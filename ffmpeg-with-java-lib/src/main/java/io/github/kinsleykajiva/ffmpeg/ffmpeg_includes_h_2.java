// Generated by jextract

package io.github.kinsleykajiva.ffmpeg;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

class ffmpeg_includes_h_2 extends ffmpeg_includes_h_3 {

    ffmpeg_includes_h_2() {
        // Should not be called directly
    }

    private static class __p__commode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p__commode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__p__commode()
     * }
     */
    public static FunctionDescriptor __p__commode$descriptor() {
        return __p__commode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__p__commode()
     * }
     */
    public static MethodHandle __p__commode$handle() {
        return __p__commode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__p__commode()
     * }
     */
    public static MemorySegment __p__commode$address() {
        return __p__commode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__p__commode()
     * }
     */
    public static MemorySegment __p__commode() {
        var mh$ = __p__commode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__commode");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfprintf$descriptor() {
        return __stdio_common_vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfprintf$handle() {
        return __stdio_common_vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfprintf$address() {
        return __stdio_common_vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfprintf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfprintf", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfprintf_s$descriptor() {
        return __stdio_common_vfprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfprintf_s$handle() {
        return __stdio_common_vfprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfprintf_s$address() {
        return __stdio_common_vfprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfprintf_s(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfprintf_s", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfprintf_p$descriptor() {
        return __stdio_common_vfprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfprintf_p$handle() {
        return __stdio_common_vfprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfprintf_p$address() {
        return __stdio_common_vfprintf_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfprintf_p(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfprintf_p", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_printf_count_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_printf_count_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _set_printf_count_output(int _Value)
     * }
     */
    public static FunctionDescriptor _set_printf_count_output$descriptor() {
        return _set_printf_count_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _set_printf_count_output(int _Value)
     * }
     */
    public static MethodHandle _set_printf_count_output$handle() {
        return _set_printf_count_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _set_printf_count_output(int _Value)
     * }
     */
    public static MemorySegment _set_printf_count_output$address() {
        return _set_printf_count_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _set_printf_count_output(int _Value)
     * }
     */
    public static int _set_printf_count_output(int _Value) {
        var mh$ = _set_printf_count_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_printf_count_output", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_printf_count_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_printf_count_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _get_printf_count_output()
     * }
     */
    public static FunctionDescriptor _get_printf_count_output$descriptor() {
        return _get_printf_count_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _get_printf_count_output()
     * }
     */
    public static MethodHandle _get_printf_count_output$handle() {
        return _get_printf_count_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _get_printf_count_output()
     * }
     */
    public static MemorySegment _get_printf_count_output$address() {
        return _get_printf_count_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _get_printf_count_output()
     * }
     */
    public static int _get_printf_count_output() {
        var mh$ = _get_printf_count_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_printf_count_output");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfscanf$descriptor() {
        return __stdio_common_vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static MethodHandle __stdio_common_vfscanf$handle() {
        return __stdio_common_vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static MemorySegment __stdio_common_vfscanf$address() {
        return __stdio_common_vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static int __stdio_common_vfscanf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _Arglist) {
        var mh$ = __stdio_common_vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfscanf", _Options, _Stream, _Format, _Locale, _Arglist);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _Arglist);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsprintf$descriptor() {
        return __stdio_common_vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsprintf$handle() {
        return __stdio_common_vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsprintf$address() {
        return __stdio_common_vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsprintf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsprintf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vsprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsprintf_s$descriptor() {
        return __stdio_common_vsprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsprintf_s$handle() {
        return __stdio_common_vsprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsprintf_s$address() {
        return __stdio_common_vsprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsprintf_s", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsnprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vsnprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsnprintf_s$descriptor() {
        return __stdio_common_vsnprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsnprintf_s$handle() {
        return __stdio_common_vsnprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsnprintf_s$address() {
        return __stdio_common_vsnprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsnprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, long _MaxCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsnprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsnprintf_s", _Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vsprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsprintf_p$descriptor() {
        return __stdio_common_vsprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsprintf_p$handle() {
        return __stdio_common_vsprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsprintf_p$address() {
        return __stdio_common_vsprintf_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsprintf_p(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsprintf_p", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsscanf$descriptor() {
        return __stdio_common_vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsscanf$handle() {
        return __stdio_common_vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsscanf$address() {
        return __stdio_common_vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsscanf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsscanf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static MemorySegment tempnam(MemorySegment _Directory, MemorySegment _FilePrefix) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", _Directory, _FilePrefix);
            }
            return (MemorySegment)mh$.invokeExact(_Directory, _FilePrefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcloseall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcloseall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fcloseall()
     * }
     */
    public static FunctionDescriptor fcloseall$descriptor() {
        return fcloseall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fcloseall()
     * }
     */
    public static MethodHandle fcloseall$handle() {
        return fcloseall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fcloseall()
     * }
     */
    public static MemorySegment fcloseall$address() {
        return fcloseall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fcloseall()
     * }
     */
    public static int fcloseall() {
        var mh$ = fcloseall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcloseall");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static MemorySegment fdopen(int _FileHandle, MemorySegment _Format) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", _FileHandle, _Format);
            }
            return (MemorySegment)mh$.invokeExact(_FileHandle, _Format);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetchar()
     * }
     */
    public static FunctionDescriptor fgetchar$descriptor() {
        return fgetchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetchar()
     * }
     */
    public static MethodHandle fgetchar$handle() {
        return fgetchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetchar()
     * }
     */
    public static MemorySegment fgetchar$address() {
        return fgetchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetchar()
     * }
     */
    public static int fgetchar() {
        var mh$ = fgetchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetchar");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fileno(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fileno(FILE *_Stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fileno(FILE *_Stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fileno(FILE *_Stream)
     * }
     */
    public static int fileno(MemorySegment _Stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flushall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flushall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flushall()
     * }
     */
    public static FunctionDescriptor flushall$descriptor() {
        return flushall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flushall()
     * }
     */
    public static MethodHandle flushall$handle() {
        return flushall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flushall()
     * }
     */
    public static MemorySegment flushall$address() {
        return flushall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flushall()
     * }
     */
    public static int flushall() {
        var mh$ = flushall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flushall");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fputchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputchar(int _Ch)
     * }
     */
    public static FunctionDescriptor fputchar$descriptor() {
        return fputchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputchar(int _Ch)
     * }
     */
    public static MethodHandle fputchar$handle() {
        return fputchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputchar(int _Ch)
     * }
     */
    public static MemorySegment fputchar$address() {
        return fputchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputchar(int _Ch)
     * }
     */
    public static int fputchar(int _Ch) {
        var mh$ = fputchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputchar", _Ch);
            }
            return (int)mh$.invokeExact(_Ch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getw(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getw(FILE *_Stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getw(FILE *_Stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getw(FILE *_Stream)
     * }
     */
    public static int getw(MemorySegment _Stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static int putw(int _Ch, MemorySegment _Stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", _Ch, _Stream);
            }
            return (int)mh$.invokeExact(_Ch, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmtmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rmtmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rmtmp()
     * }
     */
    public static FunctionDescriptor rmtmp$descriptor() {
        return rmtmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rmtmp()
     * }
     */
    public static MethodHandle rmtmp$handle() {
        return rmtmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rmtmp()
     * }
     */
    public static MemorySegment rmtmp$address() {
        return rmtmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rmtmp()
     * }
     */
    public static int rmtmp() {
        var mh$ = rmtmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmtmp");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _calloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_calloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor _calloc_base$descriptor() {
        return _calloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle _calloc_base$handle() {
        return _calloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _calloc_base$address() {
        return _calloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _calloc_base(long _Count, long _Size) {
        var mh$ = _calloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_calloc_base", _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Count, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment calloc(long _Count, long _Size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Count, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _callnewh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_callnewh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static FunctionDescriptor _callnewh$descriptor() {
        return _callnewh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static MethodHandle _callnewh$handle() {
        return _callnewh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static MemorySegment _callnewh$address() {
        return _callnewh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static int _callnewh(long _Size) {
        var mh$ = _callnewh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_callnewh", _Size);
            }
            return (int)mh$.invokeExact(_Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _expand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_expand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static FunctionDescriptor _expand$descriptor() {
        return _expand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static MethodHandle _expand$handle() {
        return _expand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _expand$address() {
        return _expand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _expand(MemorySegment _Block, long _Size) {
        var mh$ = _expand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_expand", _Block, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _free_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_free_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static FunctionDescriptor _free_base$descriptor() {
        return _free_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static MethodHandle _free_base$handle() {
        return _free_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static MemorySegment _free_base$address() {
        return _free_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static void _free_base(MemorySegment _Block) {
        var mh$ = _free_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_free_base", _Block);
            }
            mh$.invokeExact(_Block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static void free(MemorySegment _Block) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", _Block);
            }
            mh$.invokeExact(_Block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _malloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_malloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static FunctionDescriptor _malloc_base$descriptor() {
        return _malloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static MethodHandle _malloc_base$handle() {
        return _malloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static MemorySegment _malloc_base$address() {
        return _malloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static MemorySegment _malloc_base(long _Size) {
        var mh$ = _malloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_malloc_base", _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static MemorySegment malloc(long _Size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _msize_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_msize_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static FunctionDescriptor _msize_base$descriptor() {
        return _msize_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static MethodHandle _msize_base$handle() {
        return _msize_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static MemorySegment _msize_base$address() {
        return _msize_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static long _msize_base(MemorySegment _Block) {
        var mh$ = _msize_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_msize_base", _Block);
            }
            return (long)mh$.invokeExact(_Block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _msize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_msize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static FunctionDescriptor _msize$descriptor() {
        return _msize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static MethodHandle _msize$handle() {
        return _msize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static MemorySegment _msize$address() {
        return _msize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static long _msize(MemorySegment _Block) {
        var mh$ = _msize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_msize", _Block);
            }
            return (long)mh$.invokeExact(_Block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _realloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_realloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static FunctionDescriptor _realloc_base$descriptor() {
        return _realloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static MethodHandle _realloc_base$handle() {
        return _realloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _realloc_base$address() {
        return _realloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _realloc_base(MemorySegment _Block, long _Size) {
        var mh$ = _realloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_realloc_base", _Block, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment realloc(MemorySegment _Block, long _Size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", _Block, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _recalloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_recalloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor _recalloc_base$descriptor() {
        return _recalloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle _recalloc_base$handle() {
        return _recalloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc_base$address() {
        return _recalloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc_base(MemorySegment _Block, long _Count, long _Size) {
        var mh$ = _recalloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_recalloc_base", _Block, _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _recalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_recalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor _recalloc$descriptor() {
        return _recalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle _recalloc$handle() {
        return _recalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc$address() {
        return _recalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc(MemorySegment _Block, long _Count, long _Size) {
        var mh$ = _recalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_recalloc", _Block, _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static FunctionDescriptor _aligned_free$descriptor() {
        return _aligned_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static MethodHandle _aligned_free$handle() {
        return _aligned_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static MemorySegment _aligned_free$address() {
        return _aligned_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static void _aligned_free(MemorySegment _Block) {
        var mh$ = _aligned_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_free", _Block);
            }
            mh$.invokeExact(_Block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static FunctionDescriptor _aligned_malloc$descriptor() {
        return _aligned_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static MethodHandle _aligned_malloc$handle() {
        return _aligned_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_malloc$address() {
        return _aligned_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_malloc(long _Size, long _Alignment) {
        var mh$ = _aligned_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_malloc", _Size, _Alignment);
            }
            return (MemorySegment)mh$.invokeExact(_Size, _Alignment);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_offset_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_offset_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_offset_malloc$descriptor() {
        return _aligned_offset_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_offset_malloc$handle() {
        return _aligned_offset_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_malloc$address() {
        return _aligned_offset_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_malloc(long _Size, long _Alignment, long _Offset) {
        var mh$ = _aligned_offset_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_offset_malloc", _Size, _Alignment, _Offset);
            }
            return (MemorySegment)mh$.invokeExact(_Size, _Alignment, _Offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_msize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_msize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_msize$descriptor() {
        return _aligned_msize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_msize$handle() {
        return _aligned_msize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_msize$address() {
        return _aligned_msize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static long _aligned_msize(MemorySegment _Block, long _Alignment, long _Offset) {
        var mh$ = _aligned_msize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_msize", _Block, _Alignment, _Offset);
            }
            return (long)mh$.invokeExact(_Block, _Alignment, _Offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_offset_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_offset_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_offset_realloc$descriptor() {
        return _aligned_offset_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_offset_realloc$handle() {
        return _aligned_offset_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_realloc$address() {
        return _aligned_offset_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_realloc(MemorySegment _Block, long _Size, long _Alignment, long _Offset) {
        var mh$ = _aligned_offset_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_offset_realloc", _Block, _Size, _Alignment, _Offset);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size, _Alignment, _Offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_offset_recalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_offset_recalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_offset_recalloc$descriptor() {
        return _aligned_offset_recalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_offset_recalloc$handle() {
        return _aligned_offset_recalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_recalloc$address() {
        return _aligned_offset_recalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_recalloc(MemorySegment _Block, long _Count, long _Size, long _Alignment, long _Offset) {
        var mh$ = _aligned_offset_recalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_offset_recalloc", _Block, _Count, _Size, _Alignment, _Offset);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size, _Alignment, _Offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static FunctionDescriptor _aligned_realloc$descriptor() {
        return _aligned_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static MethodHandle _aligned_realloc$handle() {
        return _aligned_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_realloc$address() {
        return _aligned_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_realloc(MemorySegment _Block, long _Size, long _Alignment) {
        var mh$ = _aligned_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_realloc", _Block, _Size, _Alignment);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size, _Alignment);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_recalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_aligned_recalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static FunctionDescriptor _aligned_recalloc$descriptor() {
        return _aligned_recalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static MethodHandle _aligned_recalloc$handle() {
        return _aligned_recalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_recalloc$address() {
        return _aligned_recalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_recalloc(MemorySegment _Block, long _Count, long _Size, long _Alignment) {
        var mh$ = _aligned_recalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_recalloc", _Block, _Count, _Size, _Alignment);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size, _Alignment);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef double max_align_t
     * }
     */
    public static final OfDouble max_align_t = ffmpeg_includes_h.C_DOUBLE;

    private static class bsearch_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bsearch_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor bsearch_s$descriptor() {
        return bsearch_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle bsearch_s$handle() {
        return bsearch_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment bsearch_s$address() {
        return bsearch_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment bsearch_s(MemorySegment _Key, MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = bsearch_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_s", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("qsort_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor qsort_s$descriptor() {
        return qsort_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle qsort_s$handle() {
        return qsort_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment qsort_s$address() {
        return qsort_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static void qsort_s(MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = qsort_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_s", _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            mh$.invokeExact(_Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment bsearch(MemorySegment _Key, MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static void qsort(MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            mh$.invokeExact(_Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lfind_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_lfind_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor _lfind_s$descriptor() {
        return _lfind_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle _lfind_s$handle() {
        return _lfind_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lfind_s$address() {
        return _lfind_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lfind_s(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = _lfind_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lfind_s", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lfind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_lfind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor _lfind$descriptor() {
        return _lfind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle _lfind$handle() {
        return _lfind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lfind$address() {
        return _lfind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lfind(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = _lfind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lfind", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lsearch_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_lsearch_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor _lsearch_s$descriptor() {
        return _lsearch_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle _lsearch_s$handle() {
        return _lsearch_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lsearch_s$address() {
        return _lsearch_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lsearch_s(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = _lsearch_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lsearch_s", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_lsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor _lsearch$descriptor() {
        return _lsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle _lsearch$handle() {
        return _lsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lsearch$address() {
        return _lsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lsearch(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = _lsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lsearch", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lfind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lfind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor lfind$descriptor() {
        return lfind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle lfind$handle() {
        return lfind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lfind$address() {
        return lfind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lfind(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = lfind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lfind", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor lsearch$descriptor() {
        return lsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle lsearch$handle() {
        return lsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lsearch$address() {
        return lsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lsearch(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = lsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lsearch", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_itow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _itow_s$descriptor() {
        return _itow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _itow_s$handle() {
        return _itow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _itow_s$address() {
        return _itow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _itow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _itow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_itow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _itow$descriptor() {
        return _itow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _itow$handle() {
        return _itow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itow$address() {
        return _itow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _itow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ltow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltow_s$descriptor() {
        return _ltow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ltow_s$handle() {
        return _ltow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ltow_s$address() {
        return _ltow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ltow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ltow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ltow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltow$descriptor() {
        return _ltow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ltow$handle() {
        return _ltow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltow$address() {
        return _ltow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ltow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ultow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultow_s$descriptor() {
        return _ultow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ultow_s$handle() {
        return _ultow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ultow_s$address() {
        return _ultow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ultow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ultow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ultow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultow$descriptor() {
        return _ultow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ultow$handle() {
        return _ultow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultow$address() {
        return _ultow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ultow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstod$descriptor() {
        return wcstod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstod$handle() {
        return wcstod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MemorySegment wcstod$address() {
        return wcstod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static double wcstod(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstod", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstod_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstod_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstod_l$descriptor() {
        return _wcstod_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstod_l$handle() {
        return _wcstod_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstod_l$address() {
        return _wcstod_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _wcstod_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstod_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstod_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstol$descriptor() {
        return wcstol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstol$handle() {
        return wcstol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstol$address() {
        return wcstol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static int wcstol(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstol", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstol_l$descriptor() {
        return _wcstol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstol_l$handle() {
        return _wcstol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstol_l$address() {
        return _wcstol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _wcstol_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstol_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoll$descriptor() {
        return wcstoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoll$handle() {
        return wcstoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoll$address() {
        return wcstoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoll(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoll", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoll_l$descriptor() {
        return _wcstoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoll_l$handle() {
        return _wcstoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoll_l$address() {
        return _wcstoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoll_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoll_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoul$descriptor() {
        return wcstoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoul$handle() {
        return wcstoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoul$address() {
        return wcstoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static int wcstoul(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoul", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoul_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoul_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoul_l$descriptor() {
        return _wcstoul_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoul_l$handle() {
        return _wcstoul_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoul_l$address() {
        return _wcstoul_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _wcstoul_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoul_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoul_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoull$descriptor() {
        return wcstoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoull$handle() {
        return wcstoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoull$address() {
        return wcstoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoull(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoull", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoull_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoull_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoull_l$descriptor() {
        return _wcstoull_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoull_l$handle() {
        return _wcstoull_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoull_l$address() {
        return _wcstoull_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoull_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoull_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoull_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstold$descriptor() {
        return wcstold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstold$handle() {
        return wcstold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MemorySegment wcstold$address() {
        return wcstold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static double wcstold(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstold", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstold_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstold_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstold_l$descriptor() {
        return _wcstold_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstold_l$handle() {
        return _wcstold_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstold_l$address() {
        return _wcstold_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _wcstold_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstold_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstold_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstof$descriptor() {
        return wcstof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstof$handle() {
        return wcstof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MemorySegment wcstof$address() {
        return wcstof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static float wcstof(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstof", _String, _EndPtr);
            }
            return (float)mh$.invokeExact(_String, _EndPtr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstof_l$descriptor() {
        return _wcstof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstof_l$handle() {
        return _wcstof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstof_l$address() {
        return _wcstof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static float _wcstof_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstof_l", _String, _EndPtr, _Locale);
            }
            return (float)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtof$descriptor() {
        return _wtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtof$handle() {
        return _wtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtof$address() {
        return _wtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static double _wtof(MemorySegment _String) {
        var mh$ = _wtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtof", _String);
            }
            return (double)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtof_l$descriptor() {
        return _wtof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtof_l$handle() {
        return _wtof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtof_l$address() {
        return _wtof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static double _wtof_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtof_l", _String, _Locale);
            }
            return (double)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoi$descriptor() {
        return _wtoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoi$handle() {
        return _wtoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtoi$address() {
        return _wtoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static int _wtoi(MemorySegment _String) {
        var mh$ = _wtoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtoi_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoi_l$descriptor() {
        return _wtoi_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoi_l$handle() {
        return _wtoi_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtoi_l$address() {
        return _wtoi_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static int _wtoi_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoi_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtol$descriptor() {
        return _wtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtol$handle() {
        return _wtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtol$address() {
        return _wtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static int _wtol(MemorySegment _String) {
        var mh$ = _wtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtol", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtol_l$descriptor() {
        return _wtol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtol_l$handle() {
        return _wtol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtol_l$address() {
        return _wtol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static int _wtol_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtol_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoll$descriptor() {
        return _wtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoll$handle() {
        return _wtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtoll$address() {
        return _wtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static long _wtoll(MemorySegment _String) {
        var mh$ = _wtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoll", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoll_l$descriptor() {
        return _wtoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoll_l$handle() {
        return _wtoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtoll_l$address() {
        return _wtoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static long _wtoll_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoll_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64tow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_i64tow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64tow_s$descriptor() {
        return _i64tow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _i64tow_s$handle() {
        return _i64tow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _i64tow_s$address() {
        return _i64tow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _i64tow_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _i64tow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64tow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64tow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_i64tow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64tow$descriptor() {
        return _i64tow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _i64tow$handle() {
        return _i64tow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64tow$address() {
        return _i64tow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64tow(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _i64tow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64tow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64tow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ui64tow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64tow_s$descriptor() {
        return _ui64tow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ui64tow_s$handle() {
        return _ui64tow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow_s$address() {
        return _ui64tow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ui64tow_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ui64tow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64tow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64tow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ui64tow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64tow$descriptor() {
        return _ui64tow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ui64tow$handle() {
        return _ui64tow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow$address() {
        return _ui64tow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ui64tow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64tow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoi64$descriptor() {
        return _wtoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoi64$handle() {
        return _wtoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtoi64$address() {
        return _wtoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static long _wtoi64(MemorySegment _String) {
        var mh$ = _wtoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi64", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoi64_l$descriptor() {
        return _wtoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoi64_l$handle() {
        return _wtoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtoi64_l$address() {
        return _wtoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static long _wtoi64_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi64_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _wcstoi64$descriptor() {
        return _wcstoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _wcstoi64$handle() {
        return _wcstoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _wcstoi64$address() {
        return _wcstoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long _wcstoi64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _wcstoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoi64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoi64_l$descriptor() {
        return _wcstoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoi64_l$handle() {
        return _wcstoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoi64_l$address() {
        return _wcstoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoi64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoi64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoui64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoui64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _wcstoui64$descriptor() {
        return _wcstoui64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _wcstoui64$handle() {
        return _wcstoui64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _wcstoui64$address() {
        return _wcstoui64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long _wcstoui64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _wcstoui64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoui64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoui64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoui64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoui64_l$descriptor() {
        return _wcstoui64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoui64_l$handle() {
        return _wcstoui64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoui64_l$address() {
        return _wcstoui64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoui64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoui64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoui64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfullpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wfullpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wfullpath$descriptor() {
        return _wfullpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wfullpath$handle() {
        return _wfullpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wfullpath$address() {
        return _wfullpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wfullpath(MemorySegment _Buffer, MemorySegment _Path, long _BufferCount) {
        var mh$ = _wfullpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfullpath", _Buffer, _Path, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Path, _BufferCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmakepath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wmakepath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wmakepath_s$descriptor() {
        return _wmakepath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wmakepath_s$handle() {
        return _wmakepath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MemorySegment _wmakepath_s$address() {
        return _wmakepath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static int _wmakepath_s(MemorySegment _Buffer, long _BufferCount, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wmakepath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmakepath_s", _Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmakepath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wmakepath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wmakepath$descriptor() {
        return _wmakepath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wmakepath$handle() {
        return _wmakepath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MemorySegment _wmakepath$address() {
        return _wmakepath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static void _wmakepath(MemorySegment _Buffer, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wmakepath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmakepath", _Buffer, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_Buffer, _Drive, _Dir, _Filename, _Ext);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsplitpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wsplitpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wsplitpath$descriptor() {
        return _wsplitpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wsplitpath$handle() {
        return _wsplitpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static MemorySegment _wsplitpath$address() {
        return _wsplitpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static void _wsplitpath(MemorySegment _FullPath, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wsplitpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsplitpath", _FullPath, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_FullPath, _Drive, _Dir, _Filename, _Ext);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsplitpath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wsplitpath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static FunctionDescriptor _wsplitpath_s$descriptor() {
        return _wsplitpath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static MethodHandle _wsplitpath_s$handle() {
        return _wsplitpath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static MemorySegment _wsplitpath_s$address() {
        return _wsplitpath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static int _wsplitpath_s(MemorySegment _FullPath, MemorySegment _Drive, long _DriveCount, MemorySegment _Dir, long _DirCount, MemorySegment _Filename, long _FilenameCount, MemorySegment _Ext, long _ExtCount) {
        var mh$ = _wsplitpath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsplitpath_s", _FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
            }
            return (int)mh$.invokeExact(_FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wdupenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wdupenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wdupenv_s$descriptor() {
        return _wdupenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wdupenv_s$handle() {
        return _wdupenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wdupenv_s$address() {
        return _wdupenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static int _wdupenv_s(MemorySegment _Buffer, MemorySegment _BufferCount, MemorySegment _VarName) {
        var mh$ = _wdupenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wdupenv_s", _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _VarName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wgetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wgetenv$descriptor() {
        return _wgetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wgetenv$handle() {
        return _wgetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv$address() {
        return _wgetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv(MemorySegment _VarName) {
        var mh$ = _wgetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetenv", _VarName);
            }
            return (MemorySegment)mh$.invokeExact(_VarName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wgetenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wgetenv_s$descriptor() {
        return _wgetenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wgetenv_s$handle() {
        return _wgetenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv_s$address() {
        return _wgetenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static int _wgetenv_s(MemorySegment _RequiredCount, MemorySegment _Buffer, long _BufferCount, MemorySegment _VarName) {
        var mh$ = _wgetenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetenv_s", _RequiredCount, _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_RequiredCount, _Buffer, _BufferCount, _VarName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wputenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wputenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static FunctionDescriptor _wputenv$descriptor() {
        return _wputenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static MethodHandle _wputenv$handle() {
        return _wputenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static MemorySegment _wputenv$address() {
        return _wputenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static int _wputenv(MemorySegment _EnvString) {
        var mh$ = _wputenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wputenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wputenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wputenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static FunctionDescriptor _wputenv_s$descriptor() {
        return _wputenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static MethodHandle _wputenv_s$handle() {
        return _wputenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static MemorySegment _wputenv_s$address() {
        return _wputenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static int _wputenv_s(MemorySegment _Name, MemorySegment _Value) {
        var mh$ = _wputenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wputenv_s", _Name, _Value);
            }
            return (int)mh$.invokeExact(_Name, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsearchenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wsearchenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wsearchenv_s$descriptor() {
        return _wsearchenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wsearchenv_s$handle() {
        return _wsearchenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wsearchenv_s$address() {
        return _wsearchenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _wsearchenv_s(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _wsearchenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsearchenv_s", _Filename, _VarName, _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Filename, _VarName, _Buffer, _BufferCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsearchenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wsearchenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static FunctionDescriptor _wsearchenv$descriptor() {
        return _wsearchenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static MethodHandle _wsearchenv$handle() {
        return _wsearchenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static MemorySegment _wsearchenv$address() {
        return _wsearchenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static void _wsearchenv(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _ResultPath) {
        var mh$ = _wsearchenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsearchenv", _Filename, _VarName, _ResultPath);
            }
            mh$.invokeExact(_Filename, _VarName, _ResultPath);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsystem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wsystem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static FunctionDescriptor _wsystem$descriptor() {
        return _wsystem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static MethodHandle _wsystem$handle() {
        return _wsystem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static MemorySegment _wsystem$address() {
        return _wsystem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static int _wsystem(MemorySegment _Command) {
        var mh$ = _wsystem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsystem", _Command);
            }
            return (int)mh$.invokeExact(_Command);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static FunctionDescriptor _swab$descriptor() {
        return _swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MethodHandle _swab$handle() {
        return _swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MemorySegment _swab$address() {
        return _swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static void _swab(MemorySegment _Buf1, MemorySegment _Buf2, int _SizeInBytes) {
        var mh$ = _swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_swab", _Buf1, _Buf2, _SizeInBytes);
            }
            mh$.invokeExact(_Buf1, _Buf2, _SizeInBytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static void exit(int _Code) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static FunctionDescriptor _exit$descriptor() {
        return _exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static MethodHandle _exit$handle() {
        return _exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static MemorySegment _exit$address() {
        return _exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static void _exit(int _Code) {
        var mh$ = _exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit$ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit$.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit$.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit$.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static void _Exit(int _Code) {
        var mh$ = _Exit$.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static void quick_exit(int _Code) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_abort_behavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_abort_behavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static FunctionDescriptor _set_abort_behavior$descriptor() {
        return _set_abort_behavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static MethodHandle _set_abort_behavior$handle() {
        return _set_abort_behavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static MemorySegment _set_abort_behavior$address() {
        return _set_abort_behavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static int _set_abort_behavior(int _Flags, int _Mask) {
        var mh$ = _set_abort_behavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_abort_behavior", _Flags, _Mask);
            }
            return (int)mh$.invokeExact(_Flags, _Mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static int atexit(MemorySegment x0) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _onexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_onexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static FunctionDescriptor _onexit$descriptor() {
        return _onexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static MethodHandle _onexit$handle() {
        return _onexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment _onexit$address() {
        return _onexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment _onexit(MemorySegment _Func) {
        var mh$ = _onexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_onexit", _Func);
            }
            return (MemorySegment)mh$.invokeExact(_Func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static int at_quick_exit(MemorySegment x0) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_purecall_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_purecall_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static FunctionDescriptor _set_purecall_handler$descriptor() {
        return _set_purecall_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static MethodHandle _set_purecall_handler$handle() {
        return _set_purecall_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static MemorySegment _set_purecall_handler$address() {
        return _set_purecall_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static MemorySegment _set_purecall_handler(MemorySegment _Handler) {
        var mh$ = _set_purecall_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_purecall_handler", _Handler);
            }
            return (MemorySegment)mh$.invokeExact(_Handler);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_purecall_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_purecall_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static FunctionDescriptor _get_purecall_handler$descriptor() {
        return _get_purecall_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static MethodHandle _get_purecall_handler$handle() {
        return _get_purecall_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static MemorySegment _get_purecall_handler$address() {
        return _get_purecall_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static MemorySegment _get_purecall_handler() {
        var mh$ = _get_purecall_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_purecall_handler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static FunctionDescriptor _set_invalid_parameter_handler$descriptor() {
        return _set_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MethodHandle _set_invalid_parameter_handler$handle() {
        return _set_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_invalid_parameter_handler$address() {
        return _set_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_invalid_parameter_handler(MemorySegment _Handler) {
        var mh$ = _set_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_invalid_parameter_handler", _Handler);
            }
            return (MemorySegment)mh$.invokeExact(_Handler);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static FunctionDescriptor _get_invalid_parameter_handler$descriptor() {
        return _get_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static MethodHandle _get_invalid_parameter_handler$handle() {
        return _get_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_invalid_parameter_handler$address() {
        return _get_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_invalid_parameter_handler() {
        var mh$ = _get_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_invalid_parameter_handler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_thread_local_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_thread_local_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static FunctionDescriptor _set_thread_local_invalid_parameter_handler$descriptor() {
        return _set_thread_local_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MethodHandle _set_thread_local_invalid_parameter_handler$handle() {
        return _set_thread_local_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_thread_local_invalid_parameter_handler$address() {
        return _set_thread_local_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_thread_local_invalid_parameter_handler(MemorySegment _Handler) {
        var mh$ = _set_thread_local_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_thread_local_invalid_parameter_handler", _Handler);
            }
            return (MemorySegment)mh$.invokeExact(_Handler);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_thread_local_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_thread_local_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static FunctionDescriptor _get_thread_local_invalid_parameter_handler$descriptor() {
        return _get_thread_local_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static MethodHandle _get_thread_local_invalid_parameter_handler$handle() {
        return _get_thread_local_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_thread_local_invalid_parameter_handler$address() {
        return _get_thread_local_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_thread_local_invalid_parameter_handler() {
        var mh$ = _get_thread_local_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_thread_local_invalid_parameter_handler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_error_mode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_error_mode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static FunctionDescriptor _set_error_mode$descriptor() {
        return _set_error_mode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static MethodHandle _set_error_mode$handle() {
        return _set_error_mode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static MemorySegment _set_error_mode$address() {
        return _set_error_mode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static int _set_error_mode(int _Mode) {
        var mh$ = _set_error_mode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_error_mode", _Mode);
            }
            return (int)mh$.invokeExact(_Mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sys_errlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__sys_errlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static FunctionDescriptor __sys_errlist$descriptor() {
        return __sys_errlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static MethodHandle __sys_errlist$handle() {
        return __sys_errlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static MemorySegment __sys_errlist$address() {
        return __sys_errlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static MemorySegment __sys_errlist() {
        var mh$ = __sys_errlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sys_errlist");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sys_nerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__sys_nerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static FunctionDescriptor __sys_nerr$descriptor() {
        return __sys_nerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static MethodHandle __sys_nerr$handle() {
        return __sys_nerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static MemorySegment __sys_nerr$address() {
        return __sys_nerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static MemorySegment __sys_nerr() {
        var mh$ = __sys_nerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sys_nerr");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__pgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p__pgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static FunctionDescriptor __p__pgmptr$descriptor() {
        return __p__pgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static MethodHandle __p__pgmptr$handle() {
        return __p__pgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static MemorySegment __p__pgmptr$address() {
        return __p__pgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static MemorySegment __p__pgmptr() {
        var mh$ = __p__pgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__pgmptr");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__wpgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p__wpgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static FunctionDescriptor __p__wpgmptr$descriptor() {
        return __p__wpgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static MethodHandle __p__wpgmptr$handle() {
        return __p__wpgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static MemorySegment __p__wpgmptr$address() {
        return __p__wpgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static MemorySegment __p__wpgmptr() {
        var mh$ = __p__wpgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__wpgmptr");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__fmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p__fmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static FunctionDescriptor __p__fmode$descriptor() {
        return __p__fmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static MethodHandle __p__fmode$handle() {
        return __p__fmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static MemorySegment __p__fmode$address() {
        return __p__fmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static MemorySegment __p__fmode() {
        var mh$ = __p__fmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__fmode");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_pgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_pgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static FunctionDescriptor _get_pgmptr$descriptor() {
        return _get_pgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static MethodHandle _get_pgmptr$handle() {
        return _get_pgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static MemorySegment _get_pgmptr$address() {
        return _get_pgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static int _get_pgmptr(MemorySegment _Value) {
        var mh$ = _get_pgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_pgmptr", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_wpgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_wpgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static FunctionDescriptor _get_wpgmptr$descriptor() {
        return _get_wpgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static MethodHandle _get_wpgmptr$handle() {
        return _get_wpgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static MemorySegment _get_wpgmptr$address() {
        return _get_wpgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static int _get_wpgmptr(MemorySegment _Value) {
        var mh$ = _get_wpgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_wpgmptr", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_fmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_fmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static FunctionDescriptor _set_fmode$descriptor() {
        return _set_fmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static MethodHandle _set_fmode$handle() {
        return _set_fmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static MemorySegment _set_fmode$address() {
        return _set_fmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static int _set_fmode(int _Mode) {
        var mh$ = _set_fmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_fmode", _Mode);
            }
            return (int)mh$.invokeExact(_Mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_fmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_fmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static FunctionDescriptor _get_fmode$descriptor() {
        return _get_fmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static MethodHandle _get_fmode$handle() {
        return _get_fmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static MemorySegment _get_fmode$address() {
        return _get_fmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static int _get_fmode(MemorySegment _PMode) {
        var mh$ = _get_fmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_fmode", _PMode);
            }
            return (int)mh$.invokeExact(_PMode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _abs64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_abs64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static FunctionDescriptor _abs64$descriptor() {
        return _abs64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static MethodHandle _abs64$handle() {
        return _abs64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static MemorySegment _abs64$address() {
        return _abs64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static long _abs64(long _Number) {
        var mh$ = _abs64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_abs64", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _byteswap_ushort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_byteswap_ushort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static FunctionDescriptor _byteswap_ushort$descriptor() {
        return _byteswap_ushort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static MethodHandle _byteswap_ushort$handle() {
        return _byteswap_ushort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static MemorySegment _byteswap_ushort$address() {
        return _byteswap_ushort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static short _byteswap_ushort(short _Number) {
        var mh$ = _byteswap_ushort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_byteswap_ushort", _Number);
            }
            return (short)mh$.invokeExact(_Number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _byteswap_ulong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_byteswap_ulong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static FunctionDescriptor _byteswap_ulong$descriptor() {
        return _byteswap_ulong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static MethodHandle _byteswap_ulong$handle() {
        return _byteswap_ulong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static MemorySegment _byteswap_ulong$address() {
        return _byteswap_ulong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static int _byteswap_ulong(int _Number) {
        var mh$ = _byteswap_ulong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_byteswap_ulong", _Number);
            }
            return (int)mh$.invokeExact(_Number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _byteswap_uint64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_byteswap_uint64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static FunctionDescriptor _byteswap_uint64$descriptor() {
        return _byteswap_uint64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static MethodHandle _byteswap_uint64$handle() {
        return _byteswap_uint64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static MemorySegment _byteswap_uint64$address() {
        return _byteswap_uint64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static long _byteswap_uint64(long _Number) {
        var mh$ = _byteswap_uint64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_byteswap_uint64", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _div_t.layout(),
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int _Numerator, int _Denominator) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _ldiv_t.layout(),
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, int _Numerator, int _Denominator) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _lldiv_t$3.layout(),
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long _Numerator, long _Denominator) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_rotl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotl$descriptor() {
        return _rotl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotl$handle() {
        return _rotl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int _Value, int _Shift)
     * }
     */
    public static MemorySegment _rotl$address() {
        return _rotl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int _Value, int _Shift)
     * }
     */
    public static int _rotl(int _Value, int _Shift) {
        var mh$ = _rotl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotl", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lrotl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_lrotl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _lrotl$descriptor() {
        return _lrotl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static MethodHandle _lrotl$handle() {
        return _lrotl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static MemorySegment _lrotl$address() {
        return _lrotl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static int _lrotl(int _Value, int _Shift) {
        var mh$ = _lrotl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lrotl", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotl64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_rotl64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotl64$descriptor() {
        return _rotl64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotl64$handle() {
        return _rotl64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long _Value, int _Shift)
     * }
     */
    public static MemorySegment _rotl64$address() {
        return _rotl64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long _Value, int _Shift)
     * }
     */
    public static long _rotl64(long _Value, int _Shift) {
        var mh$ = _rotl64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotl64", _Value, _Shift);
            }
            return (long)mh$.invokeExact(_Value, _Shift);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_rotr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotr$descriptor() {
        return _rotr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotr$handle() {
        return _rotr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int _Value, int _Shift)
     * }
     */
    public static MemorySegment _rotr$address() {
        return _rotr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int _Value, int _Shift)
     * }
     */
    public static int _rotr(int _Value, int _Shift) {
        var mh$ = _rotr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotr", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lrotr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_lrotr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _lrotr$descriptor() {
        return _lrotr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static MethodHandle _lrotr$handle() {
        return _lrotr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static MemorySegment _lrotr$address() {
        return _lrotr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static int _lrotr(int _Value, int _Shift) {
        var mh$ = _lrotr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lrotr", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotr64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_rotr64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotr64$descriptor() {
        return _rotr64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotr64$handle() {
        return _rotr64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long _Value, int _Shift)
     * }
     */
    public static MemorySegment _rotr64$address() {
        return _rotr64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long _Value, int _Shift)
     * }
     */
    public static long _rotr64(long _Value, int _Shift) {
        var mh$ = _rotr64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotr64", _Value, _Shift);
            }
            return (long)mh$.invokeExact(_Value, _Shift);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static void srand(int _Seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", _Seed);
            }
            mh$.invokeExact(_Seed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static int atoi(MemorySegment _String) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static int atol(MemorySegment _String) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static long atoll(MemorySegment _String) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static FunctionDescriptor _atoi64$descriptor() {
        return _atoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static MethodHandle _atoi64$handle() {
        return _atoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static MemorySegment _atoi64$address() {
        return _atoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static long _atoi64(MemorySegment _String) {
        var mh$ = _atoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoi64", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoi_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoi_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoi_l$descriptor() {
        return _atoi_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoi_l$handle() {
        return _atoi_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoi_l$address() {
        return _atoi_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static int _atoi_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoi_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoi_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atol_l$descriptor() {
        return _atol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atol_l$handle() {
        return _atol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atol_l$address() {
        return _atol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static int _atol_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atol_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoll_l$descriptor() {
        return _atoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoll_l$handle() {
        return _atoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoll_l$address() {
        return _atoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _atoll_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoll_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoi64_l$descriptor() {
        return _atoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoi64_l$handle() {
        return _atoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoi64_l$address() {
        return _atoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _atoi64_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoi64_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoflt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoflt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static FunctionDescriptor _atoflt$descriptor() {
        return _atoflt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static MethodHandle _atoflt$handle() {
        return _atoflt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static MemorySegment _atoflt$address() {
        return _atoflt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static int _atoflt(MemorySegment _Result, MemorySegment _String) {
        var mh$ = _atoflt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoflt", _Result, _String);
            }
            return (int)mh$.invokeExact(_Result, _String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atodbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atodbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static FunctionDescriptor _atodbl$descriptor() {
        return _atodbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static MethodHandle _atodbl$handle() {
        return _atodbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static MemorySegment _atodbl$address() {
        return _atodbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static int _atodbl(MemorySegment _Result, MemorySegment _String) {
        var mh$ = _atodbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atodbl", _Result, _String);
            }
            return (int)mh$.invokeExact(_Result, _String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoldbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoldbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static FunctionDescriptor _atoldbl$descriptor() {
        return _atoldbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static MethodHandle _atoldbl$handle() {
        return _atoldbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static MemorySegment _atoldbl$address() {
        return _atoldbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static int _atoldbl(MemorySegment _Result, MemorySegment _String) {
        var mh$ = _atoldbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoldbl", _Result, _String);
            }
            return (int)mh$.invokeExact(_Result, _String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoflt_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoflt_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoflt_l$descriptor() {
        return _atoflt_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoflt_l$handle() {
        return _atoflt_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoflt_l$address() {
        return _atoflt_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static int _atoflt_l(MemorySegment _Result, MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoflt_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoflt_l", _Result, _String, _Locale);
            }
            return (int)mh$.invokeExact(_Result, _String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atodbl_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atodbl_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atodbl_l$descriptor() {
        return _atodbl_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atodbl_l$handle() {
        return _atodbl_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atodbl_l$address() {
        return _atodbl_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static int _atodbl_l(MemorySegment _Result, MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atodbl_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atodbl_l", _Result, _String, _Locale);
            }
            return (int)mh$.invokeExact(_Result, _String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoldbl_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atoldbl_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoldbl_l$descriptor() {
        return _atoldbl_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoldbl_l$handle() {
        return _atoldbl_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoldbl_l$address() {
        return _atoldbl_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static int _atoldbl_l(MemorySegment _Result, MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoldbl_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoldbl_l", _Result, _String, _Locale);
            }
            return (int)mh$.invokeExact(_Result, _String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static float strtof(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", _String, _EndPtr);
            }
            return (float)mh$.invokeExact(_String, _EndPtr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtof_l$descriptor() {
        return _strtof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtof_l$handle() {
        return _strtof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtof_l$address() {
        return _strtof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static float _strtof_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _strtof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtof_l", _String, _EndPtr, _Locale);
            }
            return (float)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static double strtod(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtod_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtod_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtod_l$descriptor() {
        return _strtod_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtod_l$handle() {
        return _strtod_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtod_l$address() {
        return _strtod_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _strtod_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _strtod_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtod_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static FunctionDescriptor strtold$descriptor() {
        return strtold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static MethodHandle strtold$handle() {
        return strtold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static MemorySegment strtold$address() {
        return strtold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static double strtold(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = strtold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtold", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtold_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtold_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtold_l$descriptor() {
        return _strtold_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtold_l$handle() {
        return _strtold_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtold_l$address() {
        return _strtold_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _strtold_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _strtold_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtold_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static int strtol(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtol_l$descriptor() {
        return _strtol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtol_l$handle() {
        return _strtol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtol_l$address() {
        return _strtol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _strtol_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtol_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoll(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoll_l$descriptor() {
        return _strtoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoll_l$handle() {
        return _strtoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoll_l$address() {
        return _strtoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoll_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoll_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static int strtoul(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoul_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoul_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoul_l$descriptor() {
        return _strtoul_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoul_l$handle() {
        return _strtoul_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoul_l$address() {
        return _strtoul_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _strtoul_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoul_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoul_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoull(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoull_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoull_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoull_l$descriptor() {
        return _strtoull_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoull_l$handle() {
        return _strtoull_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoull_l$address() {
        return _strtoull_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoull_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoull_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoull_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _strtoi64$descriptor() {
        return _strtoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _strtoi64$handle() {
        return _strtoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _strtoi64$address() {
        return _strtoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long _strtoi64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _strtoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoi64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoi64_l$descriptor() {
        return _strtoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoi64_l$handle() {
        return _strtoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoi64_l$address() {
        return _strtoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoi64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoi64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoui64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoui64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _strtoui64$descriptor() {
        return _strtoui64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _strtoui64$handle() {
        return _strtoui64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _strtoui64$address() {
        return _strtoui64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long _strtoui64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _strtoui64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoui64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoui64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoui64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoui64_l$descriptor() {
        return _strtoui64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoui64_l$handle() {
        return _strtoui64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoui64_l$address() {
        return _strtoui64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoui64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoui64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoui64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_itoa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _itoa_s$descriptor() {
        return _itoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _itoa_s$handle() {
        return _itoa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _itoa_s$address() {
        return _itoa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _itoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _itoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_itoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _itoa$descriptor() {
        return _itoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _itoa$handle() {
        return _itoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itoa$address() {
        return _itoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _itoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ltoa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltoa_s$descriptor() {
        return _ltoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ltoa_s$handle() {
        return _ltoa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ltoa_s$address() {
        return _ltoa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ltoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ltoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ltoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltoa$descriptor() {
        return _ltoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ltoa$handle() {
        return _ltoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltoa$address() {
        return _ltoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ltoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ultoa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultoa_s$descriptor() {
        return _ultoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ultoa_s$handle() {
        return _ultoa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ultoa_s$address() {
        return _ultoa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ultoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ultoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ultoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultoa$descriptor() {
        return _ultoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ultoa$handle() {
        return _ultoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultoa$address() {
        return _ultoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ultoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64toa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_i64toa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64toa_s$descriptor() {
        return _i64toa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _i64toa_s$handle() {
        return _i64toa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _i64toa_s$address() {
        return _i64toa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _i64toa_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _i64toa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64toa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64toa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_i64toa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64toa$descriptor() {
        return _i64toa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _i64toa$handle() {
        return _i64toa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64toa$address() {
        return _i64toa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64toa(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _i64toa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64toa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64toa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ui64toa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64toa_s$descriptor() {
        return _ui64toa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ui64toa_s$handle() {
        return _ui64toa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa_s$address() {
        return _ui64toa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ui64toa_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ui64toa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64toa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64toa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ui64toa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64toa$descriptor() {
        return _ui64toa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ui64toa$handle() {
        return _ui64toa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa$address() {
        return _ui64toa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ui64toa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64toa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ecvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ecvt_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _ecvt_s$descriptor() {
        return _ecvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _ecvt_s$handle() {
        return _ecvt_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt_s$address() {
        return _ecvt_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static int _ecvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _ecvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ecvt_s", _Buffer, _BufferCount, _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _DigitCount, _PtDec, _PtSign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _ecvt$descriptor() {
        return _ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _ecvt$handle() {
        return _ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt$address() {
        return _ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt(double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ecvt", _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _PtDec, _PtSign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fcvt_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _fcvt_s$descriptor() {
        return _fcvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _fcvt_s$handle() {
        return _fcvt_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt_s$address() {
        return _fcvt_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static int _fcvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _fcvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcvt_s", _Buffer, _BufferCount, _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _fcvt$descriptor() {
        return _fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _fcvt$handle() {
        return _fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt$address() {
        return _fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt(double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcvt", _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gcvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_gcvt_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static FunctionDescriptor _gcvt_s$descriptor() {
        return _gcvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static MethodHandle _gcvt_s$handle() {
        return _gcvt_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static MemorySegment _gcvt_s$address() {
        return _gcvt_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static int _gcvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _DigitCount) {
        var mh$ = _gcvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gcvt_s", _Buffer, _BufferCount, _Value, _DigitCount);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _DigitCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static FunctionDescriptor _gcvt$descriptor() {
        return _gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MethodHandle _gcvt$handle() {
        return _gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MemorySegment _gcvt$address() {
        return _gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MemorySegment _gcvt(double _Value, int _DigitCount, MemorySegment _Buffer) {
        var mh$ = _gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gcvt", _Value, _DigitCount, _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _Buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___mb_cur_max_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("___mb_cur_max_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static FunctionDescriptor ___mb_cur_max_func$descriptor() {
        return ___mb_cur_max_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static MethodHandle ___mb_cur_max_func$handle() {
        return ___mb_cur_max_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static MemorySegment ___mb_cur_max_func$address() {
        return ___mb_cur_max_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static int ___mb_cur_max_func() {
        var mh$ = ___mb_cur_max_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___mb_cur_max_func");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___mb_cur_max_l_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("___mb_cur_max_l_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static FunctionDescriptor ___mb_cur_max_l_func$descriptor() {
        return ___mb_cur_max_l_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static MethodHandle ___mb_cur_max_l_func$handle() {
        return ___mb_cur_max_l_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static MemorySegment ___mb_cur_max_l_func$address() {
        return ___mb_cur_max_l_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static int ___mb_cur_max_l_func(MemorySegment _Locale) {
        var mh$ = ___mb_cur_max_l_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___mb_cur_max_l_func", _Locale);
            }
            return (int)mh$.invokeExact(_Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static int mblen(MemorySegment _Ch, long _MaxCount) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", _Ch, _MaxCount);
            }
            return (int)mh$.invokeExact(_Ch, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mblen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mblen_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mblen_l$descriptor() {
        return _mblen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mblen_l$handle() {
        return _mblen_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mblen_l$address() {
        return _mblen_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _mblen_l(MemorySegment _Ch, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mblen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mblen_l", _Ch, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_Ch, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mbstrlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static FunctionDescriptor _mbstrlen$descriptor() {
        return _mbstrlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static MethodHandle _mbstrlen$handle() {
        return _mbstrlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static MemorySegment _mbstrlen$address() {
        return _mbstrlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static long _mbstrlen(MemorySegment _String) {
        var mh$ = _mbstrlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrlen", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrlen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mbstrlen_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstrlen_l$descriptor() {
        return _mbstrlen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstrlen_l$handle() {
        return _mbstrlen_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstrlen_l$address() {
        return _mbstrlen_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _mbstrlen_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _mbstrlen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrlen_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mbstrnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _mbstrnlen$descriptor() {
        return _mbstrnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MethodHandle _mbstrnlen$handle() {
        return _mbstrnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MemorySegment _mbstrnlen$address() {
        return _mbstrnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static long _mbstrnlen(MemorySegment _String, long _MaxCount) {
        var mh$ = _mbstrnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrnlen", _String, _MaxCount);
            }
            return (long)mh$.invokeExact(_String, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrnlen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mbstrnlen_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstrnlen_l$descriptor() {
        return _mbstrnlen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstrnlen_l$handle() {
        return _mbstrnlen_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstrnlen_l$address() {
        return _mbstrnlen_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _mbstrnlen_l(MemorySegment _String, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstrnlen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrnlen_l", _String, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_String, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static int mbtowc(MemorySegment _DstCh, MemorySegment _SrcCh, long _SrcSizeInBytes) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", _DstCh, _SrcCh, _SrcSizeInBytes);
            }
            return (int)mh$.invokeExact(_DstCh, _SrcCh, _SrcSizeInBytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbtowc_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mbtowc_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbtowc_l$descriptor() {
        return _mbtowc_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbtowc_l$handle() {
        return _mbtowc_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbtowc_l$address() {
        return _mbtowc_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static int _mbtowc_l(MemorySegment _DstCh, MemorySegment _SrcCh, long _SrcSizeInBytes, MemorySegment _Locale) {
        var mh$ = _mbtowc_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbtowc_l", _DstCh, _SrcCh, _SrcSizeInBytes, _Locale);
            }
            return (int)mh$.invokeExact(_DstCh, _SrcCh, _SrcSizeInBytes, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbstowcs_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mbstowcs_s$descriptor() {
        return mbstowcs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static MethodHandle mbstowcs_s$handle() {
        return mbstowcs_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static MemorySegment mbstowcs_s$address() {
        return mbstowcs_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static int mbstowcs_s(MemorySegment _PtNumOfCharConverted, MemorySegment _DstBuf, long _SizeInWords, MemorySegment _SrcBuf, long _MaxCount) {
        var mh$ = mbstowcs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs_s", _PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static long mbstowcs(MemorySegment _Dest, MemorySegment _Source, long _MaxCount) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", _Dest, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstowcs_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mbstowcs_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstowcs_s_l$descriptor() {
        return _mbstowcs_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstowcs_s_l$handle() {
        return _mbstowcs_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstowcs_s_l$address() {
        return _mbstowcs_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _mbstowcs_s_l(MemorySegment _PtNumOfCharConverted, MemorySegment _DstBuf, long _SizeInWords, MemorySegment _SrcBuf, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstowcs_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstowcs_s_l", _PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstowcs_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_mbstowcs_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstowcs_l$descriptor() {
        return _mbstowcs_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstowcs_l$handle() {
        return _mbstowcs_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstowcs_l$address() {
        return _mbstowcs_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _mbstowcs_l(MemorySegment _Dest, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstowcs_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstowcs_l", _Dest, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static int wctomb(MemorySegment _MbCh, short _WCh) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", _MbCh, _WCh);
            }
            return (int)mh$.invokeExact(_MbCh, _WCh);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctomb_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wctomb_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wctomb_l$descriptor() {
        return _wctomb_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wctomb_l$handle() {
        return _wctomb_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wctomb_l$address() {
        return _wctomb_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static int _wctomb_l(MemorySegment _MbCh, short _WCh, MemorySegment _Locale) {
        var mh$ = _wctomb_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctomb_l", _MbCh, _WCh, _Locale);
            }
            return (int)mh$.invokeExact(_MbCh, _WCh, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wctomb_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static FunctionDescriptor wctomb_s$descriptor() {
        return wctomb_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static MethodHandle wctomb_s$handle() {
        return wctomb_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static MemorySegment wctomb_s$address() {
        return wctomb_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static int wctomb_s(MemorySegment _SizeConverted, MemorySegment _MbCh, long _SizeInBytes, short _WCh) {
        var mh$ = wctomb_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb_s", _SizeConverted, _MbCh, _SizeInBytes, _WCh);
            }
            return (int)mh$.invokeExact(_SizeConverted, _MbCh, _SizeInBytes, _WCh);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctomb_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wctomb_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wctomb_s_l$descriptor() {
        return _wctomb_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wctomb_s_l$handle() {
        return _wctomb_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wctomb_s_l$address() {
        return _wctomb_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static int _wctomb_s_l(MemorySegment _SizeConverted, MemorySegment _MbCh, long _SizeInBytes, short _WCh, MemorySegment _Locale) {
        var mh$ = _wctomb_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctomb_s_l", _SizeConverted, _MbCh, _SizeInBytes, _WCh, _Locale);
            }
            return (int)mh$.invokeExact(_SizeConverted, _MbCh, _SizeInBytes, _WCh, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstombs_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static FunctionDescriptor wcstombs_s$descriptor() {
        return wcstombs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static MethodHandle wcstombs_s$handle() {
        return wcstombs_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static MemorySegment wcstombs_s$address() {
        return wcstombs_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static int wcstombs_s(MemorySegment _PtNumOfCharConverted, MemorySegment _Dst, long _DstSizeInBytes, MemorySegment _Src, long _MaxCountInBytes) {
        var mh$ = wcstombs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs_s", _PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcstombs(MemorySegment _Dest, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", _Dest, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstombs_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstombs_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstombs_s_l$descriptor() {
        return _wcstombs_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstombs_s_l$handle() {
        return _wcstombs_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstombs_s_l$address() {
        return _wcstombs_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static int _wcstombs_s_l(MemorySegment _PtNumOfCharConverted, MemorySegment _Dst, long _DstSizeInBytes, MemorySegment _Src, long _MaxCountInBytes, MemorySegment _Locale) {
        var mh$ = _wcstombs_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstombs_s_l", _PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes, _Locale);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstombs_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstombs_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstombs_l$descriptor() {
        return _wcstombs_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstombs_l$handle() {
        return _wcstombs_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstombs_l$address() {
        return _wcstombs_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _wcstombs_l(MemorySegment _Dest, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcstombs_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstombs_l", _Dest, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fullpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fullpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _fullpath$descriptor() {
        return _fullpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MethodHandle _fullpath$handle() {
        return _fullpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _fullpath$address() {
        return _fullpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _fullpath(MemorySegment _Buffer, MemorySegment _Path, long _BufferCount) {
        var mh$ = _fullpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fullpath", _Buffer, _Path, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Path, _BufferCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _makepath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_makepath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static FunctionDescriptor _makepath_s$descriptor() {
        return _makepath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MethodHandle _makepath_s$handle() {
        return _makepath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MemorySegment _makepath_s$address() {
        return _makepath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static int _makepath_s(MemorySegment _Buffer, long _BufferCount, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _makepath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_makepath_s", _Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _makepath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_makepath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static FunctionDescriptor _makepath$descriptor() {
        return _makepath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MethodHandle _makepath$handle() {
        return _makepath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MemorySegment _makepath$address() {
        return _makepath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static void _makepath(MemorySegment _Buffer, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _makepath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_makepath", _Buffer, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_Buffer, _Drive, _Dir, _Filename, _Ext);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _splitpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_splitpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static FunctionDescriptor _splitpath$descriptor() {
        return _splitpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static MethodHandle _splitpath$handle() {
        return _splitpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static MemorySegment _splitpath$address() {
        return _splitpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static void _splitpath(MemorySegment _FullPath, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _splitpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_splitpath", _FullPath, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_FullPath, _Drive, _Dir, _Filename, _Ext);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _splitpath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_splitpath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static FunctionDescriptor _splitpath_s$descriptor() {
        return _splitpath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static MethodHandle _splitpath_s$handle() {
        return _splitpath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static MemorySegment _splitpath_s$address() {
        return _splitpath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static int _splitpath_s(MemorySegment _FullPath, MemorySegment _Drive, long _DriveCount, MemorySegment _Dir, long _DirCount, MemorySegment _Filename, long _FilenameCount, MemorySegment _Ext, long _ExtCount) {
        var mh$ = _splitpath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_splitpath_s", _FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
            }
            return (int)mh$.invokeExact(_FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static FunctionDescriptor getenv_s$descriptor() {
        return getenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static MethodHandle getenv_s$handle() {
        return getenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static MemorySegment getenv_s$address() {
        return getenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static int getenv_s(MemorySegment _RequiredCount, MemorySegment _Buffer, long _BufferCount, MemorySegment _VarName) {
        var mh$ = getenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv_s", _RequiredCount, _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_RequiredCount, _Buffer, _BufferCount, _VarName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___argc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p___argc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static FunctionDescriptor __p___argc$descriptor() {
        return __p___argc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MethodHandle __p___argc$handle() {
        return __p___argc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MemorySegment __p___argc$address() {
        return __p___argc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MemorySegment __p___argc() {
        var mh$ = __p___argc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___argc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___argv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p___argv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static FunctionDescriptor __p___argv$descriptor() {
        return __p___argv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MethodHandle __p___argv$handle() {
        return __p___argv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MemorySegment __p___argv$address() {
        return __p___argv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MemorySegment __p___argv() {
        var mh$ = __p___argv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___argv");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___wargv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p___wargv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static FunctionDescriptor __p___wargv$descriptor() {
        return __p___wargv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MethodHandle __p___wargv$handle() {
        return __p___wargv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MemorySegment __p___wargv$address() {
        return __p___wargv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MemorySegment __p___wargv() {
        var mh$ = __p___wargv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___wargv");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__environ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p__environ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static FunctionDescriptor __p__environ$descriptor() {
        return __p__environ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MethodHandle __p__environ$handle() {
        return __p__environ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MemorySegment __p__environ$address() {
        return __p__environ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MemorySegment __p__environ() {
        var mh$ = __p__environ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__environ");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__wenviron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__p__wenviron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static FunctionDescriptor __p__wenviron$descriptor() {
        return __p__wenviron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MethodHandle __p__wenviron$handle() {
        return __p__wenviron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MemorySegment __p__wenviron$address() {
        return __p__wenviron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MemorySegment __p__wenviron() {
        var mh$ = __p__wenviron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__wenviron");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MemorySegment getenv(MemorySegment _VarName) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", _VarName);
            }
            return (MemorySegment)mh$.invokeExact(_VarName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dupenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_dupenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static FunctionDescriptor _dupenv_s$descriptor() {
        return _dupenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static MethodHandle _dupenv_s$handle() {
        return _dupenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static MemorySegment _dupenv_s$address() {
        return _dupenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static int _dupenv_s(MemorySegment _Buffer, MemorySegment _BufferCount, MemorySegment _VarName) {
        var mh$ = _dupenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dupenv_s", _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _VarName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static int system(MemorySegment _Command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", _Command);
            }
            return (int)mh$.invokeExact(_Command);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static FunctionDescriptor _putenv$descriptor() {
        return _putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static MethodHandle _putenv$handle() {
        return _putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static MemorySegment _putenv$address() {
        return _putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static int _putenv(MemorySegment _EnvString) {
        var mh$ = _putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_putenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static FunctionDescriptor _putenv_s$descriptor() {
        return _putenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static MethodHandle _putenv_s$handle() {
        return _putenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static MemorySegment _putenv_s$address() {
        return _putenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static int _putenv_s(MemorySegment _Name, MemorySegment _Value) {
        var mh$ = _putenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putenv_s", _Name, _Value);
            }
            return (int)mh$.invokeExact(_Name, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _searchenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_searchenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _searchenv_s$descriptor() {
        return _searchenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _searchenv_s$handle() {
        return _searchenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _searchenv_s$address() {
        return _searchenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _searchenv_s(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _searchenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_searchenv_s", _Filename, _VarName, _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Filename, _VarName, _Buffer, _BufferCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _searchenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_searchenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static FunctionDescriptor _searchenv$descriptor() {
        return _searchenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static MethodHandle _searchenv$handle() {
        return _searchenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static MemorySegment _searchenv$address() {
        return _searchenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static void _searchenv(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer) {
        var mh$ = _searchenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_searchenv", _Filename, _VarName, _Buffer);
            }
            mh$.invokeExact(_Filename, _VarName, _Buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _seterrormode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_seterrormode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static FunctionDescriptor _seterrormode$descriptor() {
        return _seterrormode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static MethodHandle _seterrormode$handle() {
        return _seterrormode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static MemorySegment _seterrormode$address() {
        return _seterrormode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static void _seterrormode(int _Mode) {
        var mh$ = _seterrormode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_seterrormode", _Mode);
            }
            mh$.invokeExact(_Mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _beep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_beep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static FunctionDescriptor _beep$descriptor() {
        return _beep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static MethodHandle _beep$handle() {
        return _beep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static MemorySegment _beep$address() {
        return _beep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static void _beep(int _Frequency, int _Duration) {
        var mh$ = _beep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_beep", _Frequency, _Duration);
            }
            mh$.invokeExact(_Frequency, _Duration);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_sleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static FunctionDescriptor _sleep$descriptor() {
        return _sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static MethodHandle _sleep$handle() {
        return _sleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static MemorySegment _sleep$address() {
        return _sleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static void _sleep(int _Duration) {
        var mh$ = _sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_sleep", _Duration);
            }
            mh$.invokeExact(_Duration);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment ecvt(double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _PtDec, _PtSign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment fcvt(double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MemorySegment gcvt(double _Value, int _DigitCount, MemorySegment _DstBuf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", _Value, _DigitCount, _DstBuf);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _DstBuf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class itoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("itoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor itoa$descriptor() {
        return itoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle itoa$handle() {
        return itoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment itoa$address() {
        return itoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment itoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = itoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("itoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ltoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ltoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor ltoa$descriptor() {
        return ltoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle ltoa$handle() {
        return ltoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ltoa$address() {
        return ltoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ltoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = ltoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ltoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MemorySegment swab$address() {
        return swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static void swab(MemorySegment _Buf1, MemorySegment _Buf2, int _SizeInBytes) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", _Buf1, _Buf2, _SizeInBytes);
            }
            mh$.invokeExact(_Buf1, _Buf2, _SizeInBytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ultoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ultoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor ultoa$descriptor() {
        return ultoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle ultoa$handle() {
        return ultoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ultoa$address() {
        return ultoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ultoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = ultoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ultoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static int putenv(MemorySegment _EnvString) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class onexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("onexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static FunctionDescriptor onexit$descriptor() {
        return onexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MethodHandle onexit$handle() {
        return onexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment onexit$address() {
        return onexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment onexit(MemorySegment _Func) {
        var mh$ = onexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("onexit", _Func);
            }
            return (MemorySegment)mh$.invokeExact(_Func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memchr(const void *_Buf, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment memchr(MemorySegment _Buf, int _Val, long _MaxCount) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", _Buf, _Val, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buf, _Val, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memcmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int memcmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memcpy(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memcpy(MemorySegment _Dst, MemorySegment _Src, long _Size) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", _Dst, _Src, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmove(void *_Dst, const void *_Src, size_t _Size)
     * }
     */
    public static MemorySegment memmove(MemorySegment _Dst, MemorySegment _Src, long _Size) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", _Dst, _Src, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memset(void *_Dst, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memset(MemorySegment _Dst, int _Val, long _Size) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", _Dst, _Val, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Val, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchr(const char *_Str, int _Val)
     * }
     */
    public static MemorySegment strchr(MemorySegment _Str, int _Val) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", _Str, _Val);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrchr(const char *_Str, int _Ch)
     * }
     */
    public static MemorySegment strrchr(MemorySegment _Str, int _Ch) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strstr(const char *_Str, const char *_SubStr)
     * }
     */
    public static MemorySegment strstr(MemorySegment _Str, MemorySegment _SubStr) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", _Str, _SubStr);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _SubStr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcschr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcschr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static FunctionDescriptor wcschr$descriptor() {
        return wcschr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MethodHandle wcschr$handle() {
        return wcschr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcschr$address() {
        return wcschr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *wcschr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcschr(MemorySegment _Str, short _Ch) {
        var mh$ = wcschr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcschr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static FunctionDescriptor wcsrchr$descriptor() {
        return wcsrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MethodHandle wcsrchr$handle() {
        return wcsrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcsrchr$address() {
        return wcsrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *_Str, wchar_t _Ch)
     * }
     */
    public static MemorySegment wcsrchr(MemorySegment _Str, short _Ch) {
        var mh$ = wcsrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrchr", _Str, _Ch);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Ch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static FunctionDescriptor wcsstr$descriptor() {
        return wcsstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MethodHandle wcsstr$handle() {
        return wcsstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MemorySegment wcsstr$address() {
        return wcsstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *_Str, const wchar_t *_SubStr)
     * }
     */
    public static MemorySegment wcsstr(MemorySegment _Str, MemorySegment _SubStr) {
        var mh$ = wcsstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsstr", _Str, _SubStr);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _SubStr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _memicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_memicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor _memicmp$descriptor() {
        return _memicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle _memicmp$handle() {
        return _memicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment _memicmp$address() {
        return _memicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int _memicmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = _memicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_memicmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _memicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_memicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _memicmp_l$descriptor() {
        return _memicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _memicmp_l$handle() {
        return _memicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _memicmp_l$address() {
        return _memicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _memicmp_l(const void *_Buf1, const void *_Buf2, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _memicmp_l(MemorySegment _Buf1, MemorySegment _Buf2, long _Size, MemorySegment _Locale) {
        var mh$ = _memicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_memicmp_l", _Buf1, _Buf2, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memccpy(void *_Dst, const void *_Src, int _Val, size_t _Size)
     * }
     */
    public static MemorySegment memccpy(MemorySegment _Dst, MemorySegment _Src, int _Val, long _Size) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", _Dst, _Src, _Val, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Val, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static FunctionDescriptor memicmp$descriptor() {
        return memicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MethodHandle memicmp$handle() {
        return memicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static MemorySegment memicmp$address() {
        return memicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memicmp(const void *_Buf1, const void *_Buf2, size_t _Size)
     * }
     */
    public static int memicmp(MemorySegment _Buf1, MemorySegment _Buf2, long _Size) {
        var mh$ = memicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memicmp", _Buf1, _Buf2, _Size);
            }
            return (int)mh$.invokeExact(_Buf1, _Buf2, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcscat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscat_s$descriptor() {
        return wcscat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscat_s$handle() {
        return wcscat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat_s$address() {
        return wcscat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcscat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static int wcscat_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source) {
        var mh$ = wcscat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscat_s", _Destination, _SizeInWords, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcscpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscpy_s$descriptor() {
        return wcscpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscpy_s$handle() {
        return wcscpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy_s$address() {
        return wcscpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcscpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source)
     * }
     */
    public static int wcscpy_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source) {
        var mh$ = wcscpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscpy_s", _Destination, _SizeInWords, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsncat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncat_s$descriptor() {
        return wcsncat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncat_s$handle() {
        return wcsncat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncat_s$address() {
        return wcsncat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcsncat_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static int wcsncat_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsncat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncat_s", _Destination, _SizeInWords, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsncpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncpy_s$descriptor() {
        return wcsncpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncpy_s$handle() {
        return wcsncpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncpy_s$address() {
        return wcsncpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcsncpy_s(wchar_t *_Destination, rsize_t _SizeInWords, const wchar_t *_Source, rsize_t _MaxCount)
     * }
     */
    public static int wcsncpy_s(MemorySegment _Destination, long _SizeInWords, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsncpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncpy_s", _Destination, _SizeInWords, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstok_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstok_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static FunctionDescriptor wcstok_s$descriptor() {
        return wcstok_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MethodHandle wcstok_s$handle() {
        return wcstok_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok_s$address() {
        return wcstok_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcstok_s(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok_s(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = wcstok_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstok_s", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsdup$descriptor() {
        return _wcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsdup$handle() {
        return _wcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsdup$address() {
        return _wcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsdup(MemorySegment _String) {
        var mh$ = _wcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcscat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscat$descriptor() {
        return wcscat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscat$handle() {
        return wcscat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat$address() {
        return wcscat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscat(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = wcscat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscat", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcscmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcscmp$descriptor() {
        return wcscmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcscmp$handle() {
        return wcscmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcscmp$address() {
        return wcscmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcscmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcscmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcscpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static FunctionDescriptor wcscpy$descriptor() {
        return wcscpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MethodHandle wcscpy$handle() {
        return wcscpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy$address() {
        return wcscpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *_Destination, const wchar_t *_Source)
     * }
     */
    public static MemorySegment wcscpy(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = wcscpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscpy", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcscspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcscspn$descriptor() {
        return wcscspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcscspn$handle() {
        return wcscspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcscspn$address() {
        return wcscspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static long wcscspn(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcscspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscspn", _String, _Control);
            }
            return (long)mh$.invokeExact(_String, _Control);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcslen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcslen$descriptor() {
        return wcslen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static MethodHandle wcslen$handle() {
        return wcslen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcslen$address() {
        return wcslen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long wcslen(const wchar_t *_String)
     * }
     */
    public static long wcslen(MemorySegment _String) {
        var mh$ = wcslen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslen", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnlen$descriptor() {
        return wcsnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnlen$handle() {
        return wcsnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnlen$address() {
        return wcsnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcsnlen(MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnlen", _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor wcsncat$descriptor() {
        return wcsncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MethodHandle wcsncat$handle() {
        return wcsncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncat$address() {
        return wcsncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncat(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = wcsncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncat", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsncmp$descriptor() {
        return wcsncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsncmp$handle() {
        return wcsncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsncmp$address() {
        return wcsncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int wcsncmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = wcsncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor wcsncpy$descriptor() {
        return wcsncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MethodHandle wcsncpy$handle() {
        return wcsncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncpy$address() {
        return wcsncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *_Destination, const wchar_t *_Source, size_t _Count)
     * }
     */
    public static MemorySegment wcsncpy(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = wcsncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncpy", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcspbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcspbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcspbrk$descriptor() {
        return wcspbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcspbrk$handle() {
        return wcspbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcspbrk$address() {
        return wcspbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcspbrk(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcspbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcspbrk", _String, _Control);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Control);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static FunctionDescriptor wcsspn$descriptor() {
        return wcsspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MethodHandle wcsspn$handle() {
        return wcsspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static MemorySegment wcsspn$address() {
        return wcsspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *_String, const wchar_t *_Control)
     * }
     */
    public static long wcsspn(MemorySegment _String, MemorySegment _Control) {
        var mh$ = wcsspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsspn", _String, _Control);
            }
            return (long)mh$.invokeExact(_String, _Control);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static FunctionDescriptor wcstok$descriptor() {
        return wcstok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MethodHandle wcstok$handle() {
        return wcstok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok$address() {
        return wcstok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *_String, const wchar_t *_Delimiter, wchar_t **_Context)
     * }
     */
    public static MemorySegment wcstok(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = wcstok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstok", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcserror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcserror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor _wcserror$descriptor() {
        return _wcserror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MethodHandle _wcserror$handle() {
        return _wcserror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror$address() {
        return _wcserror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcserror(int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror(int _ErrorNumber) {
        var mh$ = _wcserror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcserror", _ErrorNumber);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorNumber);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcserror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcserror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor _wcserror_s$descriptor() {
        return _wcserror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static MethodHandle _wcserror_s$handle() {
        return _wcserror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static MemorySegment _wcserror_s$address() {
        return _wcserror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, int _ErrorNumber)
     * }
     */
    public static int _wcserror_s(MemorySegment _Buffer, long _SizeInWords, int _ErrorNumber) {
        var mh$ = _wcserror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcserror_s", _Buffer, _SizeInWords, _ErrorNumber);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _ErrorNumber);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __wcserror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__wcserror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor __wcserror$descriptor() {
        return __wcserror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MethodHandle __wcserror$handle() {
        return __wcserror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MemorySegment __wcserror$address() {
        return __wcserror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *__wcserror(const wchar_t *_String)
     * }
     */
    public static MemorySegment __wcserror(MemorySegment _String) {
        var mh$ = __wcserror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__wcserror", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __wcserror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__wcserror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor __wcserror_s$descriptor() {
        return __wcserror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static MethodHandle __wcserror_s$handle() {
        return __wcserror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static MemorySegment __wcserror_s$address() {
        return __wcserror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t __wcserror_s(wchar_t *_Buffer, size_t _SizeInWords, const wchar_t *_ErrorMessage)
     * }
     */
    public static int __wcserror_s(MemorySegment _Buffer, long _SizeInWords, MemorySegment _ErrorMessage) {
        var mh$ = __wcserror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__wcserror_s", _Buffer, _SizeInWords, _ErrorMessage);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInWords, _ErrorMessage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor _wcsicmp$descriptor() {
        return _wcsicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle _wcsicmp$handle() {
        return _wcsicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment _wcsicmp$address() {
        return _wcsicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int _wcsicmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _wcsicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsicmp_l$descriptor() {
        return _wcsicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsicmp_l$handle() {
        return _wcsicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsicmp_l$address() {
        return _wcsicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicmp_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcsicmp_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcsicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicmp_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnicmp$descriptor() {
        return _wcsnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnicmp$handle() {
        return _wcsnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnicmp$address() {
        return _wcsnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsnicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsnicmp_l$descriptor() {
        return _wcsnicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsnicmp_l$handle() {
        return _wcsnicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsnicmp_l$address() {
        return _wcsnicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicmp_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsnicmp_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsnicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicmp_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsnset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnset_s$descriptor() {
        return _wcsnset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnset_s$handle() {
        return _wcsnset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset_s$address() {
        return _wcsnset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsnset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static int _wcsnset_s(MemorySegment _Destination, long _SizeInWords, short _Value, long _MaxCount) {
        var mh$ = _wcsnset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnset_s", _Destination, _SizeInWords, _Value, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Value, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnset$descriptor() {
        return _wcsnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnset$handle() {
        return _wcsnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset$address() {
        return _wcsnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnset(MemorySegment _String, short _Value, long _MaxCount) {
        var mh$ = _wcsnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsrev$descriptor() {
        return _wcsrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsrev$handle() {
        return _wcsrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsrev$address() {
        return _wcsrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsrev(MemorySegment _String) {
        var mh$ = _wcsrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor _wcsset_s$descriptor() {
        return _wcsset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static MethodHandle _wcsset_s$handle() {
        return _wcsset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset_s$address() {
        return _wcsset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsset_s(wchar_t *_Destination, size_t _SizeInWords, wchar_t _Value)
     * }
     */
    public static int _wcsset_s(MemorySegment _Destination, long _SizeInWords, short _Value) {
        var mh$ = _wcsset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsset_s", _Destination, _SizeInWords, _Value);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInWords, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor _wcsset$descriptor() {
        return _wcsset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MethodHandle _wcsset$handle() {
        return _wcsset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset$address() {
        return _wcsset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment _wcsset(MemorySegment _String, short _Value) {
        var mh$ = _wcsset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcslwr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static FunctionDescriptor _wcslwr_s$descriptor() {
        return _wcslwr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static MethodHandle _wcslwr_s$handle() {
        return _wcslwr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static MemorySegment _wcslwr_s$address() {
        return _wcslwr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcslwr_s(wchar_t *_String, size_t _SizeInWords)
     * }
     */
    public static int _wcslwr_s(MemorySegment _String, long _SizeInWords) {
        var mh$ = _wcslwr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_s", _String, _SizeInWords);
            }
            return (int)mh$.invokeExact(_String, _SizeInWords);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcslwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcslwr$descriptor() {
        return _wcslwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcslwr$handle() {
        return _wcslwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcslwr$address() {
        return _wcslwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcslwr(MemorySegment _String) {
        var mh$ = _wcslwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcslwr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcslwr_s_l$descriptor() {
        return _wcslwr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcslwr_s_l$handle() {
        return _wcslwr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_s_l$address() {
        return _wcslwr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcslwr_s_l(wchar_t *_String, size_t _SizeInWords, _locale_t _Locale)
     * }
     */
    public static int _wcslwr_s_l(MemorySegment _String, long _SizeInWords, MemorySegment _Locale) {
        var mh$ = _wcslwr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_s_l", _String, _SizeInWords, _Locale);
            }
            return (int)mh$.invokeExact(_String, _SizeInWords, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcslwr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcslwr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcslwr_l$descriptor() {
        return _wcslwr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcslwr_l$handle() {
        return _wcslwr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_l$address() {
        return _wcslwr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcslwr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcslwr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wcslwr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcslwr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsupr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _wcsupr_s$descriptor() {
        return _wcsupr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static MethodHandle _wcsupr_s$handle() {
        return _wcsupr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static MemorySegment _wcsupr_s$address() {
        return _wcsupr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsupr_s(wchar_t *_String, size_t _Size)
     * }
     */
    public static int _wcsupr_s(MemorySegment _String, long _Size) {
        var mh$ = _wcsupr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wcsupr$descriptor() {
        return _wcsupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MethodHandle _wcsupr$handle() {
        return _wcsupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsupr$address() {
        return _wcsupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment _wcsupr(MemorySegment _String) {
        var mh$ = _wcsupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsupr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsupr_s_l$descriptor() {
        return _wcsupr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsupr_s_l$handle() {
        return _wcsupr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_s_l$address() {
        return _wcsupr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcsupr_s_l(wchar_t *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _wcsupr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _wcsupr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsupr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsupr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsupr_l$descriptor() {
        return _wcsupr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsupr_l$handle() {
        return _wcsupr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_l$address() {
        return _wcsupr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wcsupr_l(wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsupr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wcsupr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsupr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsxfrm$descriptor() {
        return wcsxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsxfrm$handle() {
        return wcsxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsxfrm$address() {
        return wcsxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcsxfrm(MemorySegment _Destination, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcsxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsxfrm", _Destination, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsxfrm_l$descriptor() {
        return _wcsxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsxfrm_l$handle() {
        return _wcsxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsxfrm_l$address() {
        return _wcsxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _wcsxfrm_l(wchar_t *_Destination, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _wcsxfrm_l(MemorySegment _Destination, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsxfrm_l", _Destination, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcscoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcscoll$descriptor() {
        return wcscoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcscoll$handle() {
        return wcscoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcscoll$address() {
        return wcscoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcscoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcscoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcscoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcscoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcscoll_l$descriptor() {
        return _wcscoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcscoll_l$handle() {
        return _wcscoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcscoll_l$address() {
        return _wcscoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcscoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcscoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcscoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcscoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor _wcsicoll$descriptor() {
        return _wcsicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle _wcsicoll$handle() {
        return _wcsicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment _wcsicoll$address() {
        return _wcsicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int _wcsicoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _wcsicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsicoll_l$descriptor() {
        return _wcsicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsicoll_l$handle() {
        return _wcsicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsicoll_l$address() {
        return _wcsicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsicoll_l(const wchar_t *_String1, const wchar_t *_String2, _locale_t _Locale)
     * }
     */
    public static int _wcsicoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _wcsicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsicoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsncoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsncoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsncoll$descriptor() {
        return _wcsncoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsncoll$handle() {
        return _wcsncoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsncoll$address() {
        return _wcsncoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsncoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsncoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsncoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsncoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsncoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsncoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsncoll_l$descriptor() {
        return _wcsncoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsncoll_l$handle() {
        return _wcsncoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsncoll_l$address() {
        return _wcsncoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsncoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsncoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsncoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsncoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsnicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _wcsnicoll$descriptor() {
        return _wcsnicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _wcsnicoll$handle() {
        return _wcsnicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _wcsnicoll$address() {
        return _wcsnicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicoll(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int _wcsnicoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _wcsnicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcsnicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcsnicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcsnicoll_l$descriptor() {
        return _wcsnicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcsnicoll_l$handle() {
        return _wcsnicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcsnicoll_l$address() {
        return _wcsnicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wcsnicoll_l(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _wcsnicoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcsnicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcsnicoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsdup$descriptor() {
        return wcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MethodHandle wcsdup$handle() {
        return wcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcsdup$address() {
        return wcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *_String)
     * }
     */
    public static MemorySegment wcsdup(MemorySegment _String) {
        var mh$ = wcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcsicmp$descriptor() {
        return wcsicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcsicmp$handle() {
        return wcsicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcsicmp$address() {
        return wcsicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsicmp(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcsicmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcsicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsicmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnicmp$descriptor() {
        return wcsnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnicmp$handle() {
        return wcsnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnicmp$address() {
        return wcsnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsnicmp(const wchar_t *_String1, const wchar_t *_String2, size_t _MaxCount)
     * }
     */
    public static int wcsnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = wcsnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcsnset$descriptor() {
        return wcsnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcsnset$handle() {
        return wcsnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnset$address() {
        return wcsnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsnset(wchar_t *_String, wchar_t _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcsnset(MemorySegment _String, short _Value, long _MaxCount) {
        var mh$ = wcsnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsrev$descriptor() {
        return wcsrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MethodHandle wcsrev$handle() {
        return wcsrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsrev$address() {
        return wcsrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsrev(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsrev(MemorySegment _String) {
        var mh$ = wcsrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static FunctionDescriptor wcsset$descriptor() {
        return wcsset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MethodHandle wcsset$handle() {
        return wcsset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment wcsset$address() {
        return wcsset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsset(wchar_t *_String, wchar_t _Value)
     * }
     */
    public static MemorySegment wcsset(MemorySegment _String, short _Value) {
        var mh$ = wcsset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcslwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcslwr$descriptor() {
        return wcslwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MethodHandle wcslwr$handle() {
        return wcslwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcslwr$address() {
        return wcslwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcslwr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcslwr(MemorySegment _String) {
        var mh$ = wcslwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static FunctionDescriptor wcsupr$descriptor() {
        return wcsupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MethodHandle wcsupr$handle() {
        return wcsupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsupr$address() {
        return wcsupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsupr(wchar_t *_String)
     * }
     */
    public static MemorySegment wcsupr(MemorySegment _String) {
        var mh$ = wcsupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcsicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static FunctionDescriptor wcsicoll$descriptor() {
        return wcsicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MethodHandle wcsicoll$handle() {
        return wcsicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static MemorySegment wcsicoll$address() {
        return wcsicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsicoll(const wchar_t *_String1, const wchar_t *_String2)
     * }
     */
    public static int wcsicoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = wcsicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsicoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcpy_s$descriptor() {
        return strcpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MethodHandle strcpy_s$handle() {
        return strcpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MemorySegment strcpy_s$address() {
        return strcpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strcpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static int strcpy_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source) {
        var mh$ = strcpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy_s", _Destination, _SizeInBytes, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcat_s$descriptor() {
        return strcat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MethodHandle strcat_s$handle() {
        return strcat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static MemorySegment strcat_s$address() {
        return strcat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strcat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source)
     * }
     */
    public static int strcat_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source) {
        var mh$ = strcat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat_s", _Destination, _SizeInBytes, _Source);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strerror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static FunctionDescriptor strerror_s$descriptor() {
        return strerror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static MethodHandle strerror_s$handle() {
        return strerror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static MemorySegment strerror_s$address() {
        return strerror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strerror_s(char *_Buffer, size_t _SizeInBytes, int _ErrorNumber)
     * }
     */
    public static int strerror_s(MemorySegment _Buffer, long _SizeInBytes, int _ErrorNumber) {
        var mh$ = strerror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_s", _Buffer, _SizeInBytes, _ErrorNumber);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _ErrorNumber);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncat_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strncat_s$descriptor() {
        return strncat_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle strncat_s$handle() {
        return strncat_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment strncat_s$address() {
        return strncat_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strncat_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static int strncat_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source, long _MaxCount) {
        var mh$ = strncat_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat_s", _Destination, _SizeInBytes, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncpy_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strncpy_s$descriptor() {
        return strncpy_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MethodHandle strncpy_s$handle() {
        return strncpy_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static MemorySegment strncpy_s$address() {
        return strncpy_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t strncpy_s(char *_Destination, rsize_t _SizeInBytes, const char *_Source, rsize_t _MaxCount)
     * }
     */
    public static int strncpy_s(MemorySegment _Destination, long _SizeInBytes, MemorySegment _Source, long _MaxCount) {
        var mh$ = strncpy_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy_s", _Destination, _SizeInBytes, _Source, _MaxCount);
            }
            return (int)mh$.invokeExact(_Destination, _SizeInBytes, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtok_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static FunctionDescriptor strtok_s$descriptor() {
        return strtok_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static MethodHandle strtok_s$handle() {
        return strtok_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static MemorySegment strtok_s$address() {
        return strtok_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok_s(char *_String, const char *_Delimiter, char **_Context)
     * }
     */
    public static MemorySegment strtok_s(MemorySegment _String, MemorySegment _Delimiter, MemorySegment _Context) {
        var mh$ = strtok_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_s", _String, _Delimiter, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter, _Context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _memccpy$descriptor() {
        return _memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static MethodHandle _memccpy$handle() {
        return _memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment _memccpy$address() {
        return _memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_memccpy(void *_Dst, const void *_Src, int _Val, size_t _MaxCount)
     * }
     */
    public static MemorySegment _memccpy(MemorySegment _Dst, MemorySegment _Src, int _Val, long _MaxCount) {
        var mh$ = _memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_memccpy", _Dst, _Src, _Val, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_Dst, _Src, _Val, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcat(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcat(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmp(const char *_Str1, const char *_Str2)
     * }
     */
    public static int strcmp(MemorySegment _Str1, MemorySegment _Str2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", _Str1, _Str2);
            }
            return (int)mh$.invokeExact(_Str1, _Str2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strcmpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strcmpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor _strcmpi$descriptor() {
        return _strcmpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle _strcmpi$handle() {
        return _strcmpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment _strcmpi$address() {
        return _strcmpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static int _strcmpi(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _strcmpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strcmpi", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcoll(const char *_String1, const char *_String2)
     * }
     */
    public static int strcoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strcoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strcoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strcoll_l$descriptor() {
        return _strcoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strcoll_l$handle() {
        return _strcoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strcoll_l$address() {
        return _strcoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strcoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static int _strcoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _strcoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strcoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcpy(char *_Destination, const char *_Source)
     * }
     */
    public static MemorySegment strcpy(MemorySegment _Destination, MemorySegment _Source) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", _Destination, _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strcspn(const char *_Str, const char *_Control)
     * }
     */
    public static long strcspn(MemorySegment _Str, MemorySegment _Control) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", _Str, _Control);
            }
            return (long)mh$.invokeExact(_Str, _Control);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static FunctionDescriptor _strdup$descriptor() {
        return _strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static MethodHandle _strdup$handle() {
        return _strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static MemorySegment _strdup$address() {
        return _strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strdup(const char *_Source)
     * }
     */
    public static MemorySegment _strdup(MemorySegment _Source) {
        var mh$ = _strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strdup", _Source);
            }
            return (MemorySegment)mh$.invokeExact(_Source);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _strerror$descriptor() {
        return _strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static MethodHandle _strerror$handle() {
        return _strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static MemorySegment _strerror$address() {
        return _strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strerror(const char *_ErrorMessage)
     * }
     */
    public static MemorySegment _strerror(MemorySegment _ErrorMessage) {
        var mh$ = _strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strerror", _ErrorMessage);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorMessage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strerror_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strerror_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _strerror_s$descriptor() {
        return _strerror_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static MethodHandle _strerror_s$handle() {
        return _strerror_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static MemorySegment _strerror_s$address() {
        return _strerror_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strerror_s(char *_Buffer, size_t _SizeInBytes, const char *_ErrorMessage)
     * }
     */
    public static int _strerror_s(MemorySegment _Buffer, long _SizeInBytes, MemorySegment _ErrorMessage) {
        var mh$ = _strerror_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strerror_s", _Buffer, _SizeInBytes, _ErrorMessage);
            }
            return (int)mh$.invokeExact(_Buffer, _SizeInBytes, _ErrorMessage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strerror(int _ErrorMessage)
     * }
     */
    public static MemorySegment strerror(int _ErrorMessage) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", _ErrorMessage);
            }
            return (MemorySegment)mh$.invokeExact(_ErrorMessage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_stricmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor _stricmp$descriptor() {
        return _stricmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle _stricmp$handle() {
        return _stricmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment _stricmp$address() {
        return _stricmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static int _stricmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _stricmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_stricoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor _stricoll$descriptor() {
        return _stricoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle _stricoll$handle() {
        return _stricoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment _stricoll$address() {
        return _stricoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricoll(const char *_String1, const char *_String2)
     * }
     */
    public static int _stricoll(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = _stricoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricoll", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_stricoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _stricoll_l$descriptor() {
        return _stricoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _stricoll_l$handle() {
        return _stricoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _stricoll_l$address() {
        return _stricoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricoll_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static int _stricoll_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _stricoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricoll_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _stricmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_stricmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _stricmp_l$descriptor() {
        return _stricmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MethodHandle _stricmp_l$handle() {
        return _stricmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static MemorySegment _stricmp_l$address() {
        return _stricmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _stricmp_l(const char *_String1, const char *_String2, _locale_t _Locale)
     * }
     */
    public static int _stricmp_l(MemorySegment _String1, MemorySegment _String2, MemorySegment _Locale) {
        var mh$ = _stricmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_stricmp_l", _String1, _String2, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strlen(const char *_Str)
     * }
     */
    public static long strlen(MemorySegment _Str) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", _Str);
            }
            return (long)mh$.invokeExact(_Str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strlwr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _strlwr_s$descriptor() {
        return _strlwr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static MethodHandle _strlwr_s$handle() {
        return _strlwr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static MemorySegment _strlwr_s$address() {
        return _strlwr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strlwr_s(char *_String, size_t _Size)
     * }
     */
    public static int _strlwr_s(MemorySegment _String, long _Size) {
        var mh$ = _strlwr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strlwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static FunctionDescriptor _strlwr$descriptor() {
        return _strlwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static MethodHandle _strlwr$handle() {
        return _strlwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static MemorySegment _strlwr$address() {
        return _strlwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strlwr(char *_String)
     * }
     */
    public static MemorySegment _strlwr(MemorySegment _String) {
        var mh$ = _strlwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strlwr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strlwr_s_l$descriptor() {
        return _strlwr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strlwr_s_l$handle() {
        return _strlwr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strlwr_s_l$address() {
        return _strlwr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strlwr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _strlwr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _strlwr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strlwr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strlwr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strlwr_l$descriptor() {
        return _strlwr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strlwr_l$handle() {
        return _strlwr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strlwr_l$address() {
        return _strlwr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strlwr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strlwr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _strlwr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strlwr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncat(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncat(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncmp(const char *_Str1, const char *_Str2, size_t _MaxCount)
     * }
     */
    public static int strncmp(MemorySegment _Str1, MemorySegment _Str2, long _MaxCount) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", _Str1, _Str2, _MaxCount);
            }
            return (int)mh$.invokeExact(_Str1, _Str2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strnicmp$descriptor() {
        return _strnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strnicmp$handle() {
        return _strnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strnicmp$address() {
        return _strnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int _strnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _strnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strnicmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strnicmp_l$descriptor() {
        return _strnicmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strnicmp_l$handle() {
        return _strnicmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strnicmp_l$address() {
        return _strnicmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicmp_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _strnicmp_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strnicmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicmp_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strnicoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strnicoll$descriptor() {
        return _strnicoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strnicoll$handle() {
        return _strnicoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strnicoll$address() {
        return _strnicoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int _strnicoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _strnicoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnicoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strnicoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strnicoll_l$descriptor() {
        return _strnicoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strnicoll_l$handle() {
        return _strnicoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strnicoll_l$address() {
        return _strnicoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strnicoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _strnicoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strnicoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnicoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strncoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strncoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strncoll$descriptor() {
        return _strncoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strncoll$handle() {
        return _strncoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strncoll$address() {
        return _strncoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strncoll(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int _strncoll(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = _strncoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strncoll", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strncoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strncoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strncoll_l$descriptor() {
        return _strncoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strncoll_l$handle() {
        return _strncoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strncoll_l$address() {
        return _strncoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _strncoll_l(const char *_String1, const char *_String2, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _strncoll_l(MemorySegment _String1, MemorySegment _String2, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strncoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strncoll_l", _String1, _String2, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __strncnt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__strncnt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static FunctionDescriptor __strncnt$descriptor() {
        return __strncnt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static MethodHandle __strncnt$handle() {
        return __strncnt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static MemorySegment __strncnt$address() {
        return __strncnt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t __strncnt(const char *_String, size_t _Count)
     * }
     */
    public static long __strncnt(MemorySegment _String, long _Count) {
        var mh$ = __strncnt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__strncnt", _String, _Count);
            }
            return (long)mh$.invokeExact(_String, _Count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncpy(char *_Destination, const char *_Source, size_t _Count)
     * }
     */
    public static MemorySegment strncpy(MemorySegment _Destination, MemorySegment _Source, long _Count) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", _Destination, _Source, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Source, _Count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static long strnlen(MemorySegment _String, long _MaxCount) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", _String, _MaxCount);
            }
            return (long)mh$.invokeExact(_String, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strnset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _strnset_s$descriptor() {
        return _strnset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle _strnset_s$handle() {
        return _strnset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment _strnset_s$address() {
        return _strnset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strnset_s(char *_String, size_t _SizeInBytes, int _Value, size_t _MaxCount)
     * }
     */
    public static int _strnset_s(MemorySegment _String, long _SizeInBytes, int _Value, long _MaxCount) {
        var mh$ = _strnset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnset_s", _String, _SizeInBytes, _Value, _MaxCount);
            }
            return (int)mh$.invokeExact(_String, _SizeInBytes, _Value, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static FunctionDescriptor _strnset$descriptor() {
        return _strnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static MethodHandle _strnset$handle() {
        return _strnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static MemorySegment _strnset$address() {
        return _strnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strnset(char *_Destination, int _Value, size_t _Count)
     * }
     */
    public static MemorySegment _strnset(MemorySegment _Destination, int _Value, long _Count) {
        var mh$ = _strnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strnset", _Destination, _Value, _Count);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Value, _Count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strpbrk(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment _Str, MemorySegment _Control) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", _Str, _Control);
            }
            return (MemorySegment)mh$.invokeExact(_Str, _Control);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static FunctionDescriptor _strrev$descriptor() {
        return _strrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static MethodHandle _strrev$handle() {
        return _strrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static MemorySegment _strrev$address() {
        return _strrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strrev(char *_Str)
     * }
     */
    public static MemorySegment _strrev(MemorySegment _Str) {
        var mh$ = _strrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strrev", _Str);
            }
            return (MemorySegment)mh$.invokeExact(_Str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static FunctionDescriptor _strset_s$descriptor() {
        return _strset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static MethodHandle _strset_s$handle() {
        return _strset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static MemorySegment _strset_s$address() {
        return _strset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strset_s(char *_Destination, size_t _DestinationSize, int _Value)
     * }
     */
    public static int _strset_s(MemorySegment _Destination, long _DestinationSize, int _Value) {
        var mh$ = _strset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strset_s", _Destination, _DestinationSize, _Value);
            }
            return (int)mh$.invokeExact(_Destination, _DestinationSize, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static FunctionDescriptor _strset$descriptor() {
        return _strset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static MethodHandle _strset$handle() {
        return _strset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static MemorySegment _strset$address() {
        return _strset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strset(char *_Destination, int _Value)
     * }
     */
    public static MemorySegment _strset(MemorySegment _Destination, int _Value) {
        var mh$ = _strset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strset", _Destination, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_Destination, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strspn(const char *_Str, const char *_Control)
     * }
     */
    public static long strspn(MemorySegment _Str, MemorySegment _Control) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", _Str, _Control);
            }
            return (long)mh$.invokeExact(_Str, _Control);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok(char *_String, const char *_Delimiter)
     * }
     */
    public static MemorySegment strtok(MemorySegment _String, MemorySegment _Delimiter) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", _String, _Delimiter);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Delimiter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strupr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static FunctionDescriptor _strupr_s$descriptor() {
        return _strupr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static MethodHandle _strupr_s$handle() {
        return _strupr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static MemorySegment _strupr_s$address() {
        return _strupr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strupr_s(char *_String, size_t _Size)
     * }
     */
    public static int _strupr_s(MemorySegment _String, long _Size) {
        var mh$ = _strupr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr_s", _String, _Size);
            }
            return (int)mh$.invokeExact(_String, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static FunctionDescriptor _strupr$descriptor() {
        return _strupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static MethodHandle _strupr$handle() {
        return _strupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static MemorySegment _strupr$address() {
        return _strupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strupr(char *_String)
     * }
     */
    public static MemorySegment _strupr(MemorySegment _String) {
        var mh$ = _strupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strupr_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strupr_s_l$descriptor() {
        return _strupr_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strupr_s_l$handle() {
        return _strupr_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strupr_s_l$address() {
        return _strupr_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _strupr_s_l(char *_String, size_t _Size, _locale_t _Locale)
     * }
     */
    public static int _strupr_s_l(MemorySegment _String, long _Size, MemorySegment _Locale) {
        var mh$ = _strupr_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr_s_l", _String, _Size, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Size, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strupr_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strupr_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strupr_l$descriptor() {
        return _strupr_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strupr_l$handle() {
        return _strupr_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strupr_l$address() {
        return _strupr_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_strupr_l(char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strupr_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _strupr_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strupr_l", _String, _Locale);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strxfrm(char *_Destination, const char *_Source, size_t _MaxCount)
     * }
     */
    public static long strxfrm(MemorySegment _Destination, MemorySegment _Source, long _MaxCount) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", _Destination, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strxfrm_l$descriptor() {
        return _strxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strxfrm_l$handle() {
        return _strxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strxfrm_l$address() {
        return _strxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _strxfrm_l(char *_Destination, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _strxfrm_l(MemorySegment _Destination, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _strxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strxfrm_l", _Destination, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Destination, _Source, _MaxCount, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strdup(const char *_String)
     * }
     */
    public static MemorySegment strdup(MemorySegment _String) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcmpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor strcmpi$descriptor() {
        return strcmpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle strcmpi$handle() {
        return strcmpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment strcmpi$address() {
        return strcmpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmpi(const char *_String1, const char *_String2)
     * }
     */
    public static int strcmpi(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = strcmpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmpi", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stricmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stricmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static FunctionDescriptor stricmp$descriptor() {
        return stricmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MethodHandle stricmp$handle() {
        return stricmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static MemorySegment stricmp$address() {
        return stricmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stricmp(const char *_String1, const char *_String2)
     * }
     */
    public static int stricmp(MemorySegment _String1, MemorySegment _String2) {
        var mh$ = stricmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stricmp", _String1, _String2);
            }
            return (int)mh$.invokeExact(_String1, _String2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlwr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlwr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static FunctionDescriptor strlwr$descriptor() {
        return strlwr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static MethodHandle strlwr$handle() {
        return strlwr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static MemorySegment strlwr$address() {
        return strlwr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strlwr(char *_String)
     * }
     */
    public static MemorySegment strlwr(MemorySegment _String) {
        var mh$ = strlwr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlwr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnicmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strnicmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strnicmp$descriptor() {
        return strnicmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MethodHandle strnicmp$handle() {
        return strnicmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnicmp$address() {
        return strnicmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strnicmp(const char *_String1, const char *_String2, size_t _MaxCount)
     * }
     */
    public static int strnicmp(MemorySegment _String1, MemorySegment _String2, long _MaxCount) {
        var mh$ = strnicmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnicmp", _String1, _String2, _MaxCount);
            }
            return (int)mh$.invokeExact(_String1, _String2, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strnset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor strnset$descriptor() {
        return strnset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static MethodHandle strnset$handle() {
        return strnset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnset$address() {
        return strnset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strnset(char *_String, int _Value, size_t _MaxCount)
     * }
     */
    public static MemorySegment strnset(MemorySegment _String, int _Value, long _MaxCount) {
        var mh$ = strnset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnset", _String, _Value, _MaxCount);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value, _MaxCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strrev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static FunctionDescriptor strrev$descriptor() {
        return strrev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static MethodHandle strrev$handle() {
        return strrev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static MemorySegment strrev$address() {
        return strrev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrev(char *_String)
     * }
     */
    public static MemorySegment strrev(MemorySegment _String) {
        var mh$ = strrev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrev", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static FunctionDescriptor strset$descriptor() {
        return strset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static MethodHandle strset$handle() {
        return strset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static MemorySegment strset$address() {
        return strset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strset(char *_String, int _Value)
     * }
     */
    public static MemorySegment strset(MemorySegment _String, int _Value) {
        var mh$ = strset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strset", _String, _Value);
            }
            return (MemorySegment)mh$.invokeExact(_String, _Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strupr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strupr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static FunctionDescriptor strupr$descriptor() {
        return strupr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static MethodHandle strupr$handle() {
        return strupr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static MemorySegment strupr$address() {
        return strupr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strupr(char *_String)
     * }
     */
    public static MemorySegment strupr(MemorySegment _String) {
        var mh$ = strupr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strupr", _String);
            }
            return (MemorySegment)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static FunctionDescriptor av_strerror$descriptor() {
        return av_strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static MethodHandle av_strerror$handle() {
        return av_strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static MemorySegment av_strerror$address() {
        return av_strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static int av_strerror(int errnum, MemorySegment errbuf, long errbuf_size) {
        var mh$ = av_strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_strerror", errnum, errbuf, errbuf_size);
            }
            return (int)mh$.invokeExact(errnum, errbuf, errbuf_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static FunctionDescriptor av_malloc$descriptor() {
        return av_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static MethodHandle av_malloc$handle() {
        return av_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static MemorySegment av_malloc$address() {
        return av_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static MemorySegment av_malloc(long size) {
        var mh$ = av_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_malloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_mallocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_mallocz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static FunctionDescriptor av_mallocz$descriptor() {
        return av_mallocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static MethodHandle av_mallocz$handle() {
        return av_mallocz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static MemorySegment av_mallocz$address() {
        return av_mallocz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static MemorySegment av_mallocz(long size) {
        var mh$ = av_mallocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_mallocz", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_malloc_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_malloc_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_malloc_array$descriptor() {
        return av_malloc_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_malloc_array$handle() {
        return av_malloc_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_malloc_array$address() {
        return av_malloc_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_malloc_array(long nmemb, long size) {
        var mh$ = av_malloc_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_malloc_array", nmemb, size);
            }
            return (MemorySegment)mh$.invokeExact(nmemb, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_calloc$descriptor() {
        return av_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_calloc$handle() {
        return av_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_calloc$address() {
        return av_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_calloc(long nmemb, long size) {
        var mh$ = av_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_calloc", nmemb, size);
            }
            return (MemorySegment)mh$.invokeExact(nmemb, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static FunctionDescriptor av_realloc$descriptor() {
        return av_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static MethodHandle av_realloc$handle() {
        return av_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static MemorySegment av_realloc$address() {
        return av_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static MemorySegment av_realloc(MemorySegment ptr, long size) {
        var mh$ = av_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_realloc", ptr, size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_reallocp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_reallocp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static FunctionDescriptor av_reallocp$descriptor() {
        return av_reallocp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static MethodHandle av_reallocp$handle() {
        return av_reallocp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static MemorySegment av_reallocp$address() {
        return av_reallocp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static int av_reallocp(MemorySegment ptr, long size) {
        var mh$ = av_reallocp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_reallocp", ptr, size);
            }
            return (int)mh$.invokeExact(ptr, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_realloc_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_realloc_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor av_realloc_f$descriptor() {
        return av_realloc_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle av_realloc_f$handle() {
        return av_realloc_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment av_realloc_f$address() {
        return av_realloc_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment av_realloc_f(MemorySegment ptr, long nelem, long elsize) {
        var mh$ = av_realloc_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_realloc_f", ptr, nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(ptr, nelem, elsize);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_realloc_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_realloc_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_realloc_array$descriptor() {
        return av_realloc_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_realloc_array$handle() {
        return av_realloc_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_realloc_array$address() {
        return av_realloc_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_realloc_array(MemorySegment ptr, long nmemb, long size) {
        var mh$ = av_realloc_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_realloc_array", ptr, nmemb, size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, nmemb, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_reallocp_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_reallocp_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_reallocp_array$descriptor() {
        return av_reallocp_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_reallocp_array$handle() {
        return av_reallocp_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_reallocp_array$address() {
        return av_reallocp_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static int av_reallocp_array(MemorySegment ptr, long nmemb, long size) {
        var mh$ = av_reallocp_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_reallocp_array", ptr, nmemb, size);
            }
            return (int)mh$.invokeExact(ptr, nmemb, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_fast_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_realloc$descriptor() {
        return av_fast_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_realloc$handle() {
        return av_fast_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_realloc$address() {
        return av_fast_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_realloc(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_realloc", ptr, size, min_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size, min_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_fast_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_malloc$descriptor() {
        return av_fast_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_malloc$handle() {
        return av_fast_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_malloc$address() {
        return av_fast_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_malloc(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_malloc", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_mallocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_fast_mallocz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_mallocz$descriptor() {
        return av_fast_mallocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_mallocz$handle() {
        return av_fast_mallocz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_mallocz$address() {
        return av_fast_mallocz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_mallocz(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_mallocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_mallocz", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static FunctionDescriptor av_free$descriptor() {
        return av_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static MethodHandle av_free$handle() {
        return av_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static MemorySegment av_free$address() {
        return av_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static void av_free(MemorySegment ptr) {
        var mh$ = av_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_free", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_freep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_freep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static FunctionDescriptor av_freep$descriptor() {
        return av_freep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static MethodHandle av_freep$handle() {
        return av_freep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static MemorySegment av_freep$address() {
        return av_freep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static void av_freep(MemorySegment ptr) {
        var mh$ = av_freep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_freep", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static FunctionDescriptor av_strdup$descriptor() {
        return av_strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static MethodHandle av_strdup$handle() {
        return av_strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static MemorySegment av_strdup$address() {
        return av_strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static MemorySegment av_strdup(MemorySegment s) {
        var mh$ = av_strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_strdup", s);
            }
            return (MemorySegment)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static FunctionDescriptor av_strndup$descriptor() {
        return av_strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static MethodHandle av_strndup$handle() {
        return av_strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static MemorySegment av_strndup$address() {
        return av_strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static MemorySegment av_strndup(MemorySegment s, long len) {
        var mh$ = av_strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_strndup", s, len);
            }
            return (MemorySegment)mh$.invokeExact(s, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_memdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_memdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static FunctionDescriptor av_memdup$descriptor() {
        return av_memdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static MethodHandle av_memdup$handle() {
        return av_memdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static MemorySegment av_memdup$address() {
        return av_memdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static MemorySegment av_memdup(MemorySegment p, long size) {
        var mh$ = av_memdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_memdup", p, size);
            }
            return (MemorySegment)mh$.invokeExact(p, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_memcpy_backptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_memcpy_backptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static FunctionDescriptor av_memcpy_backptr$descriptor() {
        return av_memcpy_backptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static MethodHandle av_memcpy_backptr$handle() {
        return av_memcpy_backptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static MemorySegment av_memcpy_backptr$address() {
        return av_memcpy_backptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static void av_memcpy_backptr(MemorySegment dst, int back, int cnt) {
        var mh$ = av_memcpy_backptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_memcpy_backptr", dst, back, cnt);
            }
            mh$.invokeExact(dst, back, cnt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dynarray_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dynarray_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static FunctionDescriptor av_dynarray_add$descriptor() {
        return av_dynarray_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MethodHandle av_dynarray_add$handle() {
        return av_dynarray_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MemorySegment av_dynarray_add$address() {
        return av_dynarray_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static void av_dynarray_add(MemorySegment tab_ptr, MemorySegment nb_ptr, MemorySegment elem) {
        var mh$ = av_dynarray_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dynarray_add", tab_ptr, nb_ptr, elem);
            }
            mh$.invokeExact(tab_ptr, nb_ptr, elem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dynarray_add_nofree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dynarray_add_nofree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static FunctionDescriptor av_dynarray_add_nofree$descriptor() {
        return av_dynarray_add_nofree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MethodHandle av_dynarray_add_nofree$handle() {
        return av_dynarray_add_nofree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MemorySegment av_dynarray_add_nofree$address() {
        return av_dynarray_add_nofree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static int av_dynarray_add_nofree(MemorySegment tab_ptr, MemorySegment nb_ptr, MemorySegment elem) {
        var mh$ = av_dynarray_add_nofree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dynarray_add_nofree", tab_ptr, nb_ptr, elem);
            }
            return (int)mh$.invokeExact(tab_ptr, nb_ptr, elem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dynarray2_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dynarray2_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static FunctionDescriptor av_dynarray2_add$descriptor() {
        return av_dynarray2_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static MethodHandle av_dynarray2_add$handle() {
        return av_dynarray2_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static MemorySegment av_dynarray2_add$address() {
        return av_dynarray2_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static MemorySegment av_dynarray2_add(MemorySegment tab_ptr, MemorySegment nb_ptr, long elem_size, MemorySegment elem_data) {
        var mh$ = av_dynarray2_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dynarray2_add", tab_ptr, nb_ptr, elem_size, elem_data);
            }
            return (MemorySegment)mh$.invokeExact(tab_ptr, nb_ptr, elem_size, elem_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_size_mult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_size_mult");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static FunctionDescriptor av_size_mult$descriptor() {
        return av_size_mult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static MethodHandle av_size_mult$handle() {
        return av_size_mult.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static MemorySegment av_size_mult$address() {
        return av_size_mult.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static int av_size_mult(long a, long b, MemorySegment r) {
        var mh$ = av_size_mult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_size_mult", a, b, r);
            }
            return (int)mh$.invokeExact(a, b, r);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_max_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_max_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static FunctionDescriptor av_max_alloc$descriptor() {
        return av_max_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static MethodHandle av_max_alloc$handle() {
        return av_max_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static MemorySegment av_max_alloc$address() {
        return av_max_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static void av_max_alloc(long max) {
        var mh$ = av_max_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_max_alloc", max);
            }
            mh$.invokeExact(max);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log2(unsigned int v)
     * }
     */
    public static FunctionDescriptor av_log2$descriptor() {
        return av_log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log2(unsigned int v)
     * }
     */
    public static MethodHandle av_log2$handle() {
        return av_log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_log2(unsigned int v)
     * }
     */
    public static MemorySegment av_log2$address() {
        return av_log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_log2(unsigned int v)
     * }
     */
    public static int av_log2(int v) {
        var mh$ = av_log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log2", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log2_16bit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log2_16bit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log2_16bit(unsigned int v)
     * }
     */
    public static FunctionDescriptor av_log2_16bit$descriptor() {
        return av_log2_16bit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log2_16bit(unsigned int v)
     * }
     */
    public static MethodHandle av_log2_16bit$handle() {
        return av_log2_16bit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_log2_16bit(unsigned int v)
     * }
     */
    public static MemorySegment av_log2_16bit$address() {
        return av_log2_16bit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_log2_16bit(unsigned int v)
     * }
     */
    public static int av_log2_16bit(int v) {
        var mh$ = av_log2_16bit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log2_16bit", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_reduce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_reduce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)
     * }
     */
    public static FunctionDescriptor av_reduce$descriptor() {
        return av_reduce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)
     * }
     */
    public static MethodHandle av_reduce$handle() {
        return av_reduce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)
     * }
     */
    public static MemorySegment av_reduce$address() {
        return av_reduce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)
     * }
     */
    public static int av_reduce(MemorySegment dst_num, MemorySegment dst_den, long num, long den, long max) {
        var mh$ = av_reduce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_reduce", dst_num, dst_den, num, den, max);
            }
            return (int)mh$.invokeExact(dst_num, dst_den, num, den, max);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_mul_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_mul_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_mul_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_mul_q$descriptor() {
        return av_mul_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_mul_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_mul_q$handle() {
        return av_mul_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_mul_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_mul_q$address() {
        return av_mul_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_mul_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_mul_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_mul_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_mul_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_div_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_div_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_div_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_div_q$descriptor() {
        return av_div_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_div_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_div_q$handle() {
        return av_div_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_div_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_div_q$address() {
        return av_div_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_div_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_div_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_div_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_div_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_add_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_add_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_add_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_add_q$descriptor() {
        return av_add_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_add_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_add_q$handle() {
        return av_add_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_add_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_add_q$address() {
        return av_add_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_add_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_add_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_add_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_add_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_sub_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_sub_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_sub_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_sub_q$descriptor() {
        return av_sub_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_sub_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_sub_q$handle() {
        return av_sub_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_sub_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_sub_q$address() {
        return av_sub_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_sub_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_sub_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_sub_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_sub_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_d2q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_d2q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_d2q(double d, int max)
     * }
     */
    public static FunctionDescriptor av_d2q$descriptor() {
        return av_d2q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_d2q(double d, int max)
     * }
     */
    public static MethodHandle av_d2q$handle() {
        return av_d2q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_d2q(double d, int max)
     * }
     */
    public static MemorySegment av_d2q$address() {
        return av_d2q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_d2q(double d, int max)
     * }
     */
    public static MemorySegment av_d2q(SegmentAllocator allocator, double d, int max) {
        var mh$ = av_d2q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_d2q", allocator, d, max);
            }
            return (MemorySegment)mh$.invokeExact(allocator, d, max);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_nearer_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_nearer_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
     * }
     */
    public static FunctionDescriptor av_nearer_q$descriptor() {
        return av_nearer_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
     * }
     */
    public static MethodHandle av_nearer_q$handle() {
        return av_nearer_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
     * }
     */
    public static MemorySegment av_nearer_q$address() {
        return av_nearer_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
     * }
     */
    public static int av_nearer_q(MemorySegment q, MemorySegment q1, MemorySegment q2) {
        var mh$ = av_nearer_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_nearer_q", q, q1, q2);
            }
            return (int)mh$.invokeExact(q, q1, q2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_nearest_q_idx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            AVRational.layout(),
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_find_nearest_q_idx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_find_nearest_q_idx(AVRational q, const AVRational *q_list)
     * }
     */
    public static FunctionDescriptor av_find_nearest_q_idx$descriptor() {
        return av_find_nearest_q_idx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_find_nearest_q_idx(AVRational q, const AVRational *q_list)
     * }
     */
    public static MethodHandle av_find_nearest_q_idx$handle() {
        return av_find_nearest_q_idx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_find_nearest_q_idx(AVRational q, const AVRational *q_list)
     * }
     */
    public static MemorySegment av_find_nearest_q_idx$address() {
        return av_find_nearest_q_idx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_find_nearest_q_idx(AVRational q, const AVRational *q_list)
     * }
     */
    public static int av_find_nearest_q_idx(MemorySegment q, MemorySegment q_list) {
        var mh$ = av_find_nearest_q_idx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_nearest_q_idx", q, q_list);
            }
            return (int)mh$.invokeExact(q, q_list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_q2intfloat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_q2intfloat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t av_q2intfloat(AVRational q)
     * }
     */
    public static FunctionDescriptor av_q2intfloat$descriptor() {
        return av_q2intfloat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t av_q2intfloat(AVRational q)
     * }
     */
    public static MethodHandle av_q2intfloat$handle() {
        return av_q2intfloat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t av_q2intfloat(AVRational q)
     * }
     */
    public static MemorySegment av_q2intfloat$address() {
        return av_q2intfloat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t av_q2intfloat(AVRational q)
     * }
     */
    public static int av_q2intfloat(MemorySegment q) {
        var mh$ = av_q2intfloat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_q2intfloat", q);
            }
            return (int)mh$.invokeExact(q);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_gcd_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout(),
            ffmpeg_includes_h.C_INT,
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_gcd_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def)
     * }
     */
    public static FunctionDescriptor av_gcd_q$descriptor() {
        return av_gcd_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def)
     * }
     */
    public static MethodHandle av_gcd_q$handle() {
        return av_gcd_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def)
     * }
     */
    public static MemorySegment av_gcd_q$address() {
        return av_gcd_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def)
     * }
     */
    public static MemorySegment av_gcd_q(SegmentAllocator allocator, MemorySegment a, MemorySegment b, int max_den, MemorySegment def) {
        var mh$ = av_gcd_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_gcd_q", allocator, a, b, max_den, def);
            }
            return (MemorySegment)mh$.invokeExact(allocator, a, b, max_den, def);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_ROUND_ZERO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_ZERO = 0
     * }
     */
    public static int AV_ROUND_ZERO() {
        return AV_ROUND_ZERO;
    }
    private static final int AV_ROUND_INF = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_INF = 1
     * }
     */
    public static int AV_ROUND_INF() {
        return AV_ROUND_INF;
    }
    private static final int AV_ROUND_DOWN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_DOWN = 2
     * }
     */
    public static int AV_ROUND_DOWN() {
        return AV_ROUND_DOWN;
    }
    private static final int AV_ROUND_UP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_UP = 3
     * }
     */
    public static int AV_ROUND_UP() {
        return AV_ROUND_UP;
    }
    private static final int AV_ROUND_NEAR_INF = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_NEAR_INF = 5
     * }
     */
    public static int AV_ROUND_NEAR_INF() {
        return AV_ROUND_NEAR_INF;
    }
    private static final int AV_ROUND_PASS_MINMAX = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_PASS_MINMAX = 8192
     * }
     */
    public static int AV_ROUND_PASS_MINMAX() {
        return AV_ROUND_PASS_MINMAX;
    }

    private static class av_gcd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_gcd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_gcd(int64_t a, int64_t b)
     * }
     */
    public static FunctionDescriptor av_gcd$descriptor() {
        return av_gcd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_gcd(int64_t a, int64_t b)
     * }
     */
    public static MethodHandle av_gcd$handle() {
        return av_gcd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_gcd(int64_t a, int64_t b)
     * }
     */
    public static MemorySegment av_gcd$address() {
        return av_gcd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_gcd(int64_t a, int64_t b)
     * }
     */
    public static long av_gcd(long a, long b) {
        var mh$ = av_gcd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_gcd", a, b);
            }
            return (long)mh$.invokeExact(a, b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_rescale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale(int64_t a, int64_t b, int64_t c)
     * }
     */
    public static FunctionDescriptor av_rescale$descriptor() {
        return av_rescale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale(int64_t a, int64_t b, int64_t c)
     * }
     */
    public static MethodHandle av_rescale$handle() {
        return av_rescale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_rescale(int64_t a, int64_t b, int64_t c)
     * }
     */
    public static MemorySegment av_rescale$address() {
        return av_rescale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_rescale(int64_t a, int64_t b, int64_t c)
     * }
     */
    public static long av_rescale(long a, long b, long c) {
        var mh$ = av_rescale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale", a, b, c);
            }
            return (long)mh$.invokeExact(a, b, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_rnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_rescale_rnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
     * }
     */
    public static FunctionDescriptor av_rescale_rnd$descriptor() {
        return av_rescale_rnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
     * }
     */
    public static MethodHandle av_rescale_rnd$handle() {
        return av_rescale_rnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
     * }
     */
    public static MemorySegment av_rescale_rnd$address() {
        return av_rescale_rnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
     * }
     */
    public static long av_rescale_rnd(long a, long b, long c, int rnd) {
        var mh$ = av_rescale_rnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_rnd", a, b, c, rnd);
            }
            return (long)mh$.invokeExact(a, b, c, rnd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_rescale_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)
     * }
     */
    public static FunctionDescriptor av_rescale_q$descriptor() {
        return av_rescale_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)
     * }
     */
    public static MethodHandle av_rescale_q$handle() {
        return av_rescale_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)
     * }
     */
    public static MemorySegment av_rescale_q$address() {
        return av_rescale_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)
     * }
     */
    public static long av_rescale_q(long a, MemorySegment bq, MemorySegment cq) {
        var mh$ = av_rescale_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_q", a, bq, cq);
            }
            return (long)mh$.invokeExact(a, bq, cq);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_q_rnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            AVRational.layout(),
            AVRational.layout(),
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_rescale_q_rnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd)
     * }
     */
    public static FunctionDescriptor av_rescale_q_rnd$descriptor() {
        return av_rescale_q_rnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd)
     * }
     */
    public static MethodHandle av_rescale_q_rnd$handle() {
        return av_rescale_q_rnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd)
     * }
     */
    public static MemorySegment av_rescale_q_rnd$address() {
        return av_rescale_q_rnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd)
     * }
     */
    public static long av_rescale_q_rnd(long a, MemorySegment bq, MemorySegment cq, int rnd) {
        var mh$ = av_rescale_q_rnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_q_rnd", a, bq, cq, rnd);
            }
            return (long)mh$.invokeExact(a, bq, cq, rnd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_compare_ts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            AVRational.layout(),
            ffmpeg_includes_h.C_LONG_LONG,
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_compare_ts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)
     * }
     */
    public static FunctionDescriptor av_compare_ts$descriptor() {
        return av_compare_ts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)
     * }
     */
    public static MethodHandle av_compare_ts$handle() {
        return av_compare_ts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)
     * }
     */
    public static MemorySegment av_compare_ts$address() {
        return av_compare_ts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)
     * }
     */
    public static int av_compare_ts(long ts_a, MemorySegment tb_a, long ts_b, MemorySegment tb_b) {
        var mh$ = av_compare_ts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_compare_ts", ts_a, tb_a, ts_b, tb_b);
            }
            return (int)mh$.invokeExact(ts_a, tb_a, ts_b, tb_b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_compare_mod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_compare_mod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod)
     * }
     */
    public static FunctionDescriptor av_compare_mod$descriptor() {
        return av_compare_mod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod)
     * }
     */
    public static MethodHandle av_compare_mod$handle() {
        return av_compare_mod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod)
     * }
     */
    public static MemorySegment av_compare_mod$address() {
        return av_compare_mod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod)
     * }
     */
    public static long av_compare_mod(long a, long b, long mod) {
        var mh$ = av_compare_mod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_compare_mod", a, b, mod);
            }
            return (long)mh$.invokeExact(a, b, mod);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_delta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            AVRational.layout(),
            ffmpeg_includes_h.C_LONG_LONG,
            AVRational.layout(),
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_rescale_delta");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)
     * }
     */
    public static FunctionDescriptor av_rescale_delta$descriptor() {
        return av_rescale_delta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)
     * }
     */
    public static MethodHandle av_rescale_delta$handle() {
        return av_rescale_delta.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)
     * }
     */
    public static MemorySegment av_rescale_delta$address() {
        return av_rescale_delta.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)
     * }
     */
    public static long av_rescale_delta(MemorySegment in_tb, long in_ts, MemorySegment fs_tb, int duration, MemorySegment last, MemorySegment out_tb) {
        var mh$ = av_rescale_delta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_delta", in_tb, in_ts, fs_tb, duration, last, out_tb);
            }
            return (long)mh$.invokeExact(in_tb, in_ts, fs_tb, duration, last, out_tb);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_add_stable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            AVRational.layout(),
            ffmpeg_includes_h.C_LONG_LONG,
            AVRational.layout(),
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_add_stable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)
     * }
     */
    public static FunctionDescriptor av_add_stable$descriptor() {
        return av_add_stable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)
     * }
     */
    public static MethodHandle av_add_stable$handle() {
        return av_add_stable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)
     * }
     */
    public static MemorySegment av_add_stable$address() {
        return av_add_stable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)
     * }
     */
    public static long av_add_stable(MemorySegment ts_tb, long ts, MemorySegment inc_tb, long inc) {
        var mh$ = av_add_stable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_add_stable", ts_tb, ts, inc_tb, inc);
            }
            return (long)mh$.invokeExact(ts_tb, ts, inc_tb, inc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_bessel_i0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_bessel_i0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double av_bessel_i0(double x)
     * }
     */
    public static FunctionDescriptor av_bessel_i0$descriptor() {
        return av_bessel_i0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double av_bessel_i0(double x)
     * }
     */
    public static MethodHandle av_bessel_i0$handle() {
        return av_bessel_i0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double av_bessel_i0(double x)
     * }
     */
    public static MemorySegment av_bessel_i0$address() {
        return av_bessel_i0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double av_bessel_i0(double x)
     * }
     */
    public static double av_bessel_i0(double x) {
        var mh$ = av_bessel_i0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_bessel_i0", x);
            }
            return (double)mh$.invokeExact(x);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = ffmpeg_includes_h.C_POINTER;
    private static final int AV_CLASS_CATEGORY_NA = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_NA = 0
     * }
     */
    public static int AV_CLASS_CATEGORY_NA() {
        return AV_CLASS_CATEGORY_NA;
    }
    private static final int AV_CLASS_CATEGORY_INPUT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_INPUT = 1
     * }
     */
    public static int AV_CLASS_CATEGORY_INPUT() {
        return AV_CLASS_CATEGORY_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_OUTPUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_OUTPUT = 2
     * }
     */
    public static int AV_CLASS_CATEGORY_OUTPUT() {
        return AV_CLASS_CATEGORY_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_MUXER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_MUXER = 3
     * }
     */
    public static int AV_CLASS_CATEGORY_MUXER() {
        return AV_CLASS_CATEGORY_MUXER;
    }
    private static final int AV_CLASS_CATEGORY_DEMUXER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEMUXER = 4
     * }
     */
    public static int AV_CLASS_CATEGORY_DEMUXER() {
        return AV_CLASS_CATEGORY_DEMUXER;
    }
    private static final int AV_CLASS_CATEGORY_ENCODER = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_ENCODER = 5
     * }
     */
    public static int AV_CLASS_CATEGORY_ENCODER() {
        return AV_CLASS_CATEGORY_ENCODER;
    }
    private static final int AV_CLASS_CATEGORY_DECODER = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DECODER = 6
     * }
     */
    public static int AV_CLASS_CATEGORY_DECODER() {
        return AV_CLASS_CATEGORY_DECODER;
    }
    private static final int AV_CLASS_CATEGORY_FILTER = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_FILTER = 7
     * }
     */
    public static int AV_CLASS_CATEGORY_FILTER() {
        return AV_CLASS_CATEGORY_FILTER;
    }
    private static final int AV_CLASS_CATEGORY_BITSTREAM_FILTER = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8
     * }
     */
    public static int AV_CLASS_CATEGORY_BITSTREAM_FILTER() {
        return AV_CLASS_CATEGORY_BITSTREAM_FILTER;
    }
    private static final int AV_CLASS_CATEGORY_SWSCALER = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_SWSCALER = 9
     * }
     */
    public static int AV_CLASS_CATEGORY_SWSCALER() {
        return AV_CLASS_CATEGORY_SWSCALER;
    }
    private static final int AV_CLASS_CATEGORY_SWRESAMPLER = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_SWRESAMPLER = 10
     * }
     */
    public static int AV_CLASS_CATEGORY_SWRESAMPLER() {
        return AV_CLASS_CATEGORY_SWRESAMPLER;
    }
    private static final int AV_CLASS_CATEGORY_HWDEVICE = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_HWDEVICE = 11
     * }
     */
    public static int AV_CLASS_CATEGORY_HWDEVICE() {
        return AV_CLASS_CATEGORY_HWDEVICE;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT() {
        return AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = 41
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT() {
        return AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = 42
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT() {
        return AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = 43
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT() {
        return AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_OUTPUT = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_OUTPUT = 44
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_OUTPUT() {
        return AV_CLASS_CATEGORY_DEVICE_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_INPUT = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_INPUT = 45
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_INPUT() {
        return AV_CLASS_CATEGORY_DEVICE_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_NB = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_NB = 46
     * }
     */
    public static int AV_CLASS_CATEGORY_NB() {
        return AV_CLASS_CATEGORY_NB;
    }
    private static final int AV_CLASS_STATE_INITIALIZED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVClassStateFlags.AV_CLASS_STATE_INITIALIZED = 1
     * }
     */
    public static int AV_CLASS_STATE_INITIALIZED() {
        return AV_CLASS_STATE_INITIALIZED;
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void av_log(void *avcl, int level, const char *fmt, ...)
     * }
     */
    public static class av_log {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                ffmpeg_includes_h.C_POINTER,
                ffmpeg_includes_h.C_INT,
                ffmpeg_includes_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private av_log(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void av_log(void *avcl, int level, const char *fmt, ...)
         * }
         */
        public static av_log makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new av_log(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment avcl, int level, MemorySegment fmt, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("av_log", avcl, level, fmt, x3);
                }
                 spreader.invokeExact(avcl, level, fmt, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void av_log_once(void *avcl, int initial_level, int subsequent_level, int *state, const char *fmt, ...)
     * }
     */
    public static class av_log_once {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                ffmpeg_includes_h.C_POINTER,
                ffmpeg_includes_h.C_INT,
                ffmpeg_includes_h.C_INT,
                ffmpeg_includes_h.C_POINTER,
                ffmpeg_includes_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_once");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private av_log_once(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void av_log_once(void *avcl, int initial_level, int subsequent_level, int *state, const char *fmt, ...)
         * }
         */
        public static av_log_once makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new av_log_once(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment avcl, int initial_level, int subsequent_level, MemorySegment state, MemorySegment fmt, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("av_log_once", avcl, initial_level, subsequent_level, state, fmt, x5);
                }
                 spreader.invokeExact(avcl, initial_level, subsequent_level, state, fmt, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class av_vlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_vlog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_vlog(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static FunctionDescriptor av_vlog$descriptor() {
        return av_vlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_vlog(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static MethodHandle av_vlog$handle() {
        return av_vlog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_vlog(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static MemorySegment av_vlog$address() {
        return av_vlog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_vlog(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static void av_vlog(MemorySegment avcl, int level, MemorySegment fmt, MemorySegment vl) {
        var mh$ = av_vlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_vlog", avcl, level, fmt, vl);
            }
            mh$.invokeExact(avcl, level, fmt, vl);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_get_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_get_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log_get_level()
     * }
     */
    public static FunctionDescriptor av_log_get_level$descriptor() {
        return av_log_get_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log_get_level()
     * }
     */
    public static MethodHandle av_log_get_level$handle() {
        return av_log_get_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_log_get_level()
     * }
     */
    public static MemorySegment av_log_get_level$address() {
        return av_log_get_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_log_get_level()
     * }
     */
    public static int av_log_get_level() {
        var mh$ = av_log_get_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_get_level");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_set_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_set_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static FunctionDescriptor av_log_set_level$descriptor() {
        return av_log_set_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static MethodHandle av_log_set_level$handle() {
        return av_log_set_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static MemorySegment av_log_set_level$address() {
        return av_log_set_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static void av_log_set_level(int level) {
        var mh$ = av_log_set_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_set_level", level);
            }
            mh$.invokeExact(level);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_set_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_set_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_set_callback(void (*callback)(void *, int, const char *, va_list))
     * }
     */
    public static FunctionDescriptor av_log_set_callback$descriptor() {
        return av_log_set_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_set_callback(void (*callback)(void *, int, const char *, va_list))
     * }
     */
    public static MethodHandle av_log_set_callback$handle() {
        return av_log_set_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_set_callback(void (*callback)(void *, int, const char *, va_list))
     * }
     */
    public static MemorySegment av_log_set_callback$address() {
        return av_log_set_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_set_callback(void (*callback)(void *, int, const char *, va_list))
     * }
     */
    public static void av_log_set_callback(MemorySegment callback) {
        var mh$ = av_log_set_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_set_callback", callback);
            }
            mh$.invokeExact(callback);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_default_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_default_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static FunctionDescriptor av_log_default_callback$descriptor() {
        return av_log_default_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static MethodHandle av_log_default_callback$handle() {
        return av_log_default_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static MemorySegment av_log_default_callback$address() {
        return av_log_default_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static void av_log_default_callback(MemorySegment avcl, int level, MemorySegment fmt, MemorySegment vl) {
        var mh$ = av_log_default_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_default_callback", avcl, level, fmt, vl);
            }
            mh$.invokeExact(avcl, level, fmt, vl);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_default_item_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_default_item_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_default_item_name(void *ctx)
     * }
     */
    public static FunctionDescriptor av_default_item_name$descriptor() {
        return av_default_item_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_default_item_name(void *ctx)
     * }
     */
    public static MethodHandle av_default_item_name$handle() {
        return av_default_item_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_default_item_name(void *ctx)
     * }
     */
    public static MemorySegment av_default_item_name$address() {
        return av_default_item_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_default_item_name(void *ctx)
     * }
     */
    public static MemorySegment av_default_item_name(MemorySegment ctx) {
        var mh$ = av_default_item_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_default_item_name", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_default_get_category {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_default_get_category");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVClassCategory av_default_get_category(void *ptr)
     * }
     */
    public static FunctionDescriptor av_default_get_category$descriptor() {
        return av_default_get_category.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVClassCategory av_default_get_category(void *ptr)
     * }
     */
    public static MethodHandle av_default_get_category$handle() {
        return av_default_get_category.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVClassCategory av_default_get_category(void *ptr)
     * }
     */
    public static MemorySegment av_default_get_category$address() {
        return av_default_get_category.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVClassCategory av_default_get_category(void *ptr)
     * }
     */
    public static int av_default_get_category(MemorySegment ptr) {
        var mh$ = av_default_get_category.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_default_get_category", ptr);
            }
            return (int)mh$.invokeExact(ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_format_line {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_format_line");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static FunctionDescriptor av_log_format_line$descriptor() {
        return av_log_format_line.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static MethodHandle av_log_format_line$handle() {
        return av_log_format_line.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static MemorySegment av_log_format_line$address() {
        return av_log_format_line.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static void av_log_format_line(MemorySegment ptr, int level, MemorySegment fmt, MemorySegment vl, MemorySegment line, int line_size, MemorySegment print_prefix) {
        var mh$ = av_log_format_line.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_format_line", ptr, level, fmt, vl, line, line_size, print_prefix);
            }
            mh$.invokeExact(ptr, level, fmt, vl, line, line_size, print_prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_format_line2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_format_line2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static FunctionDescriptor av_log_format_line2$descriptor() {
        return av_log_format_line2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static MethodHandle av_log_format_line2$handle() {
        return av_log_format_line2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static MemorySegment av_log_format_line2$address() {
        return av_log_format_line2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static int av_log_format_line2(MemorySegment ptr, int level, MemorySegment fmt, MemorySegment vl, MemorySegment line, int line_size, MemorySegment print_prefix) {
        var mh$ = av_log_format_line2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_format_line2", ptr, level, fmt, vl, line, line_size, print_prefix);
            }
            return (int)mh$.invokeExact(ptr, level, fmt, vl, line, line_size, print_prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_set_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_set_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_set_flags(int arg)
     * }
     */
    public static FunctionDescriptor av_log_set_flags$descriptor() {
        return av_log_set_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_set_flags(int arg)
     * }
     */
    public static MethodHandle av_log_set_flags$handle() {
        return av_log_set_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_set_flags(int arg)
     * }
     */
    public static MemorySegment av_log_set_flags$address() {
        return av_log_set_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_set_flags(int arg)
     * }
     */
    public static void av_log_set_flags(int arg) {
        var mh$ = av_log_set_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_set_flags", arg);
            }
            mh$.invokeExact(arg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_get_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_get_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log_get_flags()
     * }
     */
    public static FunctionDescriptor av_log_get_flags$descriptor() {
        return av_log_get_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log_get_flags()
     * }
     */
    public static MethodHandle av_log_get_flags$handle() {
        return av_log_get_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_log_get_flags()
     * }
     */
    public static MemorySegment av_log_get_flags$address() {
        return av_log_get_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_log_get_flags()
     * }
     */
    public static int av_log_get_flags() {
        var mh$ = av_log_get_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_get_flags");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_PIX_FMT_NONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NONE = -1
     * }
     */
    public static int AV_PIX_FMT_NONE() {
        return AV_PIX_FMT_NONE;
    }
    private static final int AV_PIX_FMT_YUV420P = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P = 0
     * }
     */
    public static int AV_PIX_FMT_YUV420P() {
        return AV_PIX_FMT_YUV420P;
    }
    private static final int AV_PIX_FMT_YUYV422 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUYV422 = 1
     * }
     */
    public static int AV_PIX_FMT_YUYV422() {
        return AV_PIX_FMT_YUYV422;
    }
    private static final int AV_PIX_FMT_RGB24 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB24 = 2
     * }
     */
    public static int AV_PIX_FMT_RGB24() {
        return AV_PIX_FMT_RGB24;
    }
    private static final int AV_PIX_FMT_BGR24 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR24 = 3
     * }
     */
    public static int AV_PIX_FMT_BGR24() {
        return AV_PIX_FMT_BGR24;
    }
    private static final int AV_PIX_FMT_YUV422P = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P = 4
     * }
     */
    public static int AV_PIX_FMT_YUV422P() {
        return AV_PIX_FMT_YUV422P;
    }
    private static final int AV_PIX_FMT_YUV444P = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P = 5
     * }
     */
    public static int AV_PIX_FMT_YUV444P() {
        return AV_PIX_FMT_YUV444P;
    }
    private static final int AV_PIX_FMT_YUV410P = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV410P = 6
     * }
     */
    public static int AV_PIX_FMT_YUV410P() {
        return AV_PIX_FMT_YUV410P;
    }
    private static final int AV_PIX_FMT_YUV411P = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV411P = 7
     * }
     */
    public static int AV_PIX_FMT_YUV411P() {
        return AV_PIX_FMT_YUV411P;
    }
    private static final int AV_PIX_FMT_GRAY8 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY8 = 8
     * }
     */
    public static int AV_PIX_FMT_GRAY8() {
        return AV_PIX_FMT_GRAY8;
    }
    private static final int AV_PIX_FMT_MONOWHITE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MONOWHITE = 9
     * }
     */
    public static int AV_PIX_FMT_MONOWHITE() {
        return AV_PIX_FMT_MONOWHITE;
    }
    private static final int AV_PIX_FMT_MONOBLACK = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MONOBLACK = 10
     * }
     */
    public static int AV_PIX_FMT_MONOBLACK() {
        return AV_PIX_FMT_MONOBLACK;
    }
    private static final int AV_PIX_FMT_PAL8 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_PAL8 = 11
     * }
     */
    public static int AV_PIX_FMT_PAL8() {
        return AV_PIX_FMT_PAL8;
    }
    private static final int AV_PIX_FMT_YUVJ420P = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ420P = 12
     * }
     */
    public static int AV_PIX_FMT_YUVJ420P() {
        return AV_PIX_FMT_YUVJ420P;
    }
    private static final int AV_PIX_FMT_YUVJ422P = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ422P = 13
     * }
     */
    public static int AV_PIX_FMT_YUVJ422P() {
        return AV_PIX_FMT_YUVJ422P;
    }
    private static final int AV_PIX_FMT_YUVJ444P = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ444P = 14
     * }
     */
    public static int AV_PIX_FMT_YUVJ444P() {
        return AV_PIX_FMT_YUVJ444P;
    }
    private static final int AV_PIX_FMT_UYVY422 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_UYVY422 = 15
     * }
     */
    public static int AV_PIX_FMT_UYVY422() {
        return AV_PIX_FMT_UYVY422;
    }
    private static final int AV_PIX_FMT_UYYVYY411 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_UYYVYY411 = 16
     * }
     */
    public static int AV_PIX_FMT_UYYVYY411() {
        return AV_PIX_FMT_UYYVYY411;
    }
    private static final int AV_PIX_FMT_BGR8 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR8 = 17
     * }
     */
    public static int AV_PIX_FMT_BGR8() {
        return AV_PIX_FMT_BGR8;
    }
    private static final int AV_PIX_FMT_BGR4 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR4 = 18
     * }
     */
    public static int AV_PIX_FMT_BGR4() {
        return AV_PIX_FMT_BGR4;
    }
    private static final int AV_PIX_FMT_BGR4_BYTE = (int)19L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR4_BYTE = 19
     * }
     */
    public static int AV_PIX_FMT_BGR4_BYTE() {
        return AV_PIX_FMT_BGR4_BYTE;
    }
    private static final int AV_PIX_FMT_RGB8 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB8 = 20
     * }
     */
    public static int AV_PIX_FMT_RGB8() {
        return AV_PIX_FMT_RGB8;
    }
    private static final int AV_PIX_FMT_RGB4 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB4 = 21
     * }
     */
    public static int AV_PIX_FMT_RGB4() {
        return AV_PIX_FMT_RGB4;
    }
    private static final int AV_PIX_FMT_RGB4_BYTE = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB4_BYTE = 22
     * }
     */
    public static int AV_PIX_FMT_RGB4_BYTE() {
        return AV_PIX_FMT_RGB4_BYTE;
    }
    private static final int AV_PIX_FMT_NV12 = (int)23L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV12 = 23
     * }
     */
    public static int AV_PIX_FMT_NV12() {
        return AV_PIX_FMT_NV12;
    }
    private static final int AV_PIX_FMT_NV21 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV21 = 24
     * }
     */
    public static int AV_PIX_FMT_NV21() {
        return AV_PIX_FMT_NV21;
    }
    private static final int AV_PIX_FMT_ARGB = (int)25L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_ARGB = 25
     * }
     */
    public static int AV_PIX_FMT_ARGB() {
        return AV_PIX_FMT_ARGB;
    }
    private static final int AV_PIX_FMT_RGBA = (int)26L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA = 26
     * }
     */
    public static int AV_PIX_FMT_RGBA() {
        return AV_PIX_FMT_RGBA;
    }
    private static final int AV_PIX_FMT_ABGR = (int)27L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_ABGR = 27
     * }
     */
    public static int AV_PIX_FMT_ABGR() {
        return AV_PIX_FMT_ABGR;
    }
    private static final int AV_PIX_FMT_BGRA = (int)28L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGRA = 28
     * }
     */
    public static int AV_PIX_FMT_BGRA() {
        return AV_PIX_FMT_BGRA;
    }
    private static final int AV_PIX_FMT_GRAY16BE = (int)29L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY16BE = 29
     * }
     */
    public static int AV_PIX_FMT_GRAY16BE() {
        return AV_PIX_FMT_GRAY16BE;
    }
    private static final int AV_PIX_FMT_GRAY16LE = (int)30L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY16LE = 30
     * }
     */
    public static int AV_PIX_FMT_GRAY16LE() {
        return AV_PIX_FMT_GRAY16LE;
    }
    private static final int AV_PIX_FMT_YUV440P = (int)31L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P = 31
     * }
     */
    public static int AV_PIX_FMT_YUV440P() {
        return AV_PIX_FMT_YUV440P;
    }
    private static final int AV_PIX_FMT_YUVJ440P = (int)32L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ440P = 32
     * }
     */
    public static int AV_PIX_FMT_YUVJ440P() {
        return AV_PIX_FMT_YUVJ440P;
    }
    private static final int AV_PIX_FMT_YUVA420P = (int)33L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P = 33
     * }
     */
    public static int AV_PIX_FMT_YUVA420P() {
        return AV_PIX_FMT_YUVA420P;
    }
    private static final int AV_PIX_FMT_RGB48BE = (int)34L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB48BE = 34
     * }
     */
    public static int AV_PIX_FMT_RGB48BE() {
        return AV_PIX_FMT_RGB48BE;
    }
    private static final int AV_PIX_FMT_RGB48LE = (int)35L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB48LE = 35
     * }
     */
    public static int AV_PIX_FMT_RGB48LE() {
        return AV_PIX_FMT_RGB48LE;
    }
    private static final int AV_PIX_FMT_RGB565BE = (int)36L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB565BE = 36
     * }
     */
    public static int AV_PIX_FMT_RGB565BE() {
        return AV_PIX_FMT_RGB565BE;
    }
    private static final int AV_PIX_FMT_RGB565LE = (int)37L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB565LE = 37
     * }
     */
    public static int AV_PIX_FMT_RGB565LE() {
        return AV_PIX_FMT_RGB565LE;
    }
    private static final int AV_PIX_FMT_RGB555BE = (int)38L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB555BE = 38
     * }
     */
    public static int AV_PIX_FMT_RGB555BE() {
        return AV_PIX_FMT_RGB555BE;
    }
    private static final int AV_PIX_FMT_RGB555LE = (int)39L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB555LE = 39
     * }
     */
    public static int AV_PIX_FMT_RGB555LE() {
        return AV_PIX_FMT_RGB555LE;
    }
    private static final int AV_PIX_FMT_BGR565BE = (int)40L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR565BE = 40
     * }
     */
    public static int AV_PIX_FMT_BGR565BE() {
        return AV_PIX_FMT_BGR565BE;
    }
    private static final int AV_PIX_FMT_BGR565LE = (int)41L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR565LE = 41
     * }
     */
    public static int AV_PIX_FMT_BGR565LE() {
        return AV_PIX_FMT_BGR565LE;
    }
    private static final int AV_PIX_FMT_BGR555BE = (int)42L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR555BE = 42
     * }
     */
    public static int AV_PIX_FMT_BGR555BE() {
        return AV_PIX_FMT_BGR555BE;
    }
    private static final int AV_PIX_FMT_BGR555LE = (int)43L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR555LE = 43
     * }
     */
    public static int AV_PIX_FMT_BGR555LE() {
        return AV_PIX_FMT_BGR555LE;
    }
    private static final int AV_PIX_FMT_VAAPI = (int)44L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VAAPI = 44
     * }
     */
    public static int AV_PIX_FMT_VAAPI() {
        return AV_PIX_FMT_VAAPI;
    }
    private static final int AV_PIX_FMT_YUV420P16LE = (int)45L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P16LE = 45
     * }
     */
    public static int AV_PIX_FMT_YUV420P16LE() {
        return AV_PIX_FMT_YUV420P16LE;
    }
    private static final int AV_PIX_FMT_YUV420P16BE = (int)46L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P16BE = 46
     * }
     */
    public static int AV_PIX_FMT_YUV420P16BE() {
        return AV_PIX_FMT_YUV420P16BE;
    }
    private static final int AV_PIX_FMT_YUV422P16LE = (int)47L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P16LE = 47
     * }
     */
    public static int AV_PIX_FMT_YUV422P16LE() {
        return AV_PIX_FMT_YUV422P16LE;
    }
    private static final int AV_PIX_FMT_YUV422P16BE = (int)48L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P16BE = 48
     * }
     */
    public static int AV_PIX_FMT_YUV422P16BE() {
        return AV_PIX_FMT_YUV422P16BE;
    }
    private static final int AV_PIX_FMT_YUV444P16LE = (int)49L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P16LE = 49
     * }
     */
    public static int AV_PIX_FMT_YUV444P16LE() {
        return AV_PIX_FMT_YUV444P16LE;
    }
    private static final int AV_PIX_FMT_YUV444P16BE = (int)50L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P16BE = 50
     * }
     */
    public static int AV_PIX_FMT_YUV444P16BE() {
        return AV_PIX_FMT_YUV444P16BE;
    }
    private static final int AV_PIX_FMT_DXVA2_VLD = (int)51L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_DXVA2_VLD = 51
     * }
     */
    public static int AV_PIX_FMT_DXVA2_VLD() {
        return AV_PIX_FMT_DXVA2_VLD;
    }
    private static final int AV_PIX_FMT_RGB444LE = (int)52L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB444LE = 52
     * }
     */
    public static int AV_PIX_FMT_RGB444LE() {
        return AV_PIX_FMT_RGB444LE;
    }
    private static final int AV_PIX_FMT_RGB444BE = (int)53L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB444BE = 53
     * }
     */
    public static int AV_PIX_FMT_RGB444BE() {
        return AV_PIX_FMT_RGB444BE;
    }
    private static final int AV_PIX_FMT_BGR444LE = (int)54L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR444LE = 54
     * }
     */
    public static int AV_PIX_FMT_BGR444LE() {
        return AV_PIX_FMT_BGR444LE;
    }
    private static final int AV_PIX_FMT_BGR444BE = (int)55L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR444BE = 55
     * }
     */
    public static int AV_PIX_FMT_BGR444BE() {
        return AV_PIX_FMT_BGR444BE;
    }
    private static final int AV_PIX_FMT_YA8 = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YA8 = 56
     * }
     */
    public static int AV_PIX_FMT_YA8() {
        return AV_PIX_FMT_YA8;
    }
    private static final int AV_PIX_FMT_Y400A = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y400A = 56
     * }
     */
    public static int AV_PIX_FMT_Y400A() {
        return AV_PIX_FMT_Y400A;
    }
    private static final int AV_PIX_FMT_GRAY8A = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY8A = 56
     * }
     */
    public static int AV_PIX_FMT_GRAY8A() {
        return AV_PIX_FMT_GRAY8A;
    }
    private static final int AV_PIX_FMT_BGR48BE = (int)57L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR48BE = 57
     * }
     */
    public static int AV_PIX_FMT_BGR48BE() {
        return AV_PIX_FMT_BGR48BE;
    }
    private static final int AV_PIX_FMT_BGR48LE = (int)58L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR48LE = 58
     * }
     */
    public static int AV_PIX_FMT_BGR48LE() {
        return AV_PIX_FMT_BGR48LE;
    }
    private static final int AV_PIX_FMT_YUV420P9BE = (int)59L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P9BE = 59
     * }
     */
    public static int AV_PIX_FMT_YUV420P9BE() {
        return AV_PIX_FMT_YUV420P9BE;
    }
    private static final int AV_PIX_FMT_YUV420P9LE = (int)60L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P9LE = 60
     * }
     */
    public static int AV_PIX_FMT_YUV420P9LE() {
        return AV_PIX_FMT_YUV420P9LE;
    }
    private static final int AV_PIX_FMT_YUV420P10BE = (int)61L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P10BE = 61
     * }
     */
    public static int AV_PIX_FMT_YUV420P10BE() {
        return AV_PIX_FMT_YUV420P10BE;
    }
    private static final int AV_PIX_FMT_YUV420P10LE = (int)62L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P10LE = 62
     * }
     */
    public static int AV_PIX_FMT_YUV420P10LE() {
        return AV_PIX_FMT_YUV420P10LE;
    }
    private static final int AV_PIX_FMT_YUV422P10BE = (int)63L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P10BE = 63
     * }
     */
    public static int AV_PIX_FMT_YUV422P10BE() {
        return AV_PIX_FMT_YUV422P10BE;
    }
    private static final int AV_PIX_FMT_YUV422P10LE = (int)64L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P10LE = 64
     * }
     */
    public static int AV_PIX_FMT_YUV422P10LE() {
        return AV_PIX_FMT_YUV422P10LE;
    }
    private static final int AV_PIX_FMT_YUV444P9BE = (int)65L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P9BE = 65
     * }
     */
    public static int AV_PIX_FMT_YUV444P9BE() {
        return AV_PIX_FMT_YUV444P9BE;
    }
    private static final int AV_PIX_FMT_YUV444P9LE = (int)66L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P9LE = 66
     * }
     */
    public static int AV_PIX_FMT_YUV444P9LE() {
        return AV_PIX_FMT_YUV444P9LE;
    }
    private static final int AV_PIX_FMT_YUV444P10BE = (int)67L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P10BE = 67
     * }
     */
    public static int AV_PIX_FMT_YUV444P10BE() {
        return AV_PIX_FMT_YUV444P10BE;
    }
    private static final int AV_PIX_FMT_YUV444P10LE = (int)68L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P10LE = 68
     * }
     */
    public static int AV_PIX_FMT_YUV444P10LE() {
        return AV_PIX_FMT_YUV444P10LE;
    }
    private static final int AV_PIX_FMT_YUV422P9BE = (int)69L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P9BE = 69
     * }
     */
    public static int AV_PIX_FMT_YUV422P9BE() {
        return AV_PIX_FMT_YUV422P9BE;
    }
    private static final int AV_PIX_FMT_YUV422P9LE = (int)70L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P9LE = 70
     * }
     */
    public static int AV_PIX_FMT_YUV422P9LE() {
        return AV_PIX_FMT_YUV422P9LE;
    }
    private static final int AV_PIX_FMT_GBRP = (int)71L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP = 71
     * }
     */
    public static int AV_PIX_FMT_GBRP() {
        return AV_PIX_FMT_GBRP;
    }
    private static final int AV_PIX_FMT_GBR24P = (int)71L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBR24P = 71
     * }
     */
    public static int AV_PIX_FMT_GBR24P() {
        return AV_PIX_FMT_GBR24P;
    }
    private static final int AV_PIX_FMT_GBRP9BE = (int)72L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP9BE = 72
     * }
     */
    public static int AV_PIX_FMT_GBRP9BE() {
        return AV_PIX_FMT_GBRP9BE;
    }
    private static final int AV_PIX_FMT_GBRP9LE = (int)73L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP9LE = 73
     * }
     */
    public static int AV_PIX_FMT_GBRP9LE() {
        return AV_PIX_FMT_GBRP9LE;
    }
    private static final int AV_PIX_FMT_GBRP10BE = (int)74L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP10BE = 74
     * }
     */
    public static int AV_PIX_FMT_GBRP10BE() {
        return AV_PIX_FMT_GBRP10BE;
    }
    private static final int AV_PIX_FMT_GBRP10LE = (int)75L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP10LE = 75
     * }
     */
    public static int AV_PIX_FMT_GBRP10LE() {
        return AV_PIX_FMT_GBRP10LE;
    }
    private static final int AV_PIX_FMT_GBRP16BE = (int)76L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP16BE = 76
     * }
     */
    public static int AV_PIX_FMT_GBRP16BE() {
        return AV_PIX_FMT_GBRP16BE;
    }
    private static final int AV_PIX_FMT_GBRP16LE = (int)77L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP16LE = 77
     * }
     */
    public static int AV_PIX_FMT_GBRP16LE() {
        return AV_PIX_FMT_GBRP16LE;
    }
    private static final int AV_PIX_FMT_YUVA422P = (int)78L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P = 78
     * }
     */
    public static int AV_PIX_FMT_YUVA422P() {
        return AV_PIX_FMT_YUVA422P;
    }
    private static final int AV_PIX_FMT_YUVA444P = (int)79L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P = 79
     * }
     */
    public static int AV_PIX_FMT_YUVA444P() {
        return AV_PIX_FMT_YUVA444P;
    }
    private static final int AV_PIX_FMT_YUVA420P9BE = (int)80L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P9BE = 80
     * }
     */
    public static int AV_PIX_FMT_YUVA420P9BE() {
        return AV_PIX_FMT_YUVA420P9BE;
    }
    private static final int AV_PIX_FMT_YUVA420P9LE = (int)81L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P9LE = 81
     * }
     */
    public static int AV_PIX_FMT_YUVA420P9LE() {
        return AV_PIX_FMT_YUVA420P9LE;
    }
    private static final int AV_PIX_FMT_YUVA422P9BE = (int)82L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P9BE = 82
     * }
     */
    public static int AV_PIX_FMT_YUVA422P9BE() {
        return AV_PIX_FMT_YUVA422P9BE;
    }
    private static final int AV_PIX_FMT_YUVA422P9LE = (int)83L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P9LE = 83
     * }
     */
    public static int AV_PIX_FMT_YUVA422P9LE() {
        return AV_PIX_FMT_YUVA422P9LE;
    }
    private static final int AV_PIX_FMT_YUVA444P9BE = (int)84L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P9BE = 84
     * }
     */
    public static int AV_PIX_FMT_YUVA444P9BE() {
        return AV_PIX_FMT_YUVA444P9BE;
    }
    private static final int AV_PIX_FMT_YUVA444P9LE = (int)85L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P9LE = 85
     * }
     */
    public static int AV_PIX_FMT_YUVA444P9LE() {
        return AV_PIX_FMT_YUVA444P9LE;
    }
    private static final int AV_PIX_FMT_YUVA420P10BE = (int)86L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P10BE = 86
     * }
     */
    public static int AV_PIX_FMT_YUVA420P10BE() {
        return AV_PIX_FMT_YUVA420P10BE;
    }
    private static final int AV_PIX_FMT_YUVA420P10LE = (int)87L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P10LE = 87
     * }
     */
    public static int AV_PIX_FMT_YUVA420P10LE() {
        return AV_PIX_FMT_YUVA420P10LE;
    }
    private static final int AV_PIX_FMT_YUVA422P10BE = (int)88L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P10BE = 88
     * }
     */
    public static int AV_PIX_FMT_YUVA422P10BE() {
        return AV_PIX_FMT_YUVA422P10BE;
    }
    private static final int AV_PIX_FMT_YUVA422P10LE = (int)89L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P10LE = 89
     * }
     */
    public static int AV_PIX_FMT_YUVA422P10LE() {
        return AV_PIX_FMT_YUVA422P10LE;
    }
    private static final int AV_PIX_FMT_YUVA444P10BE = (int)90L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P10BE = 90
     * }
     */
    public static int AV_PIX_FMT_YUVA444P10BE() {
        return AV_PIX_FMT_YUVA444P10BE;
    }
    private static final int AV_PIX_FMT_YUVA444P10LE = (int)91L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P10LE = 91
     * }
     */
    public static int AV_PIX_FMT_YUVA444P10LE() {
        return AV_PIX_FMT_YUVA444P10LE;
    }
    private static final int AV_PIX_FMT_YUVA420P16BE = (int)92L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P16BE = 92
     * }
     */
    public static int AV_PIX_FMT_YUVA420P16BE() {
        return AV_PIX_FMT_YUVA420P16BE;
    }
    private static final int AV_PIX_FMT_YUVA420P16LE = (int)93L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P16LE = 93
     * }
     */
    public static int AV_PIX_FMT_YUVA420P16LE() {
        return AV_PIX_FMT_YUVA420P16LE;
    }
    private static final int AV_PIX_FMT_YUVA422P16BE = (int)94L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P16BE = 94
     * }
     */
    public static int AV_PIX_FMT_YUVA422P16BE() {
        return AV_PIX_FMT_YUVA422P16BE;
    }
    private static final int AV_PIX_FMT_YUVA422P16LE = (int)95L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P16LE = 95
     * }
     */
    public static int AV_PIX_FMT_YUVA422P16LE() {
        return AV_PIX_FMT_YUVA422P16LE;
    }
    private static final int AV_PIX_FMT_YUVA444P16BE = (int)96L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P16BE = 96
     * }
     */
    public static int AV_PIX_FMT_YUVA444P16BE() {
        return AV_PIX_FMT_YUVA444P16BE;
    }
    private static final int AV_PIX_FMT_YUVA444P16LE = (int)97L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P16LE = 97
     * }
     */
    public static int AV_PIX_FMT_YUVA444P16LE() {
        return AV_PIX_FMT_YUVA444P16LE;
    }
    private static final int AV_PIX_FMT_VDPAU = (int)98L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VDPAU = 98
     * }
     */
    public static int AV_PIX_FMT_VDPAU() {
        return AV_PIX_FMT_VDPAU;
    }
    private static final int AV_PIX_FMT_XYZ12LE = (int)99L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XYZ12LE = 99
     * }
     */
    public static int AV_PIX_FMT_XYZ12LE() {
        return AV_PIX_FMT_XYZ12LE;
    }
    private static final int AV_PIX_FMT_XYZ12BE = (int)100L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XYZ12BE = 100
     * }
     */
    public static int AV_PIX_FMT_XYZ12BE() {
        return AV_PIX_FMT_XYZ12BE;
    }
    private static final int AV_PIX_FMT_NV16 = (int)101L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV16 = 101
     * }
     */
    public static int AV_PIX_FMT_NV16() {
        return AV_PIX_FMT_NV16;
    }
    private static final int AV_PIX_FMT_NV20LE = (int)102L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV20LE = 102
     * }
     */
    public static int AV_PIX_FMT_NV20LE() {
        return AV_PIX_FMT_NV20LE;
    }
    private static final int AV_PIX_FMT_NV20BE = (int)103L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV20BE = 103
     * }
     */
    public static int AV_PIX_FMT_NV20BE() {
        return AV_PIX_FMT_NV20BE;
    }
    private static final int AV_PIX_FMT_RGBA64BE = (int)104L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA64BE = 104
     * }
     */
    public static int AV_PIX_FMT_RGBA64BE() {
        return AV_PIX_FMT_RGBA64BE;
    }
    private static final int AV_PIX_FMT_RGBA64LE = (int)105L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA64LE = 105
     * }
     */
    public static int AV_PIX_FMT_RGBA64LE() {
        return AV_PIX_FMT_RGBA64LE;
    }
    private static final int AV_PIX_FMT_BGRA64BE = (int)106L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGRA64BE = 106
     * }
     */
    public static int AV_PIX_FMT_BGRA64BE() {
        return AV_PIX_FMT_BGRA64BE;
    }
    private static final int AV_PIX_FMT_BGRA64LE = (int)107L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGRA64LE = 107
     * }
     */
    public static int AV_PIX_FMT_BGRA64LE() {
        return AV_PIX_FMT_BGRA64LE;
    }
    private static final int AV_PIX_FMT_YVYU422 = (int)108L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YVYU422 = 108
     * }
     */
    public static int AV_PIX_FMT_YVYU422() {
        return AV_PIX_FMT_YVYU422;
    }
    private static final int AV_PIX_FMT_YA16BE = (int)109L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YA16BE = 109
     * }
     */
    public static int AV_PIX_FMT_YA16BE() {
        return AV_PIX_FMT_YA16BE;
    }
    private static final int AV_PIX_FMT_YA16LE = (int)110L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YA16LE = 110
     * }
     */
    public static int AV_PIX_FMT_YA16LE() {
        return AV_PIX_FMT_YA16LE;
    }
    private static final int AV_PIX_FMT_GBRAP = (int)111L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP = 111
     * }
     */
    public static int AV_PIX_FMT_GBRAP() {
        return AV_PIX_FMT_GBRAP;
    }
    private static final int AV_PIX_FMT_GBRAP16BE = (int)112L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP16BE = 112
     * }
     */
    public static int AV_PIX_FMT_GBRAP16BE() {
        return AV_PIX_FMT_GBRAP16BE;
    }
    private static final int AV_PIX_FMT_GBRAP16LE = (int)113L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP16LE = 113
     * }
     */
    public static int AV_PIX_FMT_GBRAP16LE() {
        return AV_PIX_FMT_GBRAP16LE;
    }
    private static final int AV_PIX_FMT_QSV = (int)114L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_QSV = 114
     * }
     */
    public static int AV_PIX_FMT_QSV() {
        return AV_PIX_FMT_QSV;
    }
    private static final int AV_PIX_FMT_MMAL = (int)115L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MMAL = 115
     * }
     */
    public static int AV_PIX_FMT_MMAL() {
        return AV_PIX_FMT_MMAL;
    }
    private static final int AV_PIX_FMT_D3D11VA_VLD = (int)116L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_D3D11VA_VLD = 116
     * }
     */
    public static int AV_PIX_FMT_D3D11VA_VLD() {
        return AV_PIX_FMT_D3D11VA_VLD;
    }
    private static final int AV_PIX_FMT_CUDA = (int)117L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_CUDA = 117
     * }
     */
    public static int AV_PIX_FMT_CUDA() {
        return AV_PIX_FMT_CUDA;
    }
    private static final int AV_PIX_FMT_0RGB = (int)118L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_0RGB = 118
     * }
     */
    public static int AV_PIX_FMT_0RGB() {
        return AV_PIX_FMT_0RGB;
    }
    private static final int AV_PIX_FMT_RGB0 = (int)119L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB0 = 119
     * }
     */
    public static int AV_PIX_FMT_RGB0() {
        return AV_PIX_FMT_RGB0;
    }
    private static final int AV_PIX_FMT_0BGR = (int)120L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_0BGR = 120
     * }
     */
    public static int AV_PIX_FMT_0BGR() {
        return AV_PIX_FMT_0BGR;
    }
    private static final int AV_PIX_FMT_BGR0 = (int)121L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR0 = 121
     * }
     */
    public static int AV_PIX_FMT_BGR0() {
        return AV_PIX_FMT_BGR0;
    }
    private static final int AV_PIX_FMT_YUV420P12BE = (int)122L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P12BE = 122
     * }
     */
    public static int AV_PIX_FMT_YUV420P12BE() {
        return AV_PIX_FMT_YUV420P12BE;
    }
    private static final int AV_PIX_FMT_YUV420P12LE = (int)123L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P12LE = 123
     * }
     */
    public static int AV_PIX_FMT_YUV420P12LE() {
        return AV_PIX_FMT_YUV420P12LE;
    }
    private static final int AV_PIX_FMT_YUV420P14BE = (int)124L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P14BE = 124
     * }
     */
    public static int AV_PIX_FMT_YUV420P14BE() {
        return AV_PIX_FMT_YUV420P14BE;
    }
    private static final int AV_PIX_FMT_YUV420P14LE = (int)125L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P14LE = 125
     * }
     */
    public static int AV_PIX_FMT_YUV420P14LE() {
        return AV_PIX_FMT_YUV420P14LE;
    }
    private static final int AV_PIX_FMT_YUV422P12BE = (int)126L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P12BE = 126
     * }
     */
    public static int AV_PIX_FMT_YUV422P12BE() {
        return AV_PIX_FMT_YUV422P12BE;
    }
    private static final int AV_PIX_FMT_YUV422P12LE = (int)127L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P12LE = 127
     * }
     */
    public static int AV_PIX_FMT_YUV422P12LE() {
        return AV_PIX_FMT_YUV422P12LE;
    }
    private static final int AV_PIX_FMT_YUV422P14BE = (int)128L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P14BE = 128
     * }
     */
    public static int AV_PIX_FMT_YUV422P14BE() {
        return AV_PIX_FMT_YUV422P14BE;
    }
    private static final int AV_PIX_FMT_YUV422P14LE = (int)129L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P14LE = 129
     * }
     */
    public static int AV_PIX_FMT_YUV422P14LE() {
        return AV_PIX_FMT_YUV422P14LE;
    }
    private static final int AV_PIX_FMT_YUV444P12BE = (int)130L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P12BE = 130
     * }
     */
    public static int AV_PIX_FMT_YUV444P12BE() {
        return AV_PIX_FMT_YUV444P12BE;
    }
    private static final int AV_PIX_FMT_YUV444P12LE = (int)131L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P12LE = 131
     * }
     */
    public static int AV_PIX_FMT_YUV444P12LE() {
        return AV_PIX_FMT_YUV444P12LE;
    }
    private static final int AV_PIX_FMT_YUV444P14BE = (int)132L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P14BE = 132
     * }
     */
    public static int AV_PIX_FMT_YUV444P14BE() {
        return AV_PIX_FMT_YUV444P14BE;
    }
    private static final int AV_PIX_FMT_YUV444P14LE = (int)133L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P14LE = 133
     * }
     */
    public static int AV_PIX_FMT_YUV444P14LE() {
        return AV_PIX_FMT_YUV444P14LE;
    }
    private static final int AV_PIX_FMT_GBRP12BE = (int)134L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP12BE = 134
     * }
     */
    public static int AV_PIX_FMT_GBRP12BE() {
        return AV_PIX_FMT_GBRP12BE;
    }
    private static final int AV_PIX_FMT_GBRP12LE = (int)135L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP12LE = 135
     * }
     */
    public static int AV_PIX_FMT_GBRP12LE() {
        return AV_PIX_FMT_GBRP12LE;
    }
    private static final int AV_PIX_FMT_GBRP14BE = (int)136L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP14BE = 136
     * }
     */
    public static int AV_PIX_FMT_GBRP14BE() {
        return AV_PIX_FMT_GBRP14BE;
    }
    private static final int AV_PIX_FMT_GBRP14LE = (int)137L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP14LE = 137
     * }
     */
    public static int AV_PIX_FMT_GBRP14LE() {
        return AV_PIX_FMT_GBRP14LE;
    }
    private static final int AV_PIX_FMT_YUVJ411P = (int)138L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ411P = 138
     * }
     */
    public static int AV_PIX_FMT_YUVJ411P() {
        return AV_PIX_FMT_YUVJ411P;
    }
    private static final int AV_PIX_FMT_BAYER_BGGR8 = (int)139L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_BGGR8 = 139
     * }
     */
    public static int AV_PIX_FMT_BAYER_BGGR8() {
        return AV_PIX_FMT_BAYER_BGGR8;
    }
    private static final int AV_PIX_FMT_BAYER_RGGB8 = (int)140L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_RGGB8 = 140
     * }
     */
    public static int AV_PIX_FMT_BAYER_RGGB8() {
        return AV_PIX_FMT_BAYER_RGGB8;
    }
    private static final int AV_PIX_FMT_BAYER_GBRG8 = (int)141L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GBRG8 = 141
     * }
     */
    public static int AV_PIX_FMT_BAYER_GBRG8() {
        return AV_PIX_FMT_BAYER_GBRG8;
    }
    private static final int AV_PIX_FMT_BAYER_GRBG8 = (int)142L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GRBG8 = 142
     * }
     */
    public static int AV_PIX_FMT_BAYER_GRBG8() {
        return AV_PIX_FMT_BAYER_GRBG8;
    }
    private static final int AV_PIX_FMT_BAYER_BGGR16LE = (int)143L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_BGGR16LE = 143
     * }
     */
    public static int AV_PIX_FMT_BAYER_BGGR16LE() {
        return AV_PIX_FMT_BAYER_BGGR16LE;
    }
    private static final int AV_PIX_FMT_BAYER_BGGR16BE = (int)144L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_BGGR16BE = 144
     * }
     */
    public static int AV_PIX_FMT_BAYER_BGGR16BE() {
        return AV_PIX_FMT_BAYER_BGGR16BE;
    }
    private static final int AV_PIX_FMT_BAYER_RGGB16LE = (int)145L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_RGGB16LE = 145
     * }
     */
    public static int AV_PIX_FMT_BAYER_RGGB16LE() {
        return AV_PIX_FMT_BAYER_RGGB16LE;
    }
    private static final int AV_PIX_FMT_BAYER_RGGB16BE = (int)146L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_RGGB16BE = 146
     * }
     */
    public static int AV_PIX_FMT_BAYER_RGGB16BE() {
        return AV_PIX_FMT_BAYER_RGGB16BE;
    }
    private static final int AV_PIX_FMT_BAYER_GBRG16LE = (int)147L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GBRG16LE = 147
     * }
     */
    public static int AV_PIX_FMT_BAYER_GBRG16LE() {
        return AV_PIX_FMT_BAYER_GBRG16LE;
    }
    private static final int AV_PIX_FMT_BAYER_GBRG16BE = (int)148L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GBRG16BE = 148
     * }
     */
    public static int AV_PIX_FMT_BAYER_GBRG16BE() {
        return AV_PIX_FMT_BAYER_GBRG16BE;
    }
    private static final int AV_PIX_FMT_BAYER_GRBG16LE = (int)149L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GRBG16LE = 149
     * }
     */
    public static int AV_PIX_FMT_BAYER_GRBG16LE() {
        return AV_PIX_FMT_BAYER_GRBG16LE;
    }
    private static final int AV_PIX_FMT_BAYER_GRBG16BE = (int)150L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BAYER_GRBG16BE = 150
     * }
     */
    public static int AV_PIX_FMT_BAYER_GRBG16BE() {
        return AV_PIX_FMT_BAYER_GRBG16BE;
    }
    private static final int AV_PIX_FMT_YUV440P10LE = (int)151L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P10LE = 151
     * }
     */
    public static int AV_PIX_FMT_YUV440P10LE() {
        return AV_PIX_FMT_YUV440P10LE;
    }
    private static final int AV_PIX_FMT_YUV440P10BE = (int)152L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P10BE = 152
     * }
     */
    public static int AV_PIX_FMT_YUV440P10BE() {
        return AV_PIX_FMT_YUV440P10BE;
    }
    private static final int AV_PIX_FMT_YUV440P12LE = (int)153L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P12LE = 153
     * }
     */
    public static int AV_PIX_FMT_YUV440P12LE() {
        return AV_PIX_FMT_YUV440P12LE;
    }
    private static final int AV_PIX_FMT_YUV440P12BE = (int)154L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P12BE = 154
     * }
     */
    public static int AV_PIX_FMT_YUV440P12BE() {
        return AV_PIX_FMT_YUV440P12BE;
    }
    private static final int AV_PIX_FMT_AYUV64LE = (int)155L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_AYUV64LE = 155
     * }
     */
    public static int AV_PIX_FMT_AYUV64LE() {
        return AV_PIX_FMT_AYUV64LE;
    }
    private static final int AV_PIX_FMT_AYUV64BE = (int)156L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_AYUV64BE = 156
     * }
     */
    public static int AV_PIX_FMT_AYUV64BE() {
        return AV_PIX_FMT_AYUV64BE;
    }
    private static final int AV_PIX_FMT_VIDEOTOOLBOX = (int)157L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VIDEOTOOLBOX = 157
     * }
     */
    public static int AV_PIX_FMT_VIDEOTOOLBOX() {
        return AV_PIX_FMT_VIDEOTOOLBOX;
    }
    private static final int AV_PIX_FMT_P010LE = (int)158L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P010LE = 158
     * }
     */
    public static int AV_PIX_FMT_P010LE() {
        return AV_PIX_FMT_P010LE;
    }
    private static final int AV_PIX_FMT_P010BE = (int)159L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P010BE = 159
     * }
     */
    public static int AV_PIX_FMT_P010BE() {
        return AV_PIX_FMT_P010BE;
    }
    private static final int AV_PIX_FMT_GBRAP12BE = (int)160L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP12BE = 160
     * }
     */
    public static int AV_PIX_FMT_GBRAP12BE() {
        return AV_PIX_FMT_GBRAP12BE;
    }
    private static final int AV_PIX_FMT_GBRAP12LE = (int)161L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP12LE = 161
     * }
     */
    public static int AV_PIX_FMT_GBRAP12LE() {
        return AV_PIX_FMT_GBRAP12LE;
    }
    private static final int AV_PIX_FMT_GBRAP10BE = (int)162L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP10BE = 162
     * }
     */
    public static int AV_PIX_FMT_GBRAP10BE() {
        return AV_PIX_FMT_GBRAP10BE;
    }
    private static final int AV_PIX_FMT_GBRAP10LE = (int)163L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP10LE = 163
     * }
     */
    public static int AV_PIX_FMT_GBRAP10LE() {
        return AV_PIX_FMT_GBRAP10LE;
    }
    private static final int AV_PIX_FMT_MEDIACODEC = (int)164L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MEDIACODEC = 164
     * }
     */
    public static int AV_PIX_FMT_MEDIACODEC() {
        return AV_PIX_FMT_MEDIACODEC;
    }
    private static final int AV_PIX_FMT_GRAY12BE = (int)165L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY12BE = 165
     * }
     */
    public static int AV_PIX_FMT_GRAY12BE() {
        return AV_PIX_FMT_GRAY12BE;
    }
    private static final int AV_PIX_FMT_GRAY12LE = (int)166L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY12LE = 166
     * }
     */
    public static int AV_PIX_FMT_GRAY12LE() {
        return AV_PIX_FMT_GRAY12LE;
    }
    private static final int AV_PIX_FMT_GRAY10BE = (int)167L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY10BE = 167
     * }
     */
    public static int AV_PIX_FMT_GRAY10BE() {
        return AV_PIX_FMT_GRAY10BE;
    }
    private static final int AV_PIX_FMT_GRAY10LE = (int)168L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY10LE = 168
     * }
     */
    public static int AV_PIX_FMT_GRAY10LE() {
        return AV_PIX_FMT_GRAY10LE;
    }
    private static final int AV_PIX_FMT_P016LE = (int)169L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P016LE = 169
     * }
     */
    public static int AV_PIX_FMT_P016LE() {
        return AV_PIX_FMT_P016LE;
    }
    private static final int AV_PIX_FMT_P016BE = (int)170L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P016BE = 170
     * }
     */
    public static int AV_PIX_FMT_P016BE() {
        return AV_PIX_FMT_P016BE;
    }
    private static final int AV_PIX_FMT_D3D11 = (int)171L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_D3D11 = 171
     * }
     */
    public static int AV_PIX_FMT_D3D11() {
        return AV_PIX_FMT_D3D11;
    }
    private static final int AV_PIX_FMT_GRAY9BE = (int)172L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY9BE = 172
     * }
     */
    public static int AV_PIX_FMT_GRAY9BE() {
        return AV_PIX_FMT_GRAY9BE;
    }
    private static final int AV_PIX_FMT_GRAY9LE = (int)173L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY9LE = 173
     * }
     */
    public static int AV_PIX_FMT_GRAY9LE() {
        return AV_PIX_FMT_GRAY9LE;
    }
    private static final int AV_PIX_FMT_GBRPF32BE = (int)174L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRPF32BE = 174
     * }
     */
    public static int AV_PIX_FMT_GBRPF32BE() {
        return AV_PIX_FMT_GBRPF32BE;
    }
    private static final int AV_PIX_FMT_GBRPF32LE = (int)175L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRPF32LE = 175
     * }
     */
    public static int AV_PIX_FMT_GBRPF32LE() {
        return AV_PIX_FMT_GBRPF32LE;
    }
    private static final int AV_PIX_FMT_GBRAPF32BE = (int)176L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAPF32BE = 176
     * }
     */
    public static int AV_PIX_FMT_GBRAPF32BE() {
        return AV_PIX_FMT_GBRAPF32BE;
    }
    private static final int AV_PIX_FMT_GBRAPF32LE = (int)177L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAPF32LE = 177
     * }
     */
    public static int AV_PIX_FMT_GBRAPF32LE() {
        return AV_PIX_FMT_GBRAPF32LE;
    }
    private static final int AV_PIX_FMT_DRM_PRIME = (int)178L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_DRM_PRIME = 178
     * }
     */
    public static int AV_PIX_FMT_DRM_PRIME() {
        return AV_PIX_FMT_DRM_PRIME;
    }
    private static final int AV_PIX_FMT_OPENCL = (int)179L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_OPENCL = 179
     * }
     */
    public static int AV_PIX_FMT_OPENCL() {
        return AV_PIX_FMT_OPENCL;
    }
    private static final int AV_PIX_FMT_GRAY14BE = (int)180L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY14BE = 180
     * }
     */
    public static int AV_PIX_FMT_GRAY14BE() {
        return AV_PIX_FMT_GRAY14BE;
    }
    private static final int AV_PIX_FMT_GRAY14LE = (int)181L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY14LE = 181
     * }
     */
    public static int AV_PIX_FMT_GRAY14LE() {
        return AV_PIX_FMT_GRAY14LE;
    }
    private static final int AV_PIX_FMT_GRAYF32BE = (int)182L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAYF32BE = 182
     * }
     */
    public static int AV_PIX_FMT_GRAYF32BE() {
        return AV_PIX_FMT_GRAYF32BE;
    }
    private static final int AV_PIX_FMT_GRAYF32LE = (int)183L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAYF32LE = 183
     * }
     */
    public static int AV_PIX_FMT_GRAYF32LE() {
        return AV_PIX_FMT_GRAYF32LE;
    }
    private static final int AV_PIX_FMT_YUVA422P12BE = (int)184L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P12BE = 184
     * }
     */
    public static int AV_PIX_FMT_YUVA422P12BE() {
        return AV_PIX_FMT_YUVA422P12BE;
    }
    private static final int AV_PIX_FMT_YUVA422P12LE = (int)185L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P12LE = 185
     * }
     */
    public static int AV_PIX_FMT_YUVA422P12LE() {
        return AV_PIX_FMT_YUVA422P12LE;
    }
    private static final int AV_PIX_FMT_YUVA444P12BE = (int)186L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P12BE = 186
     * }
     */
    public static int AV_PIX_FMT_YUVA444P12BE() {
        return AV_PIX_FMT_YUVA444P12BE;
    }
    private static final int AV_PIX_FMT_YUVA444P12LE = (int)187L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P12LE = 187
     * }
     */
    public static int AV_PIX_FMT_YUVA444P12LE() {
        return AV_PIX_FMT_YUVA444P12LE;
    }
    private static final int AV_PIX_FMT_NV24 = (int)188L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV24 = 188
     * }
     */
    public static int AV_PIX_FMT_NV24() {
        return AV_PIX_FMT_NV24;
    }
    private static final int AV_PIX_FMT_NV42 = (int)189L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV42 = 189
     * }
     */
    public static int AV_PIX_FMT_NV42() {
        return AV_PIX_FMT_NV42;
    }
    private static final int AV_PIX_FMT_VULKAN = (int)190L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VULKAN = 190
     * }
     */
    public static int AV_PIX_FMT_VULKAN() {
        return AV_PIX_FMT_VULKAN;
    }
    private static final int AV_PIX_FMT_Y210BE = (int)191L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y210BE = 191
     * }
     */
    public static int AV_PIX_FMT_Y210BE() {
        return AV_PIX_FMT_Y210BE;
    }
    private static final int AV_PIX_FMT_Y210LE = (int)192L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y210LE = 192
     * }
     */
    public static int AV_PIX_FMT_Y210LE() {
        return AV_PIX_FMT_Y210LE;
    }
    private static final int AV_PIX_FMT_X2RGB10LE = (int)193L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2RGB10LE = 193
     * }
     */
    public static int AV_PIX_FMT_X2RGB10LE() {
        return AV_PIX_FMT_X2RGB10LE;
    }
    private static final int AV_PIX_FMT_X2RGB10BE = (int)194L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2RGB10BE = 194
     * }
     */
    public static int AV_PIX_FMT_X2RGB10BE() {
        return AV_PIX_FMT_X2RGB10BE;
    }
    private static final int AV_PIX_FMT_X2BGR10LE = (int)195L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2BGR10LE = 195
     * }
     */
    public static int AV_PIX_FMT_X2BGR10LE() {
        return AV_PIX_FMT_X2BGR10LE;
    }
    private static final int AV_PIX_FMT_X2BGR10BE = (int)196L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_X2BGR10BE = 196
     * }
     */
    public static int AV_PIX_FMT_X2BGR10BE() {
        return AV_PIX_FMT_X2BGR10BE;
    }
    private static final int AV_PIX_FMT_P210BE = (int)197L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P210BE = 197
     * }
     */
    public static int AV_PIX_FMT_P210BE() {
        return AV_PIX_FMT_P210BE;
    }
    private static final int AV_PIX_FMT_P210LE = (int)198L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P210LE = 198
     * }
     */
    public static int AV_PIX_FMT_P210LE() {
        return AV_PIX_FMT_P210LE;
    }
    private static final int AV_PIX_FMT_P410BE = (int)199L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P410BE = 199
     * }
     */
    public static int AV_PIX_FMT_P410BE() {
        return AV_PIX_FMT_P410BE;
    }
    private static final int AV_PIX_FMT_P410LE = (int)200L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P410LE = 200
     * }
     */
    public static int AV_PIX_FMT_P410LE() {
        return AV_PIX_FMT_P410LE;
    }
    private static final int AV_PIX_FMT_P216BE = (int)201L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P216BE = 201
     * }
     */
    public static int AV_PIX_FMT_P216BE() {
        return AV_PIX_FMT_P216BE;
    }
    private static final int AV_PIX_FMT_P216LE = (int)202L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P216LE = 202
     * }
     */
    public static int AV_PIX_FMT_P216LE() {
        return AV_PIX_FMT_P216LE;
    }
    private static final int AV_PIX_FMT_P416BE = (int)203L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P416BE = 203
     * }
     */
    public static int AV_PIX_FMT_P416BE() {
        return AV_PIX_FMT_P416BE;
    }
    private static final int AV_PIX_FMT_P416LE = (int)204L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P416LE = 204
     * }
     */
    public static int AV_PIX_FMT_P416LE() {
        return AV_PIX_FMT_P416LE;
    }
    private static final int AV_PIX_FMT_VUYA = (int)205L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VUYA = 205
     * }
     */
    public static int AV_PIX_FMT_VUYA() {
        return AV_PIX_FMT_VUYA;
    }
    private static final int AV_PIX_FMT_RGBAF16BE = (int)206L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF16BE = 206
     * }
     */
    public static int AV_PIX_FMT_RGBAF16BE() {
        return AV_PIX_FMT_RGBAF16BE;
    }
    private static final int AV_PIX_FMT_RGBAF16LE = (int)207L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF16LE = 207
     * }
     */
    public static int AV_PIX_FMT_RGBAF16LE() {
        return AV_PIX_FMT_RGBAF16LE;
    }
    private static final int AV_PIX_FMT_VUYX = (int)208L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VUYX = 208
     * }
     */
    public static int AV_PIX_FMT_VUYX() {
        return AV_PIX_FMT_VUYX;
    }
    private static final int AV_PIX_FMT_P012LE = (int)209L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P012LE = 209
     * }
     */
    public static int AV_PIX_FMT_P012LE() {
        return AV_PIX_FMT_P012LE;
    }
    private static final int AV_PIX_FMT_P012BE = (int)210L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P012BE = 210
     * }
     */
    public static int AV_PIX_FMT_P012BE() {
        return AV_PIX_FMT_P012BE;
    }
    private static final int AV_PIX_FMT_Y212BE = (int)211L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y212BE = 211
     * }
     */
    public static int AV_PIX_FMT_Y212BE() {
        return AV_PIX_FMT_Y212BE;
    }
    private static final int AV_PIX_FMT_Y212LE = (int)212L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y212LE = 212
     * }
     */
    public static int AV_PIX_FMT_Y212LE() {
        return AV_PIX_FMT_Y212LE;
    }
    private static final int AV_PIX_FMT_XV30BE = (int)213L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV30BE = 213
     * }
     */
    public static int AV_PIX_FMT_XV30BE() {
        return AV_PIX_FMT_XV30BE;
    }
    private static final int AV_PIX_FMT_XV30LE = (int)214L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV30LE = 214
     * }
     */
    public static int AV_PIX_FMT_XV30LE() {
        return AV_PIX_FMT_XV30LE;
    }
    private static final int AV_PIX_FMT_XV36BE = (int)215L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV36BE = 215
     * }
     */
    public static int AV_PIX_FMT_XV36BE() {
        return AV_PIX_FMT_XV36BE;
    }
    private static final int AV_PIX_FMT_XV36LE = (int)216L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV36LE = 216
     * }
     */
    public static int AV_PIX_FMT_XV36LE() {
        return AV_PIX_FMT_XV36LE;
    }
    private static final int AV_PIX_FMT_RGBF32BE = (int)217L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBF32BE = 217
     * }
     */
    public static int AV_PIX_FMT_RGBF32BE() {
        return AV_PIX_FMT_RGBF32BE;
    }
    private static final int AV_PIX_FMT_RGBF32LE = (int)218L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBF32LE = 218
     * }
     */
    public static int AV_PIX_FMT_RGBF32LE() {
        return AV_PIX_FMT_RGBF32LE;
    }
    private static final int AV_PIX_FMT_RGBAF32BE = (int)219L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF32BE = 219
     * }
     */
    public static int AV_PIX_FMT_RGBAF32BE() {
        return AV_PIX_FMT_RGBAF32BE;
    }
    private static final int AV_PIX_FMT_RGBAF32LE = (int)220L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBAF32LE = 220
     * }
     */
    public static int AV_PIX_FMT_RGBAF32LE() {
        return AV_PIX_FMT_RGBAF32LE;
    }
    private static final int AV_PIX_FMT_P212BE = (int)221L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P212BE = 221
     * }
     */
    public static int AV_PIX_FMT_P212BE() {
        return AV_PIX_FMT_P212BE;
    }
    private static final int AV_PIX_FMT_P212LE = (int)222L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P212LE = 222
     * }
     */
    public static int AV_PIX_FMT_P212LE() {
        return AV_PIX_FMT_P212LE;
    }
    private static final int AV_PIX_FMT_P412BE = (int)223L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P412BE = 223
     * }
     */
    public static int AV_PIX_FMT_P412BE() {
        return AV_PIX_FMT_P412BE;
    }
    private static final int AV_PIX_FMT_P412LE = (int)224L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_P412LE = 224
     * }
     */
    public static int AV_PIX_FMT_P412LE() {
        return AV_PIX_FMT_P412LE;
    }
    private static final int AV_PIX_FMT_GBRAP14BE = (int)225L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP14BE = 225
     * }
     */
    public static int AV_PIX_FMT_GBRAP14BE() {
        return AV_PIX_FMT_GBRAP14BE;
    }
    private static final int AV_PIX_FMT_GBRAP14LE = (int)226L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP14LE = 226
     * }
     */
    public static int AV_PIX_FMT_GBRAP14LE() {
        return AV_PIX_FMT_GBRAP14LE;
    }
    private static final int AV_PIX_FMT_D3D12 = (int)227L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_D3D12 = 227
     * }
     */
    public static int AV_PIX_FMT_D3D12() {
        return AV_PIX_FMT_D3D12;
    }
    private static final int AV_PIX_FMT_AYUV = (int)228L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_AYUV = 228
     * }
     */
    public static int AV_PIX_FMT_AYUV() {
        return AV_PIX_FMT_AYUV;
    }
    private static final int AV_PIX_FMT_UYVA = (int)229L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_UYVA = 229
     * }
     */
    public static int AV_PIX_FMT_UYVA() {
        return AV_PIX_FMT_UYVA;
    }
    private static final int AV_PIX_FMT_VYU444 = (int)230L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VYU444 = 230
     * }
     */
    public static int AV_PIX_FMT_VYU444() {
        return AV_PIX_FMT_VYU444;
    }
    private static final int AV_PIX_FMT_V30XBE = (int)231L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_V30XBE = 231
     * }
     */
    public static int AV_PIX_FMT_V30XBE() {
        return AV_PIX_FMT_V30XBE;
    }
    private static final int AV_PIX_FMT_V30XLE = (int)232L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_V30XLE = 232
     * }
     */
    public static int AV_PIX_FMT_V30XLE() {
        return AV_PIX_FMT_V30XLE;
    }
    private static final int AV_PIX_FMT_RGBF16BE = (int)233L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBF16BE = 233
     * }
     */
    public static int AV_PIX_FMT_RGBF16BE() {
        return AV_PIX_FMT_RGBF16BE;
    }
    private static final int AV_PIX_FMT_RGBF16LE = (int)234L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBF16LE = 234
     * }
     */
    public static int AV_PIX_FMT_RGBF16LE() {
        return AV_PIX_FMT_RGBF16LE;
    }
    private static final int AV_PIX_FMT_RGBA128BE = (int)235L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA128BE = 235
     * }
     */
    public static int AV_PIX_FMT_RGBA128BE() {
        return AV_PIX_FMT_RGBA128BE;
    }
    private static final int AV_PIX_FMT_RGBA128LE = (int)236L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA128LE = 236
     * }
     */
    public static int AV_PIX_FMT_RGBA128LE() {
        return AV_PIX_FMT_RGBA128LE;
    }
    private static final int AV_PIX_FMT_RGB96BE = (int)237L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB96BE = 237
     * }
     */
    public static int AV_PIX_FMT_RGB96BE() {
        return AV_PIX_FMT_RGB96BE;
    }
    private static final int AV_PIX_FMT_RGB96LE = (int)238L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB96LE = 238
     * }
     */
    public static int AV_PIX_FMT_RGB96LE() {
        return AV_PIX_FMT_RGB96LE;
    }
    private static final int AV_PIX_FMT_Y216BE = (int)239L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y216BE = 239
     * }
     */
    public static int AV_PIX_FMT_Y216BE() {
        return AV_PIX_FMT_Y216BE;
    }
    private static final int AV_PIX_FMT_Y216LE = (int)240L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y216LE = 240
     * }
     */
    public static int AV_PIX_FMT_Y216LE() {
        return AV_PIX_FMT_Y216LE;
    }
    private static final int AV_PIX_FMT_XV48BE = (int)241L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV48BE = 241
     * }
     */
    public static int AV_PIX_FMT_XV48BE() {
        return AV_PIX_FMT_XV48BE;
    }
    private static final int AV_PIX_FMT_XV48LE = (int)242L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XV48LE = 242
     * }
     */
    public static int AV_PIX_FMT_XV48LE() {
        return AV_PIX_FMT_XV48LE;
    }
    private static final int AV_PIX_FMT_GBRPF16BE = (int)243L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRPF16BE = 243
     * }
     */
    public static int AV_PIX_FMT_GBRPF16BE() {
        return AV_PIX_FMT_GBRPF16BE;
    }
    private static final int AV_PIX_FMT_GBRPF16LE = (int)244L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRPF16LE = 244
     * }
     */
    public static int AV_PIX_FMT_GBRPF16LE() {
        return AV_PIX_FMT_GBRPF16LE;
    }
    private static final int AV_PIX_FMT_GBRAPF16BE = (int)245L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAPF16BE = 245
     * }
     */
    public static int AV_PIX_FMT_GBRAPF16BE() {
        return AV_PIX_FMT_GBRAPF16BE;
    }
    private static final int AV_PIX_FMT_GBRAPF16LE = (int)246L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAPF16LE = 246
     * }
     */
    public static int AV_PIX_FMT_GBRAPF16LE() {
        return AV_PIX_FMT_GBRAPF16LE;
    }
    private static final int AV_PIX_FMT_GRAYF16BE = (int)247L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAYF16BE = 247
     * }
     */
    public static int AV_PIX_FMT_GRAYF16BE() {
        return AV_PIX_FMT_GRAYF16BE;
    }
    private static final int AV_PIX_FMT_GRAYF16LE = (int)248L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAYF16LE = 248
     * }
     */
    public static int AV_PIX_FMT_GRAYF16LE() {
        return AV_PIX_FMT_GRAYF16LE;
    }
    private static final int AV_PIX_FMT_AMF_SURFACE = (int)249L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_AMF_SURFACE = 249
     * }
     */
    public static int AV_PIX_FMT_AMF_SURFACE() {
        return AV_PIX_FMT_AMF_SURFACE;
    }
    private static final int AV_PIX_FMT_GRAY32BE = (int)250L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY32BE = 250
     * }
     */
    public static int AV_PIX_FMT_GRAY32BE() {
        return AV_PIX_FMT_GRAY32BE;
    }
    private static final int AV_PIX_FMT_GRAY32LE = (int)251L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY32LE = 251
     * }
     */
    public static int AV_PIX_FMT_GRAY32LE() {
        return AV_PIX_FMT_GRAY32LE;
    }
    private static final int AV_PIX_FMT_YAF32BE = (int)252L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YAF32BE = 252
     * }
     */
    public static int AV_PIX_FMT_YAF32BE() {
        return AV_PIX_FMT_YAF32BE;
    }
    private static final int AV_PIX_FMT_YAF32LE = (int)253L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YAF32LE = 253
     * }
     */
    public static int AV_PIX_FMT_YAF32LE() {
        return AV_PIX_FMT_YAF32LE;
    }
    private static final int AV_PIX_FMT_YAF16BE = (int)254L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YAF16BE = 254
     * }
     */
    public static int AV_PIX_FMT_YAF16BE() {
        return AV_PIX_FMT_YAF16BE;
    }
    private static final int AV_PIX_FMT_YAF16LE = (int)255L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YAF16LE = 255
     * }
     */
    public static int AV_PIX_FMT_YAF16LE() {
        return AV_PIX_FMT_YAF16LE;
    }
    private static final int AV_PIX_FMT_GBRAP32BE = (int)256L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP32BE = 256
     * }
     */
    public static int AV_PIX_FMT_GBRAP32BE() {
        return AV_PIX_FMT_GBRAP32BE;
    }
    private static final int AV_PIX_FMT_GBRAP32LE = (int)257L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP32LE = 257
     * }
     */
    public static int AV_PIX_FMT_GBRAP32LE() {
        return AV_PIX_FMT_GBRAP32LE;
    }
    private static final int AV_PIX_FMT_YUV444P10MSBBE = (int)258L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P10MSBBE = 258
     * }
     */
    public static int AV_PIX_FMT_YUV444P10MSBBE() {
        return AV_PIX_FMT_YUV444P10MSBBE;
    }
    private static final int AV_PIX_FMT_YUV444P10MSBLE = (int)259L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P10MSBLE = 259
     * }
     */
    public static int AV_PIX_FMT_YUV444P10MSBLE() {
        return AV_PIX_FMT_YUV444P10MSBLE;
    }
    private static final int AV_PIX_FMT_YUV444P12MSBBE = (int)260L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P12MSBBE = 260
     * }
     */
    public static int AV_PIX_FMT_YUV444P12MSBBE() {
        return AV_PIX_FMT_YUV444P12MSBBE;
    }
    private static final int AV_PIX_FMT_YUV444P12MSBLE = (int)261L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P12MSBLE = 261
     * }
     */
    public static int AV_PIX_FMT_YUV444P12MSBLE() {
        return AV_PIX_FMT_YUV444P12MSBLE;
    }
    private static final int AV_PIX_FMT_GBRP10MSBBE = (int)262L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP10MSBBE = 262
     * }
     */
    public static int AV_PIX_FMT_GBRP10MSBBE() {
        return AV_PIX_FMT_GBRP10MSBBE;
    }
    private static final int AV_PIX_FMT_GBRP10MSBLE = (int)263L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP10MSBLE = 263
     * }
     */
    public static int AV_PIX_FMT_GBRP10MSBLE() {
        return AV_PIX_FMT_GBRP10MSBLE;
    }
    private static final int AV_PIX_FMT_GBRP12MSBBE = (int)264L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP12MSBBE = 264
     * }
     */
    public static int AV_PIX_FMT_GBRP12MSBBE() {
        return AV_PIX_FMT_GBRP12MSBBE;
    }
    private static final int AV_PIX_FMT_GBRP12MSBLE = (int)265L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP12MSBLE = 265
     * }
     */
    public static int AV_PIX_FMT_GBRP12MSBLE() {
        return AV_PIX_FMT_GBRP12MSBLE;
    }
    private static final int AV_PIX_FMT_OHCODEC = (int)266L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_OHCODEC = 266
     * }
     */
    public static int AV_PIX_FMT_OHCODEC() {
        return AV_PIX_FMT_OHCODEC;
    }
    private static final int AV_PIX_FMT_NB = (int)267L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NB = 267
     * }
     */
    public static int AV_PIX_FMT_NB() {
        return AV_PIX_FMT_NB;
    }
    private static final int AVCOL_PRI_RESERVED0 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_RESERVED0 = 0
     * }
     */
    public static int AVCOL_PRI_RESERVED0() {
        return AVCOL_PRI_RESERVED0;
    }
    private static final int AVCOL_PRI_BT709 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_BT709 = 1
     * }
     */
    public static int AVCOL_PRI_BT709() {
        return AVCOL_PRI_BT709;
    }
    private static final int AVCOL_PRI_UNSPECIFIED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_UNSPECIFIED = 2
     * }
     */
    public static int AVCOL_PRI_UNSPECIFIED() {
        return AVCOL_PRI_UNSPECIFIED;
    }
    private static final int AVCOL_PRI_RESERVED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_RESERVED = 3
     * }
     */
    public static int AVCOL_PRI_RESERVED() {
        return AVCOL_PRI_RESERVED;
    }
    private static final int AVCOL_PRI_BT470M = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_BT470M = 4
     * }
     */
    public static int AVCOL_PRI_BT470M() {
        return AVCOL_PRI_BT470M;
    }
    private static final int AVCOL_PRI_BT470BG = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_BT470BG = 5
     * }
     */
    public static int AVCOL_PRI_BT470BG() {
        return AVCOL_PRI_BT470BG;
    }
    private static final int AVCOL_PRI_SMPTE170M = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTE170M = 6
     * }
     */
    public static int AVCOL_PRI_SMPTE170M() {
        return AVCOL_PRI_SMPTE170M;
    }
    private static final int AVCOL_PRI_SMPTE240M = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTE240M = 7
     * }
     */
    public static int AVCOL_PRI_SMPTE240M() {
        return AVCOL_PRI_SMPTE240M;
    }
    private static final int AVCOL_PRI_FILM = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_FILM = 8
     * }
     */
    public static int AVCOL_PRI_FILM() {
        return AVCOL_PRI_FILM;
    }
    private static final int AVCOL_PRI_BT2020 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_BT2020 = 9
     * }
     */
    public static int AVCOL_PRI_BT2020() {
        return AVCOL_PRI_BT2020;
    }
    private static final int AVCOL_PRI_SMPTE428 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTE428 = 10
     * }
     */
    public static int AVCOL_PRI_SMPTE428() {
        return AVCOL_PRI_SMPTE428;
    }
    private static final int AVCOL_PRI_SMPTEST428_1 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTEST428_1 = 10
     * }
     */
    public static int AVCOL_PRI_SMPTEST428_1() {
        return AVCOL_PRI_SMPTEST428_1;
    }
    private static final int AVCOL_PRI_SMPTE431 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTE431 = 11
     * }
     */
    public static int AVCOL_PRI_SMPTE431() {
        return AVCOL_PRI_SMPTE431;
    }
    private static final int AVCOL_PRI_SMPTE432 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_SMPTE432 = 12
     * }
     */
    public static int AVCOL_PRI_SMPTE432() {
        return AVCOL_PRI_SMPTE432;
    }
    private static final int AVCOL_PRI_EBU3213 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_EBU3213 = 22
     * }
     */
    public static int AVCOL_PRI_EBU3213() {
        return AVCOL_PRI_EBU3213;
    }
    private static final int AVCOL_PRI_JEDEC_P22 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_JEDEC_P22 = 22
     * }
     */
    public static int AVCOL_PRI_JEDEC_P22() {
        return AVCOL_PRI_JEDEC_P22;
    }
    private static final int AVCOL_PRI_NB = (int)23L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_NB = 23
     * }
     */
    public static int AVCOL_PRI_NB() {
        return AVCOL_PRI_NB;
    }
    private static final int AVCOL_PRI_EXT_BASE = (int)256L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_EXT_BASE = 256
     * }
     */
    public static int AVCOL_PRI_EXT_BASE() {
        return AVCOL_PRI_EXT_BASE;
    }
    private static final int AVCOL_PRI_V_GAMUT = (int)256L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_V_GAMUT = 256
     * }
     */
    public static int AVCOL_PRI_V_GAMUT() {
        return AVCOL_PRI_V_GAMUT;
    }
    private static final int AVCOL_PRI_EXT_NB = (int)257L;
    /**
     * {@snippet lang=c :
     * enum AVColorPrimaries.AVCOL_PRI_EXT_NB = 257
     * }
     */
    public static int AVCOL_PRI_EXT_NB() {
        return AVCOL_PRI_EXT_NB;
    }
    private static final int AVCOL_TRC_RESERVED0 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_RESERVED0 = 0
     * }
     */
    public static int AVCOL_TRC_RESERVED0() {
        return AVCOL_TRC_RESERVED0;
    }
    private static final int AVCOL_TRC_BT709 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_BT709 = 1
     * }
     */
    public static int AVCOL_TRC_BT709() {
        return AVCOL_TRC_BT709;
    }
    private static final int AVCOL_TRC_UNSPECIFIED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED = 2
     * }
     */
    public static int AVCOL_TRC_UNSPECIFIED() {
        return AVCOL_TRC_UNSPECIFIED;
    }
    private static final int AVCOL_TRC_RESERVED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_RESERVED = 3
     * }
     */
    public static int AVCOL_TRC_RESERVED() {
        return AVCOL_TRC_RESERVED;
    }
    private static final int AVCOL_TRC_GAMMA22 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_GAMMA22 = 4
     * }
     */
    public static int AVCOL_TRC_GAMMA22() {
        return AVCOL_TRC_GAMMA22;
    }
    private static final int AVCOL_TRC_GAMMA28 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_GAMMA28 = 5
     * }
     */
    public static int AVCOL_TRC_GAMMA28() {
        return AVCOL_TRC_GAMMA28;
    }
    private static final int AVCOL_TRC_SMPTE170M = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTE170M = 6
     * }
     */
    public static int AVCOL_TRC_SMPTE170M() {
        return AVCOL_TRC_SMPTE170M;
    }
    private static final int AVCOL_TRC_SMPTE240M = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTE240M = 7
     * }
     */
    public static int AVCOL_TRC_SMPTE240M() {
        return AVCOL_TRC_SMPTE240M;
    }
    private static final int AVCOL_TRC_LINEAR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_LINEAR = 8
     * }
     */
    public static int AVCOL_TRC_LINEAR() {
        return AVCOL_TRC_LINEAR;
    }
    private static final int AVCOL_TRC_LOG = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_LOG = 9
     * }
     */
    public static int AVCOL_TRC_LOG() {
        return AVCOL_TRC_LOG;
    }
    private static final int AVCOL_TRC_LOG_SQRT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_LOG_SQRT = 10
     * }
     */
    public static int AVCOL_TRC_LOG_SQRT() {
        return AVCOL_TRC_LOG_SQRT;
    }
    private static final int AVCOL_TRC_IEC61966_2_4 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4 = 11
     * }
     */
    public static int AVCOL_TRC_IEC61966_2_4() {
        return AVCOL_TRC_IEC61966_2_4;
    }
    private static final int AVCOL_TRC_BT1361_ECG = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG = 12
     * }
     */
    public static int AVCOL_TRC_BT1361_ECG() {
        return AVCOL_TRC_BT1361_ECG;
    }
    private static final int AVCOL_TRC_IEC61966_2_1 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_1 = 13
     * }
     */
    public static int AVCOL_TRC_IEC61966_2_1() {
        return AVCOL_TRC_IEC61966_2_1;
    }
    private static final int AVCOL_TRC_BT2020_10 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_BT2020_10 = 14
     * }
     */
    public static int AVCOL_TRC_BT2020_10() {
        return AVCOL_TRC_BT2020_10;
    }
    private static final int AVCOL_TRC_BT2020_12 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_BT2020_12 = 15
     * }
     */
    public static int AVCOL_TRC_BT2020_12() {
        return AVCOL_TRC_BT2020_12;
    }
    private static final int AVCOL_TRC_SMPTE2084 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084 = 16
     * }
     */
    public static int AVCOL_TRC_SMPTE2084() {
        return AVCOL_TRC_SMPTE2084;
    }
    private static final int AVCOL_TRC_SMPTEST2084 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTEST2084 = 16
     * }
     */
    public static int AVCOL_TRC_SMPTEST2084() {
        return AVCOL_TRC_SMPTEST2084;
    }
    private static final int AVCOL_TRC_SMPTE428 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTE428 = 17
     * }
     */
    public static int AVCOL_TRC_SMPTE428() {
        return AVCOL_TRC_SMPTE428;
    }
    private static final int AVCOL_TRC_SMPTEST428_1 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_SMPTEST428_1 = 17
     * }
     */
    public static int AVCOL_TRC_SMPTEST428_1() {
        return AVCOL_TRC_SMPTEST428_1;
    }
    private static final int AVCOL_TRC_ARIB_STD_B67 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67 = 18
     * }
     */
    public static int AVCOL_TRC_ARIB_STD_B67() {
        return AVCOL_TRC_ARIB_STD_B67;
    }
    private static final int AVCOL_TRC_NB = (int)19L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_NB = 19
     * }
     */
    public static int AVCOL_TRC_NB() {
        return AVCOL_TRC_NB;
    }
    private static final int AVCOL_TRC_EXT_BASE = (int)256L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_EXT_BASE = 256
     * }
     */
    public static int AVCOL_TRC_EXT_BASE() {
        return AVCOL_TRC_EXT_BASE;
    }
    private static final int AVCOL_TRC_V_LOG = (int)256L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_V_LOG = 256
     * }
     */
    public static int AVCOL_TRC_V_LOG() {
        return AVCOL_TRC_V_LOG;
    }
    private static final int AVCOL_TRC_EXT_NB = (int)257L;
    /**
     * {@snippet lang=c :
     * enum AVColorTransferCharacteristic.AVCOL_TRC_EXT_NB = 257
     * }
     */
    public static int AVCOL_TRC_EXT_NB() {
        return AVCOL_TRC_EXT_NB;
    }
    private static final int AVCOL_SPC_RGB = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_RGB = 0
     * }
     */
    public static int AVCOL_SPC_RGB() {
        return AVCOL_SPC_RGB;
    }
    private static final int AVCOL_SPC_BT709 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_BT709 = 1
     * }
     */
    public static int AVCOL_SPC_BT709() {
        return AVCOL_SPC_BT709;
    }
    private static final int AVCOL_SPC_UNSPECIFIED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_UNSPECIFIED = 2
     * }
     */
    public static int AVCOL_SPC_UNSPECIFIED() {
        return AVCOL_SPC_UNSPECIFIED;
    }
    private static final int AVCOL_SPC_RESERVED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_RESERVED = 3
     * }
     */
    public static int AVCOL_SPC_RESERVED() {
        return AVCOL_SPC_RESERVED;
    }
    private static final int AVCOL_SPC_FCC = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_FCC = 4
     * }
     */
    public static int AVCOL_SPC_FCC() {
        return AVCOL_SPC_FCC;
    }
    private static final int AVCOL_SPC_BT470BG = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_BT470BG = 5
     * }
     */
    public static int AVCOL_SPC_BT470BG() {
        return AVCOL_SPC_BT470BG;
    }
    private static final int AVCOL_SPC_SMPTE170M = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_SMPTE170M = 6
     * }
     */
    public static int AVCOL_SPC_SMPTE170M() {
        return AVCOL_SPC_SMPTE170M;
    }
    private static final int AVCOL_SPC_SMPTE240M = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_SMPTE240M = 7
     * }
     */
    public static int AVCOL_SPC_SMPTE240M() {
        return AVCOL_SPC_SMPTE240M;
    }
    private static final int AVCOL_SPC_YCGCO = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_YCGCO = 8
     * }
     */
    public static int AVCOL_SPC_YCGCO() {
        return AVCOL_SPC_YCGCO;
    }
    private static final int AVCOL_SPC_YCOCG = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_YCOCG = 8
     * }
     */
    public static int AVCOL_SPC_YCOCG() {
        return AVCOL_SPC_YCOCG;
    }
    private static final int AVCOL_SPC_BT2020_NCL = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_BT2020_NCL = 9
     * }
     */
    public static int AVCOL_SPC_BT2020_NCL() {
        return AVCOL_SPC_BT2020_NCL;
    }
    private static final int AVCOL_SPC_BT2020_CL = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_BT2020_CL = 10
     * }
     */
    public static int AVCOL_SPC_BT2020_CL() {
        return AVCOL_SPC_BT2020_CL;
    }
    private static final int AVCOL_SPC_SMPTE2085 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_SMPTE2085 = 11
     * }
     */
    public static int AVCOL_SPC_SMPTE2085() {
        return AVCOL_SPC_SMPTE2085;
    }
    private static final int AVCOL_SPC_CHROMA_DERIVED_NCL = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_CHROMA_DERIVED_NCL = 12
     * }
     */
    public static int AVCOL_SPC_CHROMA_DERIVED_NCL() {
        return AVCOL_SPC_CHROMA_DERIVED_NCL;
    }
    private static final int AVCOL_SPC_CHROMA_DERIVED_CL = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_CHROMA_DERIVED_CL = 13
     * }
     */
    public static int AVCOL_SPC_CHROMA_DERIVED_CL() {
        return AVCOL_SPC_CHROMA_DERIVED_CL;
    }
    private static final int AVCOL_SPC_ICTCP = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_ICTCP = 14
     * }
     */
    public static int AVCOL_SPC_ICTCP() {
        return AVCOL_SPC_ICTCP;
    }
    private static final int AVCOL_SPC_IPT_C2 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_IPT_C2 = 15
     * }
     */
    public static int AVCOL_SPC_IPT_C2() {
        return AVCOL_SPC_IPT_C2;
    }
    private static final int AVCOL_SPC_YCGCO_RE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_YCGCO_RE = 16
     * }
     */
    public static int AVCOL_SPC_YCGCO_RE() {
        return AVCOL_SPC_YCGCO_RE;
    }
    private static final int AVCOL_SPC_YCGCO_RO = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_YCGCO_RO = 17
     * }
     */
    public static int AVCOL_SPC_YCGCO_RO() {
        return AVCOL_SPC_YCGCO_RO;
    }
    private static final int AVCOL_SPC_NB = (int)18L;
    /**
     * {@snippet lang=c :
     * enum AVColorSpace.AVCOL_SPC_NB = 18
     * }
     */
    public static int AVCOL_SPC_NB() {
        return AVCOL_SPC_NB;
    }
    private static final int AVCOL_RANGE_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVColorRange.AVCOL_RANGE_UNSPECIFIED = 0
     * }
     */
    public static int AVCOL_RANGE_UNSPECIFIED() {
        return AVCOL_RANGE_UNSPECIFIED;
    }
    private static final int AVCOL_RANGE_MPEG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVColorRange.AVCOL_RANGE_MPEG = 1
     * }
     */
    public static int AVCOL_RANGE_MPEG() {
        return AVCOL_RANGE_MPEG;
    }
    private static final int AVCOL_RANGE_JPEG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVColorRange.AVCOL_RANGE_JPEG = 2
     * }
     */
    public static int AVCOL_RANGE_JPEG() {
        return AVCOL_RANGE_JPEG;
    }
    private static final int AVCOL_RANGE_NB = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVColorRange.AVCOL_RANGE_NB = 3
     * }
     */
    public static int AVCOL_RANGE_NB() {
        return AVCOL_RANGE_NB;
    }
    private static final int AVCHROMA_LOC_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED = 0
     * }
     */
    public static int AVCHROMA_LOC_UNSPECIFIED() {
        return AVCHROMA_LOC_UNSPECIFIED;
    }
    private static final int AVCHROMA_LOC_LEFT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_LEFT = 1
     * }
     */
    public static int AVCHROMA_LOC_LEFT() {
        return AVCHROMA_LOC_LEFT;
    }
    private static final int AVCHROMA_LOC_CENTER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_CENTER = 2
     * }
     */
    public static int AVCHROMA_LOC_CENTER() {
        return AVCHROMA_LOC_CENTER;
    }
    private static final int AVCHROMA_LOC_TOPLEFT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_TOPLEFT = 3
     * }
     */
    public static int AVCHROMA_LOC_TOPLEFT() {
        return AVCHROMA_LOC_TOPLEFT;
    }
    private static final int AVCHROMA_LOC_TOP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_TOP = 4
     * }
     */
    public static int AVCHROMA_LOC_TOP() {
        return AVCHROMA_LOC_TOP;
    }
    private static final int AVCHROMA_LOC_BOTTOMLEFT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_BOTTOMLEFT = 5
     * }
     */
    public static int AVCHROMA_LOC_BOTTOMLEFT() {
        return AVCHROMA_LOC_BOTTOMLEFT;
    }
    private static final int AVCHROMA_LOC_BOTTOM = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_BOTTOM = 6
     * }
     */
    public static int AVCHROMA_LOC_BOTTOM() {
        return AVCHROMA_LOC_BOTTOM;
    }
    private static final int AVCHROMA_LOC_NB = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVChromaLocation.AVCHROMA_LOC_NB = 7
     * }
     */
    public static int AVCHROMA_LOC_NB() {
        return AVCHROMA_LOC_NB;
    }
    private static final int AVALPHA_MODE_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVAlphaMode.AVALPHA_MODE_UNSPECIFIED = 0
     * }
     */
    public static int AVALPHA_MODE_UNSPECIFIED() {
        return AVALPHA_MODE_UNSPECIFIED;
    }
    private static final int AVALPHA_MODE_PREMULTIPLIED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVAlphaMode.AVALPHA_MODE_PREMULTIPLIED = 1
     * }
     */
    public static int AVALPHA_MODE_PREMULTIPLIED() {
        return AVALPHA_MODE_PREMULTIPLIED;
    }
    private static final int AVALPHA_MODE_STRAIGHT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVAlphaMode.AVALPHA_MODE_STRAIGHT = 2
     * }
     */
    public static int AVALPHA_MODE_STRAIGHT() {
        return AVALPHA_MODE_STRAIGHT;
    }
    private static final int AVALPHA_MODE_NB = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVAlphaMode.AVALPHA_MODE_NB = 3
     * }
     */
    public static int AVALPHA_MODE_NB() {
        return AVALPHA_MODE_NB;
    }

    private static class av_int_list_length_for_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_int_list_length_for_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int av_int_list_length_for_size(unsigned int elsize, const void *list, uint64_t term)
     * }
     */
    public static FunctionDescriptor av_int_list_length_for_size$descriptor() {
        return av_int_list_length_for_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int av_int_list_length_for_size(unsigned int elsize, const void *list, uint64_t term)
     * }
     */
    public static MethodHandle av_int_list_length_for_size$handle() {
        return av_int_list_length_for_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int av_int_list_length_for_size(unsigned int elsize, const void *list, uint64_t term)
     * }
     */
    public static MemorySegment av_int_list_length_for_size$address() {
        return av_int_list_length_for_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int av_int_list_length_for_size(unsigned int elsize, const void *list, uint64_t term)
     * }
     */
    public static int av_int_list_length_for_size(int elsize, MemorySegment list, long term) {
        var mh$ = av_int_list_length_for_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_int_list_length_for_size", elsize, list, term);
            }
            return (int)mh$.invokeExact(elsize, list, term);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_time_base_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout()    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_time_base_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_get_time_base_q()
     * }
     */
    public static FunctionDescriptor av_get_time_base_q$descriptor() {
        return av_get_time_base_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_get_time_base_q()
     * }
     */
    public static MethodHandle av_get_time_base_q$handle() {
        return av_get_time_base_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_get_time_base_q()
     * }
     */
    public static MemorySegment av_get_time_base_q$address() {
        return av_get_time_base_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_get_time_base_q()
     * }
     */
    public static MemorySegment av_get_time_base_q(SegmentAllocator allocator) {
        var mh$ = av_get_time_base_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_time_base_q", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fourcc_make_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_fourcc_make_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_fourcc_make_string(char *buf, uint32_t fourcc)
     * }
     */
    public static FunctionDescriptor av_fourcc_make_string$descriptor() {
        return av_fourcc_make_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_fourcc_make_string(char *buf, uint32_t fourcc)
     * }
     */
    public static MethodHandle av_fourcc_make_string$handle() {
        return av_fourcc_make_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *av_fourcc_make_string(char *buf, uint32_t fourcc)
     * }
     */
    public static MemorySegment av_fourcc_make_string$address() {
        return av_fourcc_make_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *av_fourcc_make_string(char *buf, uint32_t fourcc)
     * }
     */
    public static MemorySegment av_fourcc_make_string(MemorySegment buf, int fourcc) {
        var mh$ = av_fourcc_make_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fourcc_make_string", buf, fourcc);
            }
            return (MemorySegment)mh$.invokeExact(buf, fourcc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_alloc(size_t size)
     * }
     */
    public static FunctionDescriptor av_buffer_alloc$descriptor() {
        return av_buffer_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_alloc(size_t size)
     * }
     */
    public static MethodHandle av_buffer_alloc$handle() {
        return av_buffer_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_alloc(size_t size)
     * }
     */
    public static MemorySegment av_buffer_alloc$address() {
        return av_buffer_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_alloc(size_t size)
     * }
     */
    public static MemorySegment av_buffer_alloc(long size) {
        var mh$ = av_buffer_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_alloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_allocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_allocz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_allocz(size_t size)
     * }
     */
    public static FunctionDescriptor av_buffer_allocz$descriptor() {
        return av_buffer_allocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_allocz(size_t size)
     * }
     */
    public static MethodHandle av_buffer_allocz$handle() {
        return av_buffer_allocz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_allocz(size_t size)
     * }
     */
    public static MemorySegment av_buffer_allocz$address() {
        return av_buffer_allocz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_allocz(size_t size)
     * }
     */
    public static MemorySegment av_buffer_allocz(long size) {
        var mh$ = av_buffer_allocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_allocz", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_create(uint8_t *data, size_t size, void (*free)(void *, uint8_t *), void *opaque, int flags)
     * }
     */
    public static FunctionDescriptor av_buffer_create$descriptor() {
        return av_buffer_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_create(uint8_t *data, size_t size, void (*free)(void *, uint8_t *), void *opaque, int flags)
     * }
     */
    public static MethodHandle av_buffer_create$handle() {
        return av_buffer_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_create(uint8_t *data, size_t size, void (*free)(void *, uint8_t *), void *opaque, int flags)
     * }
     */
    public static MemorySegment av_buffer_create$address() {
        return av_buffer_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_create(uint8_t *data, size_t size, void (*free)(void *, uint8_t *), void *opaque, int flags)
     * }
     */
    public static MemorySegment av_buffer_create(MemorySegment data, long size, MemorySegment free, MemorySegment opaque, int flags) {
        var mh$ = av_buffer_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_create", data, size, free, opaque, flags);
            }
            return (MemorySegment)mh$.invokeExact(data, size, free, opaque, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_default_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_default_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_buffer_default_free(void *opaque, uint8_t *data)
     * }
     */
    public static FunctionDescriptor av_buffer_default_free$descriptor() {
        return av_buffer_default_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_buffer_default_free(void *opaque, uint8_t *data)
     * }
     */
    public static MethodHandle av_buffer_default_free$handle() {
        return av_buffer_default_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_buffer_default_free(void *opaque, uint8_t *data)
     * }
     */
    public static MemorySegment av_buffer_default_free$address() {
        return av_buffer_default_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_buffer_default_free(void *opaque, uint8_t *data)
     * }
     */
    public static void av_buffer_default_free(MemorySegment opaque, MemorySegment data) {
        var mh$ = av_buffer_default_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_default_free", opaque, data);
            }
            mh$.invokeExact(opaque, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_ref(const AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_buffer_ref$descriptor() {
        return av_buffer_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_ref(const AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_buffer_ref$handle() {
        return av_buffer_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_ref(const AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_buffer_ref$address() {
        return av_buffer_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_ref(const AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_buffer_ref(MemorySegment buf) {
        var mh$ = av_buffer_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_ref", buf);
            }
            return (MemorySegment)mh$.invokeExact(buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_buffer_unref(AVBufferRef **buf)
     * }
     */
    public static FunctionDescriptor av_buffer_unref$descriptor() {
        return av_buffer_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_buffer_unref(AVBufferRef **buf)
     * }
     */
    public static MethodHandle av_buffer_unref$handle() {
        return av_buffer_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_buffer_unref(AVBufferRef **buf)
     * }
     */
    public static MemorySegment av_buffer_unref$address() {
        return av_buffer_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_buffer_unref(AVBufferRef **buf)
     * }
     */
    public static void av_buffer_unref(MemorySegment buf) {
        var mh$ = av_buffer_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_unref", buf);
            }
            mh$.invokeExact(buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_is_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_is_writable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffer_is_writable(const AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_buffer_is_writable$descriptor() {
        return av_buffer_is_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffer_is_writable(const AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_buffer_is_writable$handle() {
        return av_buffer_is_writable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffer_is_writable(const AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_buffer_is_writable$address() {
        return av_buffer_is_writable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffer_is_writable(const AVBufferRef *buf)
     * }
     */
    public static int av_buffer_is_writable(MemorySegment buf) {
        var mh$ = av_buffer_is_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_is_writable", buf);
            }
            return (int)mh$.invokeExact(buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_get_opaque {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_get_opaque");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_buffer_get_opaque(const AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_buffer_get_opaque$descriptor() {
        return av_buffer_get_opaque.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_buffer_get_opaque(const AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_buffer_get_opaque$handle() {
        return av_buffer_get_opaque.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_buffer_get_opaque(const AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_buffer_get_opaque$address() {
        return av_buffer_get_opaque.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_buffer_get_opaque(const AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_buffer_get_opaque(MemorySegment buf) {
        var mh$ = av_buffer_get_opaque.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_get_opaque", buf);
            }
            return (MemorySegment)mh$.invokeExact(buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_get_ref_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_get_ref_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffer_get_ref_count(const AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_buffer_get_ref_count$descriptor() {
        return av_buffer_get_ref_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffer_get_ref_count(const AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_buffer_get_ref_count$handle() {
        return av_buffer_get_ref_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffer_get_ref_count(const AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_buffer_get_ref_count$address() {
        return av_buffer_get_ref_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffer_get_ref_count(const AVBufferRef *buf)
     * }
     */
    public static int av_buffer_get_ref_count(MemorySegment buf) {
        var mh$ = av_buffer_get_ref_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_get_ref_count", buf);
            }
            return (int)mh$.invokeExact(buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_make_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_make_writable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffer_make_writable(AVBufferRef **buf)
     * }
     */
    public static FunctionDescriptor av_buffer_make_writable$descriptor() {
        return av_buffer_make_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffer_make_writable(AVBufferRef **buf)
     * }
     */
    public static MethodHandle av_buffer_make_writable$handle() {
        return av_buffer_make_writable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffer_make_writable(AVBufferRef **buf)
     * }
     */
    public static MemorySegment av_buffer_make_writable$address() {
        return av_buffer_make_writable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffer_make_writable(AVBufferRef **buf)
     * }
     */
    public static int av_buffer_make_writable(MemorySegment buf) {
        var mh$ = av_buffer_make_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_make_writable", buf);
            }
            return (int)mh$.invokeExact(buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffer_realloc(AVBufferRef **buf, size_t size)
     * }
     */
    public static FunctionDescriptor av_buffer_realloc$descriptor() {
        return av_buffer_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffer_realloc(AVBufferRef **buf, size_t size)
     * }
     */
    public static MethodHandle av_buffer_realloc$handle() {
        return av_buffer_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffer_realloc(AVBufferRef **buf, size_t size)
     * }
     */
    public static MemorySegment av_buffer_realloc$address() {
        return av_buffer_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffer_realloc(AVBufferRef **buf, size_t size)
     * }
     */
    public static int av_buffer_realloc(MemorySegment buf, long size) {
        var mh$ = av_buffer_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_realloc", buf, size);
            }
            return (int)mh$.invokeExact(buf, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffer_replace(AVBufferRef **dst, const AVBufferRef *src)
     * }
     */
    public static FunctionDescriptor av_buffer_replace$descriptor() {
        return av_buffer_replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffer_replace(AVBufferRef **dst, const AVBufferRef *src)
     * }
     */
    public static MethodHandle av_buffer_replace$handle() {
        return av_buffer_replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffer_replace(AVBufferRef **dst, const AVBufferRef *src)
     * }
     */
    public static MemorySegment av_buffer_replace$address() {
        return av_buffer_replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffer_replace(AVBufferRef **dst, const AVBufferRef *src)
     * }
     */
    public static int av_buffer_replace(MemorySegment dst, MemorySegment src) {
        var mh$ = av_buffer_replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_replace", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_pool_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_pool_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init(size_t size, AVBufferRef *(*alloc)(size_t))
     * }
     */
    public static FunctionDescriptor av_buffer_pool_init$descriptor() {
        return av_buffer_pool_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init(size_t size, AVBufferRef *(*alloc)(size_t))
     * }
     */
    public static MethodHandle av_buffer_pool_init$handle() {
        return av_buffer_pool_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init(size_t size, AVBufferRef *(*alloc)(size_t))
     * }
     */
    public static MemorySegment av_buffer_pool_init$address() {
        return av_buffer_pool_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init(size_t size, AVBufferRef *(*alloc)(size_t))
     * }
     */
    public static MemorySegment av_buffer_pool_init(long size, MemorySegment alloc) {
        var mh$ = av_buffer_pool_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_pool_init", size, alloc);
            }
            return (MemorySegment)mh$.invokeExact(size, alloc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_pool_init2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_pool_init2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque, AVBufferRef *(*alloc)(void *, size_t), void (*pool_free)(void *))
     * }
     */
    public static FunctionDescriptor av_buffer_pool_init2$descriptor() {
        return av_buffer_pool_init2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque, AVBufferRef *(*alloc)(void *, size_t), void (*pool_free)(void *))
     * }
     */
    public static MethodHandle av_buffer_pool_init2$handle() {
        return av_buffer_pool_init2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque, AVBufferRef *(*alloc)(void *, size_t), void (*pool_free)(void *))
     * }
     */
    public static MemorySegment av_buffer_pool_init2$address() {
        return av_buffer_pool_init2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque, AVBufferRef *(*alloc)(void *, size_t), void (*pool_free)(void *))
     * }
     */
    public static MemorySegment av_buffer_pool_init2(long size, MemorySegment opaque, MemorySegment alloc, MemorySegment pool_free) {
        var mh$ = av_buffer_pool_init2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_pool_init2", size, opaque, alloc, pool_free);
            }
            return (MemorySegment)mh$.invokeExact(size, opaque, alloc, pool_free);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_pool_uninit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_pool_uninit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_buffer_pool_uninit(AVBufferPool **pool)
     * }
     */
    public static FunctionDescriptor av_buffer_pool_uninit$descriptor() {
        return av_buffer_pool_uninit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_buffer_pool_uninit(AVBufferPool **pool)
     * }
     */
    public static MethodHandle av_buffer_pool_uninit$handle() {
        return av_buffer_pool_uninit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_buffer_pool_uninit(AVBufferPool **pool)
     * }
     */
    public static MemorySegment av_buffer_pool_uninit$address() {
        return av_buffer_pool_uninit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_buffer_pool_uninit(AVBufferPool **pool)
     * }
     */
    public static void av_buffer_pool_uninit(MemorySegment pool) {
        var mh$ = av_buffer_pool_uninit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_pool_uninit", pool);
            }
            mh$.invokeExact(pool);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_pool_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_pool_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)
     * }
     */
    public static FunctionDescriptor av_buffer_pool_get$descriptor() {
        return av_buffer_pool_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)
     * }
     */
    public static MethodHandle av_buffer_pool_get$handle() {
        return av_buffer_pool_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)
     * }
     */
    public static MemorySegment av_buffer_pool_get$address() {
        return av_buffer_pool_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)
     * }
     */
    public static MemorySegment av_buffer_pool_get(MemorySegment pool) {
        var mh$ = av_buffer_pool_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_pool_get", pool);
            }
            return (MemorySegment)mh$.invokeExact(pool);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffer_pool_buffer_get_opaque {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffer_pool_buffer_get_opaque");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_buffer_pool_buffer_get_opaque(const AVBufferRef *ref)
     * }
     */
    public static FunctionDescriptor av_buffer_pool_buffer_get_opaque$descriptor() {
        return av_buffer_pool_buffer_get_opaque.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_buffer_pool_buffer_get_opaque(const AVBufferRef *ref)
     * }
     */
    public static MethodHandle av_buffer_pool_buffer_get_opaque$handle() {
        return av_buffer_pool_buffer_get_opaque.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_buffer_pool_buffer_get_opaque(const AVBufferRef *ref)
     * }
     */
    public static MemorySegment av_buffer_pool_buffer_get_opaque$address() {
        return av_buffer_pool_buffer_get_opaque.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_buffer_pool_buffer_get_opaque(const AVBufferRef *ref)
     * }
     */
    public static MemorySegment av_buffer_pool_buffer_get_opaque(MemorySegment ref) {
        var mh$ = av_buffer_pool_buffer_get_opaque.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffer_pool_buffer_get_opaque", ref);
            }
            return (MemorySegment)mh$.invokeExact(ref);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_CHAN_NONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_NONE = -1
     * }
     */
    public static int AV_CHAN_NONE() {
        return AV_CHAN_NONE;
    }
    private static final int AV_CHAN_FRONT_LEFT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_FRONT_LEFT = 0
     * }
     */
    public static int AV_CHAN_FRONT_LEFT() {
        return AV_CHAN_FRONT_LEFT;
    }
    private static final int AV_CHAN_FRONT_RIGHT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_FRONT_RIGHT = 1
     * }
     */
    public static int AV_CHAN_FRONT_RIGHT() {
        return AV_CHAN_FRONT_RIGHT;
    }
    private static final int AV_CHAN_FRONT_CENTER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_FRONT_CENTER = 2
     * }
     */
    public static int AV_CHAN_FRONT_CENTER() {
        return AV_CHAN_FRONT_CENTER;
    }
    private static final int AV_CHAN_LOW_FREQUENCY = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_LOW_FREQUENCY = 3
     * }
     */
    public static int AV_CHAN_LOW_FREQUENCY() {
        return AV_CHAN_LOW_FREQUENCY;
    }
    private static final int AV_CHAN_BACK_LEFT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BACK_LEFT = 4
     * }
     */
    public static int AV_CHAN_BACK_LEFT() {
        return AV_CHAN_BACK_LEFT;
    }
    private static final int AV_CHAN_BACK_RIGHT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BACK_RIGHT = 5
     * }
     */
    public static int AV_CHAN_BACK_RIGHT() {
        return AV_CHAN_BACK_RIGHT;
    }
    private static final int AV_CHAN_FRONT_LEFT_OF_CENTER = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_FRONT_LEFT_OF_CENTER = 6
     * }
     */
    public static int AV_CHAN_FRONT_LEFT_OF_CENTER() {
        return AV_CHAN_FRONT_LEFT_OF_CENTER;
    }
    private static final int AV_CHAN_FRONT_RIGHT_OF_CENTER = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_FRONT_RIGHT_OF_CENTER = 7
     * }
     */
    public static int AV_CHAN_FRONT_RIGHT_OF_CENTER() {
        return AV_CHAN_FRONT_RIGHT_OF_CENTER;
    }
    private static final int AV_CHAN_BACK_CENTER = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BACK_CENTER = 8
     * }
     */
    public static int AV_CHAN_BACK_CENTER() {
        return AV_CHAN_BACK_CENTER;
    }
    private static final int AV_CHAN_SIDE_LEFT = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SIDE_LEFT = 9
     * }
     */
    public static int AV_CHAN_SIDE_LEFT() {
        return AV_CHAN_SIDE_LEFT;
    }
    private static final int AV_CHAN_SIDE_RIGHT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SIDE_RIGHT = 10
     * }
     */
    public static int AV_CHAN_SIDE_RIGHT() {
        return AV_CHAN_SIDE_RIGHT;
    }
    private static final int AV_CHAN_TOP_CENTER = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_CENTER = 11
     * }
     */
    public static int AV_CHAN_TOP_CENTER() {
        return AV_CHAN_TOP_CENTER;
    }
    private static final int AV_CHAN_TOP_FRONT_LEFT = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_FRONT_LEFT = 12
     * }
     */
    public static int AV_CHAN_TOP_FRONT_LEFT() {
        return AV_CHAN_TOP_FRONT_LEFT;
    }
    private static final int AV_CHAN_TOP_FRONT_CENTER = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_FRONT_CENTER = 13
     * }
     */
    public static int AV_CHAN_TOP_FRONT_CENTER() {
        return AV_CHAN_TOP_FRONT_CENTER;
    }
    private static final int AV_CHAN_TOP_FRONT_RIGHT = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_FRONT_RIGHT = 14
     * }
     */
    public static int AV_CHAN_TOP_FRONT_RIGHT() {
        return AV_CHAN_TOP_FRONT_RIGHT;
    }
    private static final int AV_CHAN_TOP_BACK_LEFT = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_BACK_LEFT = 15
     * }
     */
    public static int AV_CHAN_TOP_BACK_LEFT() {
        return AV_CHAN_TOP_BACK_LEFT;
    }
    private static final int AV_CHAN_TOP_BACK_CENTER = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_BACK_CENTER = 16
     * }
     */
    public static int AV_CHAN_TOP_BACK_CENTER() {
        return AV_CHAN_TOP_BACK_CENTER;
    }
    private static final int AV_CHAN_TOP_BACK_RIGHT = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_BACK_RIGHT = 17
     * }
     */
    public static int AV_CHAN_TOP_BACK_RIGHT() {
        return AV_CHAN_TOP_BACK_RIGHT;
    }
    private static final int AV_CHAN_STEREO_LEFT = (int)29L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_STEREO_LEFT = 29
     * }
     */
    public static int AV_CHAN_STEREO_LEFT() {
        return AV_CHAN_STEREO_LEFT;
    }
    private static final int AV_CHAN_STEREO_RIGHT = (int)30L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_STEREO_RIGHT = 30
     * }
     */
    public static int AV_CHAN_STEREO_RIGHT() {
        return AV_CHAN_STEREO_RIGHT;
    }
    private static final int AV_CHAN_WIDE_LEFT = (int)31L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_WIDE_LEFT = 31
     * }
     */
    public static int AV_CHAN_WIDE_LEFT() {
        return AV_CHAN_WIDE_LEFT;
    }
    private static final int AV_CHAN_WIDE_RIGHT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_WIDE_RIGHT = 32
     * }
     */
    public static int AV_CHAN_WIDE_RIGHT() {
        return AV_CHAN_WIDE_RIGHT;
    }
    private static final int AV_CHAN_SURROUND_DIRECT_LEFT = (int)33L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SURROUND_DIRECT_LEFT = 33
     * }
     */
    public static int AV_CHAN_SURROUND_DIRECT_LEFT() {
        return AV_CHAN_SURROUND_DIRECT_LEFT;
    }
    private static final int AV_CHAN_SURROUND_DIRECT_RIGHT = (int)34L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SURROUND_DIRECT_RIGHT = 34
     * }
     */
    public static int AV_CHAN_SURROUND_DIRECT_RIGHT() {
        return AV_CHAN_SURROUND_DIRECT_RIGHT;
    }
    private static final int AV_CHAN_LOW_FREQUENCY_2 = (int)35L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_LOW_FREQUENCY_2 = 35
     * }
     */
    public static int AV_CHAN_LOW_FREQUENCY_2() {
        return AV_CHAN_LOW_FREQUENCY_2;
    }
    private static final int AV_CHAN_TOP_SIDE_LEFT = (int)36L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_SIDE_LEFT = 36
     * }
     */
    public static int AV_CHAN_TOP_SIDE_LEFT() {
        return AV_CHAN_TOP_SIDE_LEFT;
    }
    private static final int AV_CHAN_TOP_SIDE_RIGHT = (int)37L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_SIDE_RIGHT = 37
     * }
     */
    public static int AV_CHAN_TOP_SIDE_RIGHT() {
        return AV_CHAN_TOP_SIDE_RIGHT;
    }
    private static final int AV_CHAN_BOTTOM_FRONT_CENTER = (int)38L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BOTTOM_FRONT_CENTER = 38
     * }
     */
    public static int AV_CHAN_BOTTOM_FRONT_CENTER() {
        return AV_CHAN_BOTTOM_FRONT_CENTER;
    }
    private static final int AV_CHAN_BOTTOM_FRONT_LEFT = (int)39L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BOTTOM_FRONT_LEFT = 39
     * }
     */
    public static int AV_CHAN_BOTTOM_FRONT_LEFT() {
        return AV_CHAN_BOTTOM_FRONT_LEFT;
    }
    private static final int AV_CHAN_BOTTOM_FRONT_RIGHT = (int)40L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BOTTOM_FRONT_RIGHT = 40
     * }
     */
    public static int AV_CHAN_BOTTOM_FRONT_RIGHT() {
        return AV_CHAN_BOTTOM_FRONT_RIGHT;
    }
    private static final int AV_CHAN_SIDE_SURROUND_LEFT = (int)41L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SIDE_SURROUND_LEFT = 41
     * }
     */
    public static int AV_CHAN_SIDE_SURROUND_LEFT() {
        return AV_CHAN_SIDE_SURROUND_LEFT;
    }
    private static final int AV_CHAN_SIDE_SURROUND_RIGHT = (int)42L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_SIDE_SURROUND_RIGHT = 42
     * }
     */
    public static int AV_CHAN_SIDE_SURROUND_RIGHT() {
        return AV_CHAN_SIDE_SURROUND_RIGHT;
    }
    private static final int AV_CHAN_TOP_SURROUND_LEFT = (int)43L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_SURROUND_LEFT = 43
     * }
     */
    public static int AV_CHAN_TOP_SURROUND_LEFT() {
        return AV_CHAN_TOP_SURROUND_LEFT;
    }
    private static final int AV_CHAN_TOP_SURROUND_RIGHT = (int)44L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_TOP_SURROUND_RIGHT = 44
     * }
     */
    public static int AV_CHAN_TOP_SURROUND_RIGHT() {
        return AV_CHAN_TOP_SURROUND_RIGHT;
    }
    private static final int AV_CHAN_BINAURAL_LEFT = (int)61L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BINAURAL_LEFT = 61
     * }
     */
    public static int AV_CHAN_BINAURAL_LEFT() {
        return AV_CHAN_BINAURAL_LEFT;
    }
    private static final int AV_CHAN_BINAURAL_RIGHT = (int)62L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_BINAURAL_RIGHT = 62
     * }
     */
    public static int AV_CHAN_BINAURAL_RIGHT() {
        return AV_CHAN_BINAURAL_RIGHT;
    }
    private static final int AV_CHAN_UNUSED = (int)512L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_UNUSED = 512
     * }
     */
    public static int AV_CHAN_UNUSED() {
        return AV_CHAN_UNUSED;
    }
    private static final int AV_CHAN_UNKNOWN = (int)768L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_UNKNOWN = 768
     * }
     */
    public static int AV_CHAN_UNKNOWN() {
        return AV_CHAN_UNKNOWN;
    }
    private static final int AV_CHAN_AMBISONIC_BASE = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_AMBISONIC_BASE = 1024
     * }
     */
    public static int AV_CHAN_AMBISONIC_BASE() {
        return AV_CHAN_AMBISONIC_BASE;
    }
    private static final int AV_CHAN_AMBISONIC_END = (int)2047L;
    /**
     * {@snippet lang=c :
     * enum AVChannel.AV_CHAN_AMBISONIC_END = 2047
     * }
     */
    public static int AV_CHAN_AMBISONIC_END() {
        return AV_CHAN_AMBISONIC_END;
    }
    private static final int AV_CHANNEL_ORDER_UNSPEC = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVChannelOrder.AV_CHANNEL_ORDER_UNSPEC = 0
     * }
     */
    public static int AV_CHANNEL_ORDER_UNSPEC() {
        return AV_CHANNEL_ORDER_UNSPEC;
    }
    private static final int AV_CHANNEL_ORDER_NATIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVChannelOrder.AV_CHANNEL_ORDER_NATIVE = 1
     * }
     */
    public static int AV_CHANNEL_ORDER_NATIVE() {
        return AV_CHANNEL_ORDER_NATIVE;
    }
    private static final int AV_CHANNEL_ORDER_CUSTOM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVChannelOrder.AV_CHANNEL_ORDER_CUSTOM = 2
     * }
     */
    public static int AV_CHANNEL_ORDER_CUSTOM() {
        return AV_CHANNEL_ORDER_CUSTOM;
    }
    private static final int AV_CHANNEL_ORDER_AMBISONIC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVChannelOrder.AV_CHANNEL_ORDER_AMBISONIC = 3
     * }
     */
    public static int AV_CHANNEL_ORDER_AMBISONIC() {
        return AV_CHANNEL_ORDER_AMBISONIC;
    }
    private static final int FF_CHANNEL_ORDER_NB = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVChannelOrder.FF_CHANNEL_ORDER_NB = 4
     * }
     */
    public static int FF_CHANNEL_ORDER_NB() {
        return FF_CHANNEL_ORDER_NB;
    }
    private static final int AV_MATRIX_ENCODING_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_NONE = 0
     * }
     */
    public static int AV_MATRIX_ENCODING_NONE() {
        return AV_MATRIX_ENCODING_NONE;
    }
    private static final int AV_MATRIX_ENCODING_DOLBY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_DOLBY = 1
     * }
     */
    public static int AV_MATRIX_ENCODING_DOLBY() {
        return AV_MATRIX_ENCODING_DOLBY;
    }
    private static final int AV_MATRIX_ENCODING_DPLII = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_DPLII = 2
     * }
     */
    public static int AV_MATRIX_ENCODING_DPLII() {
        return AV_MATRIX_ENCODING_DPLII;
    }
    private static final int AV_MATRIX_ENCODING_DPLIIX = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_DPLIIX = 3
     * }
     */
    public static int AV_MATRIX_ENCODING_DPLIIX() {
        return AV_MATRIX_ENCODING_DPLIIX;
    }
    private static final int AV_MATRIX_ENCODING_DPLIIZ = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_DPLIIZ = 4
     * }
     */
    public static int AV_MATRIX_ENCODING_DPLIIZ() {
        return AV_MATRIX_ENCODING_DPLIIZ;
    }
    private static final int AV_MATRIX_ENCODING_DOLBYEX = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_DOLBYEX = 5
     * }
     */
    public static int AV_MATRIX_ENCODING_DOLBYEX() {
        return AV_MATRIX_ENCODING_DOLBYEX;
    }
    private static final int AV_MATRIX_ENCODING_DOLBYHEADPHONE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_DOLBYHEADPHONE = 6
     * }
     */
    public static int AV_MATRIX_ENCODING_DOLBYHEADPHONE() {
        return AV_MATRIX_ENCODING_DOLBYHEADPHONE;
    }
    private static final int AV_MATRIX_ENCODING_NB = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVMatrixEncoding.AV_MATRIX_ENCODING_NB = 7
     * }
     */
    public static int AV_MATRIX_ENCODING_NB() {
        return AV_MATRIX_ENCODING_NB;
    }

    private static class av_channel_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_name(char *buf, size_t buf_size, enum AVChannel channel)
     * }
     */
    public static FunctionDescriptor av_channel_name$descriptor() {
        return av_channel_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_name(char *buf, size_t buf_size, enum AVChannel channel)
     * }
     */
    public static MethodHandle av_channel_name$handle() {
        return av_channel_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_channel_name(char *buf, size_t buf_size, enum AVChannel channel)
     * }
     */
    public static MemorySegment av_channel_name$address() {
        return av_channel_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_channel_name(char *buf, size_t buf_size, enum AVChannel channel)
     * }
     */
    public static int av_channel_name(MemorySegment buf, long buf_size, int channel) {
        var mh$ = av_channel_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_name", buf, buf_size, channel);
            }
            return (int)mh$.invokeExact(buf, buf_size, channel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_name_bprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_name_bprint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_channel_name_bprint(struct AVBPrint *bp, enum AVChannel channel_id)
     * }
     */
    public static FunctionDescriptor av_channel_name_bprint$descriptor() {
        return av_channel_name_bprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_channel_name_bprint(struct AVBPrint *bp, enum AVChannel channel_id)
     * }
     */
    public static MethodHandle av_channel_name_bprint$handle() {
        return av_channel_name_bprint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_channel_name_bprint(struct AVBPrint *bp, enum AVChannel channel_id)
     * }
     */
    public static MemorySegment av_channel_name_bprint$address() {
        return av_channel_name_bprint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_channel_name_bprint(struct AVBPrint *bp, enum AVChannel channel_id)
     * }
     */
    public static void av_channel_name_bprint(MemorySegment bp, int channel_id) {
        var mh$ = av_channel_name_bprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_name_bprint", bp, channel_id);
            }
            mh$.invokeExact(bp, channel_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_description {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_description");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_description(char *buf, size_t buf_size, enum AVChannel channel)
     * }
     */
    public static FunctionDescriptor av_channel_description$descriptor() {
        return av_channel_description.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_description(char *buf, size_t buf_size, enum AVChannel channel)
     * }
     */
    public static MethodHandle av_channel_description$handle() {
        return av_channel_description.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_channel_description(char *buf, size_t buf_size, enum AVChannel channel)
     * }
     */
    public static MemorySegment av_channel_description$address() {
        return av_channel_description.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_channel_description(char *buf, size_t buf_size, enum AVChannel channel)
     * }
     */
    public static int av_channel_description(MemorySegment buf, long buf_size, int channel) {
        var mh$ = av_channel_description.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_description", buf, buf_size, channel);
            }
            return (int)mh$.invokeExact(buf, buf_size, channel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_description_bprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_description_bprint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_channel_description_bprint(struct AVBPrint *bp, enum AVChannel channel_id)
     * }
     */
    public static FunctionDescriptor av_channel_description_bprint$descriptor() {
        return av_channel_description_bprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_channel_description_bprint(struct AVBPrint *bp, enum AVChannel channel_id)
     * }
     */
    public static MethodHandle av_channel_description_bprint$handle() {
        return av_channel_description_bprint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_channel_description_bprint(struct AVBPrint *bp, enum AVChannel channel_id)
     * }
     */
    public static MemorySegment av_channel_description_bprint$address() {
        return av_channel_description_bprint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_channel_description_bprint(struct AVBPrint *bp, enum AVChannel channel_id)
     * }
     */
    public static void av_channel_description_bprint(MemorySegment bp, int channel_id) {
        var mh$ = av_channel_description_bprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_description_bprint", bp, channel_id);
            }
            mh$.invokeExact(bp, channel_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_from_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_from_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVChannel av_channel_from_string(const char *name)
     * }
     */
    public static FunctionDescriptor av_channel_from_string$descriptor() {
        return av_channel_from_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVChannel av_channel_from_string(const char *name)
     * }
     */
    public static MethodHandle av_channel_from_string$handle() {
        return av_channel_from_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVChannel av_channel_from_string(const char *name)
     * }
     */
    public static MemorySegment av_channel_from_string$address() {
        return av_channel_from_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVChannel av_channel_from_string(const char *name)
     * }
     */
    public static int av_channel_from_string(MemorySegment name) {
        var mh$ = av_channel_from_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_from_string", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_custom_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_custom_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_custom_init(AVChannelLayout *channel_layout, int nb_channels)
     * }
     */
    public static FunctionDescriptor av_channel_layout_custom_init$descriptor() {
        return av_channel_layout_custom_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_custom_init(AVChannelLayout *channel_layout, int nb_channels)
     * }
     */
    public static MethodHandle av_channel_layout_custom_init$handle() {
        return av_channel_layout_custom_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_channel_layout_custom_init(AVChannelLayout *channel_layout, int nb_channels)
     * }
     */
    public static MemorySegment av_channel_layout_custom_init$address() {
        return av_channel_layout_custom_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_channel_layout_custom_init(AVChannelLayout *channel_layout, int nb_channels)
     * }
     */
    public static int av_channel_layout_custom_init(MemorySegment channel_layout, int nb_channels) {
        var mh$ = av_channel_layout_custom_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_custom_init", channel_layout, nb_channels);
            }
            return (int)mh$.invokeExact(channel_layout, nb_channels);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_from_mask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_from_mask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_from_mask(AVChannelLayout *channel_layout, uint64_t mask)
     * }
     */
    public static FunctionDescriptor av_channel_layout_from_mask$descriptor() {
        return av_channel_layout_from_mask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_from_mask(AVChannelLayout *channel_layout, uint64_t mask)
     * }
     */
    public static MethodHandle av_channel_layout_from_mask$handle() {
        return av_channel_layout_from_mask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_channel_layout_from_mask(AVChannelLayout *channel_layout, uint64_t mask)
     * }
     */
    public static MemorySegment av_channel_layout_from_mask$address() {
        return av_channel_layout_from_mask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_channel_layout_from_mask(AVChannelLayout *channel_layout, uint64_t mask)
     * }
     */
    public static int av_channel_layout_from_mask(MemorySegment channel_layout, long mask) {
        var mh$ = av_channel_layout_from_mask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_from_mask", channel_layout, mask);
            }
            return (int)mh$.invokeExact(channel_layout, mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_from_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_from_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_from_string(AVChannelLayout *channel_layout, const char *str)
     * }
     */
    public static FunctionDescriptor av_channel_layout_from_string$descriptor() {
        return av_channel_layout_from_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_from_string(AVChannelLayout *channel_layout, const char *str)
     * }
     */
    public static MethodHandle av_channel_layout_from_string$handle() {
        return av_channel_layout_from_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_channel_layout_from_string(AVChannelLayout *channel_layout, const char *str)
     * }
     */
    public static MemorySegment av_channel_layout_from_string$address() {
        return av_channel_layout_from_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_channel_layout_from_string(AVChannelLayout *channel_layout, const char *str)
     * }
     */
    public static int av_channel_layout_from_string(MemorySegment channel_layout, MemorySegment str) {
        var mh$ = av_channel_layout_from_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_from_string", channel_layout, str);
            }
            return (int)mh$.invokeExact(channel_layout, str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_channel_layout_default(AVChannelLayout *ch_layout, int nb_channels)
     * }
     */
    public static FunctionDescriptor av_channel_layout_default$descriptor() {
        return av_channel_layout_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_channel_layout_default(AVChannelLayout *ch_layout, int nb_channels)
     * }
     */
    public static MethodHandle av_channel_layout_default$handle() {
        return av_channel_layout_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_channel_layout_default(AVChannelLayout *ch_layout, int nb_channels)
     * }
     */
    public static MemorySegment av_channel_layout_default$address() {
        return av_channel_layout_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_channel_layout_default(AVChannelLayout *ch_layout, int nb_channels)
     * }
     */
    public static void av_channel_layout_default(MemorySegment ch_layout, int nb_channels) {
        var mh$ = av_channel_layout_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_default", ch_layout, nb_channels);
            }
            mh$.invokeExact(ch_layout, nb_channels);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_standard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_standard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVChannelLayout *av_channel_layout_standard(void **opaque)
     * }
     */
    public static FunctionDescriptor av_channel_layout_standard$descriptor() {
        return av_channel_layout_standard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVChannelLayout *av_channel_layout_standard(void **opaque)
     * }
     */
    public static MethodHandle av_channel_layout_standard$handle() {
        return av_channel_layout_standard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVChannelLayout *av_channel_layout_standard(void **opaque)
     * }
     */
    public static MemorySegment av_channel_layout_standard$address() {
        return av_channel_layout_standard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVChannelLayout *av_channel_layout_standard(void **opaque)
     * }
     */
    public static MemorySegment av_channel_layout_standard(MemorySegment opaque) {
        var mh$ = av_channel_layout_standard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_standard", opaque);
            }
            return (MemorySegment)mh$.invokeExact(opaque);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_uninit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_uninit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_channel_layout_uninit(AVChannelLayout *channel_layout)
     * }
     */
    public static FunctionDescriptor av_channel_layout_uninit$descriptor() {
        return av_channel_layout_uninit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_channel_layout_uninit(AVChannelLayout *channel_layout)
     * }
     */
    public static MethodHandle av_channel_layout_uninit$handle() {
        return av_channel_layout_uninit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_channel_layout_uninit(AVChannelLayout *channel_layout)
     * }
     */
    public static MemorySegment av_channel_layout_uninit$address() {
        return av_channel_layout_uninit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_channel_layout_uninit(AVChannelLayout *channel_layout)
     * }
     */
    public static void av_channel_layout_uninit(MemorySegment channel_layout) {
        var mh$ = av_channel_layout_uninit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_uninit", channel_layout);
            }
            mh$.invokeExact(channel_layout);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_copy(AVChannelLayout *dst, const AVChannelLayout *src)
     * }
     */
    public static FunctionDescriptor av_channel_layout_copy$descriptor() {
        return av_channel_layout_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_copy(AVChannelLayout *dst, const AVChannelLayout *src)
     * }
     */
    public static MethodHandle av_channel_layout_copy$handle() {
        return av_channel_layout_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_channel_layout_copy(AVChannelLayout *dst, const AVChannelLayout *src)
     * }
     */
    public static MemorySegment av_channel_layout_copy$address() {
        return av_channel_layout_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_channel_layout_copy(AVChannelLayout *dst, const AVChannelLayout *src)
     * }
     */
    public static int av_channel_layout_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = av_channel_layout_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_copy", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_describe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_describe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_describe(const AVChannelLayout *channel_layout, char *buf, size_t buf_size)
     * }
     */
    public static FunctionDescriptor av_channel_layout_describe$descriptor() {
        return av_channel_layout_describe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_describe(const AVChannelLayout *channel_layout, char *buf, size_t buf_size)
     * }
     */
    public static MethodHandle av_channel_layout_describe$handle() {
        return av_channel_layout_describe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_channel_layout_describe(const AVChannelLayout *channel_layout, char *buf, size_t buf_size)
     * }
     */
    public static MemorySegment av_channel_layout_describe$address() {
        return av_channel_layout_describe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_channel_layout_describe(const AVChannelLayout *channel_layout, char *buf, size_t buf_size)
     * }
     */
    public static int av_channel_layout_describe(MemorySegment channel_layout, MemorySegment buf, long buf_size) {
        var mh$ = av_channel_layout_describe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_describe", channel_layout, buf, buf_size);
            }
            return (int)mh$.invokeExact(channel_layout, buf, buf_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_describe_bprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_describe_bprint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_describe_bprint(const AVChannelLayout *channel_layout, struct AVBPrint *bp)
     * }
     */
    public static FunctionDescriptor av_channel_layout_describe_bprint$descriptor() {
        return av_channel_layout_describe_bprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_describe_bprint(const AVChannelLayout *channel_layout, struct AVBPrint *bp)
     * }
     */
    public static MethodHandle av_channel_layout_describe_bprint$handle() {
        return av_channel_layout_describe_bprint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_channel_layout_describe_bprint(const AVChannelLayout *channel_layout, struct AVBPrint *bp)
     * }
     */
    public static MemorySegment av_channel_layout_describe_bprint$address() {
        return av_channel_layout_describe_bprint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_channel_layout_describe_bprint(const AVChannelLayout *channel_layout, struct AVBPrint *bp)
     * }
     */
    public static int av_channel_layout_describe_bprint(MemorySegment channel_layout, MemorySegment bp) {
        var mh$ = av_channel_layout_describe_bprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_describe_bprint", channel_layout, bp);
            }
            return (int)mh$.invokeExact(channel_layout, bp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_channel_from_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_channel_from_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVChannel av_channel_layout_channel_from_index(const AVChannelLayout *channel_layout, unsigned int idx)
     * }
     */
    public static FunctionDescriptor av_channel_layout_channel_from_index$descriptor() {
        return av_channel_layout_channel_from_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVChannel av_channel_layout_channel_from_index(const AVChannelLayout *channel_layout, unsigned int idx)
     * }
     */
    public static MethodHandle av_channel_layout_channel_from_index$handle() {
        return av_channel_layout_channel_from_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVChannel av_channel_layout_channel_from_index(const AVChannelLayout *channel_layout, unsigned int idx)
     * }
     */
    public static MemorySegment av_channel_layout_channel_from_index$address() {
        return av_channel_layout_channel_from_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVChannel av_channel_layout_channel_from_index(const AVChannelLayout *channel_layout, unsigned int idx)
     * }
     */
    public static int av_channel_layout_channel_from_index(MemorySegment channel_layout, int idx) {
        var mh$ = av_channel_layout_channel_from_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_channel_from_index", channel_layout, idx);
            }
            return (int)mh$.invokeExact(channel_layout, idx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_index_from_channel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_index_from_channel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_index_from_channel(const AVChannelLayout *channel_layout, enum AVChannel channel)
     * }
     */
    public static FunctionDescriptor av_channel_layout_index_from_channel$descriptor() {
        return av_channel_layout_index_from_channel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_index_from_channel(const AVChannelLayout *channel_layout, enum AVChannel channel)
     * }
     */
    public static MethodHandle av_channel_layout_index_from_channel$handle() {
        return av_channel_layout_index_from_channel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_channel_layout_index_from_channel(const AVChannelLayout *channel_layout, enum AVChannel channel)
     * }
     */
    public static MemorySegment av_channel_layout_index_from_channel$address() {
        return av_channel_layout_index_from_channel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_channel_layout_index_from_channel(const AVChannelLayout *channel_layout, enum AVChannel channel)
     * }
     */
    public static int av_channel_layout_index_from_channel(MemorySegment channel_layout, int channel) {
        var mh$ = av_channel_layout_index_from_channel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_index_from_channel", channel_layout, channel);
            }
            return (int)mh$.invokeExact(channel_layout, channel);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_index_from_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_index_from_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_index_from_string(const AVChannelLayout *channel_layout, const char *name)
     * }
     */
    public static FunctionDescriptor av_channel_layout_index_from_string$descriptor() {
        return av_channel_layout_index_from_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_index_from_string(const AVChannelLayout *channel_layout, const char *name)
     * }
     */
    public static MethodHandle av_channel_layout_index_from_string$handle() {
        return av_channel_layout_index_from_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_channel_layout_index_from_string(const AVChannelLayout *channel_layout, const char *name)
     * }
     */
    public static MemorySegment av_channel_layout_index_from_string$address() {
        return av_channel_layout_index_from_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_channel_layout_index_from_string(const AVChannelLayout *channel_layout, const char *name)
     * }
     */
    public static int av_channel_layout_index_from_string(MemorySegment channel_layout, MemorySegment name) {
        var mh$ = av_channel_layout_index_from_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_index_from_string", channel_layout, name);
            }
            return (int)mh$.invokeExact(channel_layout, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_channel_from_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_channel_from_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVChannel av_channel_layout_channel_from_string(const AVChannelLayout *channel_layout, const char *name)
     * }
     */
    public static FunctionDescriptor av_channel_layout_channel_from_string$descriptor() {
        return av_channel_layout_channel_from_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVChannel av_channel_layout_channel_from_string(const AVChannelLayout *channel_layout, const char *name)
     * }
     */
    public static MethodHandle av_channel_layout_channel_from_string$handle() {
        return av_channel_layout_channel_from_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVChannel av_channel_layout_channel_from_string(const AVChannelLayout *channel_layout, const char *name)
     * }
     */
    public static MemorySegment av_channel_layout_channel_from_string$address() {
        return av_channel_layout_channel_from_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVChannel av_channel_layout_channel_from_string(const AVChannelLayout *channel_layout, const char *name)
     * }
     */
    public static int av_channel_layout_channel_from_string(MemorySegment channel_layout, MemorySegment name) {
        var mh$ = av_channel_layout_channel_from_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_channel_from_string", channel_layout, name);
            }
            return (int)mh$.invokeExact(channel_layout, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_subset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_subset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t av_channel_layout_subset(const AVChannelLayout *channel_layout, uint64_t mask)
     * }
     */
    public static FunctionDescriptor av_channel_layout_subset$descriptor() {
        return av_channel_layout_subset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t av_channel_layout_subset(const AVChannelLayout *channel_layout, uint64_t mask)
     * }
     */
    public static MethodHandle av_channel_layout_subset$handle() {
        return av_channel_layout_subset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t av_channel_layout_subset(const AVChannelLayout *channel_layout, uint64_t mask)
     * }
     */
    public static MemorySegment av_channel_layout_subset$address() {
        return av_channel_layout_subset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t av_channel_layout_subset(const AVChannelLayout *channel_layout, uint64_t mask)
     * }
     */
    public static long av_channel_layout_subset(MemorySegment channel_layout, long mask) {
        var mh$ = av_channel_layout_subset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_subset", channel_layout, mask);
            }
            return (long)mh$.invokeExact(channel_layout, mask);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_check(const AVChannelLayout *channel_layout)
     * }
     */
    public static FunctionDescriptor av_channel_layout_check$descriptor() {
        return av_channel_layout_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_check(const AVChannelLayout *channel_layout)
     * }
     */
    public static MethodHandle av_channel_layout_check$handle() {
        return av_channel_layout_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_channel_layout_check(const AVChannelLayout *channel_layout)
     * }
     */
    public static MemorySegment av_channel_layout_check$address() {
        return av_channel_layout_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_channel_layout_check(const AVChannelLayout *channel_layout)
     * }
     */
    public static int av_channel_layout_check(MemorySegment channel_layout) {
        var mh$ = av_channel_layout_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_check", channel_layout);
            }
            return (int)mh$.invokeExact(channel_layout);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_compare(const AVChannelLayout *chl, const AVChannelLayout *chl1)
     * }
     */
    public static FunctionDescriptor av_channel_layout_compare$descriptor() {
        return av_channel_layout_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_compare(const AVChannelLayout *chl, const AVChannelLayout *chl1)
     * }
     */
    public static MethodHandle av_channel_layout_compare$handle() {
        return av_channel_layout_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_channel_layout_compare(const AVChannelLayout *chl, const AVChannelLayout *chl1)
     * }
     */
    public static MemorySegment av_channel_layout_compare$address() {
        return av_channel_layout_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_channel_layout_compare(const AVChannelLayout *chl, const AVChannelLayout *chl1)
     * }
     */
    public static int av_channel_layout_compare(MemorySegment chl, MemorySegment chl1) {
        var mh$ = av_channel_layout_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_compare", chl, chl1);
            }
            return (int)mh$.invokeExact(chl, chl1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_ambisonic_order {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_ambisonic_order");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_ambisonic_order(const AVChannelLayout *channel_layout)
     * }
     */
    public static FunctionDescriptor av_channel_layout_ambisonic_order$descriptor() {
        return av_channel_layout_ambisonic_order.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_ambisonic_order(const AVChannelLayout *channel_layout)
     * }
     */
    public static MethodHandle av_channel_layout_ambisonic_order$handle() {
        return av_channel_layout_ambisonic_order.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_channel_layout_ambisonic_order(const AVChannelLayout *channel_layout)
     * }
     */
    public static MemorySegment av_channel_layout_ambisonic_order$address() {
        return av_channel_layout_ambisonic_order.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_channel_layout_ambisonic_order(const AVChannelLayout *channel_layout)
     * }
     */
    public static int av_channel_layout_ambisonic_order(MemorySegment channel_layout) {
        var mh$ = av_channel_layout_ambisonic_order.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_ambisonic_order", channel_layout);
            }
            return (int)mh$.invokeExact(channel_layout);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_channel_layout_retype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_channel_layout_retype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_channel_layout_retype(AVChannelLayout *channel_layout, enum AVChannelOrder order, int flags)
     * }
     */
    public static FunctionDescriptor av_channel_layout_retype$descriptor() {
        return av_channel_layout_retype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_channel_layout_retype(AVChannelLayout *channel_layout, enum AVChannelOrder order, int flags)
     * }
     */
    public static MethodHandle av_channel_layout_retype$handle() {
        return av_channel_layout_retype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_channel_layout_retype(AVChannelLayout *channel_layout, enum AVChannelOrder order, int flags)
     * }
     */
    public static MemorySegment av_channel_layout_retype$address() {
        return av_channel_layout_retype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_channel_layout_retype(AVChannelLayout *channel_layout, enum AVChannelOrder order, int flags)
     * }
     */
    public static int av_channel_layout_retype(MemorySegment channel_layout, int order, int flags) {
        var mh$ = av_channel_layout_retype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_channel_layout_retype", channel_layout, order, flags);
            }
            return (int)mh$.invokeExact(channel_layout, order, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dict_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVDictionaryEntry *av_dict_get(const AVDictionary *m, const char *key, const AVDictionaryEntry *prev, int flags)
     * }
     */
    public static FunctionDescriptor av_dict_get$descriptor() {
        return av_dict_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVDictionaryEntry *av_dict_get(const AVDictionary *m, const char *key, const AVDictionaryEntry *prev, int flags)
     * }
     */
    public static MethodHandle av_dict_get$handle() {
        return av_dict_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVDictionaryEntry *av_dict_get(const AVDictionary *m, const char *key, const AVDictionaryEntry *prev, int flags)
     * }
     */
    public static MemorySegment av_dict_get$address() {
        return av_dict_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVDictionaryEntry *av_dict_get(const AVDictionary *m, const char *key, const AVDictionaryEntry *prev, int flags)
     * }
     */
    public static MemorySegment av_dict_get(MemorySegment m, MemorySegment key, MemorySegment prev, int flags) {
        var mh$ = av_dict_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_get", m, key, prev, flags);
            }
            return (MemorySegment)mh$.invokeExact(m, key, prev, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_iterate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dict_iterate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVDictionaryEntry *av_dict_iterate(const AVDictionary *m, const AVDictionaryEntry *prev)
     * }
     */
    public static FunctionDescriptor av_dict_iterate$descriptor() {
        return av_dict_iterate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVDictionaryEntry *av_dict_iterate(const AVDictionary *m, const AVDictionaryEntry *prev)
     * }
     */
    public static MethodHandle av_dict_iterate$handle() {
        return av_dict_iterate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVDictionaryEntry *av_dict_iterate(const AVDictionary *m, const AVDictionaryEntry *prev)
     * }
     */
    public static MemorySegment av_dict_iterate$address() {
        return av_dict_iterate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVDictionaryEntry *av_dict_iterate(const AVDictionary *m, const AVDictionaryEntry *prev)
     * }
     */
    public static MemorySegment av_dict_iterate(MemorySegment m, MemorySegment prev) {
        var mh$ = av_dict_iterate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_iterate", m, prev);
            }
            return (MemorySegment)mh$.invokeExact(m, prev);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dict_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dict_count(const AVDictionary *m)
     * }
     */
    public static FunctionDescriptor av_dict_count$descriptor() {
        return av_dict_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dict_count(const AVDictionary *m)
     * }
     */
    public static MethodHandle av_dict_count$handle() {
        return av_dict_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_dict_count(const AVDictionary *m)
     * }
     */
    public static MemorySegment av_dict_count$address() {
        return av_dict_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_dict_count(const AVDictionary *m)
     * }
     */
    public static int av_dict_count(MemorySegment m) {
        var mh$ = av_dict_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_count", m);
            }
            return (int)mh$.invokeExact(m);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dict_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags)
     * }
     */
    public static FunctionDescriptor av_dict_set$descriptor() {
        return av_dict_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags)
     * }
     */
    public static MethodHandle av_dict_set$handle() {
        return av_dict_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags)
     * }
     */
    public static MemorySegment av_dict_set$address() {
        return av_dict_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags)
     * }
     */
    public static int av_dict_set(MemorySegment pm, MemorySegment key, MemorySegment value, int flags) {
        var mh$ = av_dict_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_set", pm, key, value, flags);
            }
            return (int)mh$.invokeExact(pm, key, value, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_set_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dict_set_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dict_set_int(AVDictionary **pm, const char *key, int64_t value, int flags)
     * }
     */
    public static FunctionDescriptor av_dict_set_int$descriptor() {
        return av_dict_set_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dict_set_int(AVDictionary **pm, const char *key, int64_t value, int flags)
     * }
     */
    public static MethodHandle av_dict_set_int$handle() {
        return av_dict_set_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_dict_set_int(AVDictionary **pm, const char *key, int64_t value, int flags)
     * }
     */
    public static MemorySegment av_dict_set_int$address() {
        return av_dict_set_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_dict_set_int(AVDictionary **pm, const char *key, int64_t value, int flags)
     * }
     */
    public static int av_dict_set_int(MemorySegment pm, MemorySegment key, long value, int flags) {
        var mh$ = av_dict_set_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_set_int", pm, key, value, flags);
            }
            return (int)mh$.invokeExact(pm, key, value, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_parse_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dict_parse_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dict_parse_string(AVDictionary **pm, const char *str, const char *key_val_sep, const char *pairs_sep, int flags)
     * }
     */
    public static FunctionDescriptor av_dict_parse_string$descriptor() {
        return av_dict_parse_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dict_parse_string(AVDictionary **pm, const char *str, const char *key_val_sep, const char *pairs_sep, int flags)
     * }
     */
    public static MethodHandle av_dict_parse_string$handle() {
        return av_dict_parse_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_dict_parse_string(AVDictionary **pm, const char *str, const char *key_val_sep, const char *pairs_sep, int flags)
     * }
     */
    public static MemorySegment av_dict_parse_string$address() {
        return av_dict_parse_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_dict_parse_string(AVDictionary **pm, const char *str, const char *key_val_sep, const char *pairs_sep, int flags)
     * }
     */
    public static int av_dict_parse_string(MemorySegment pm, MemorySegment str, MemorySegment key_val_sep, MemorySegment pairs_sep, int flags) {
        var mh$ = av_dict_parse_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_parse_string", pm, str, key_val_sep, pairs_sep, flags);
            }
            return (int)mh$.invokeExact(pm, str, key_val_sep, pairs_sep, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dict_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dict_copy(AVDictionary **dst, const AVDictionary *src, int flags)
     * }
     */
    public static FunctionDescriptor av_dict_copy$descriptor() {
        return av_dict_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dict_copy(AVDictionary **dst, const AVDictionary *src, int flags)
     * }
     */
    public static MethodHandle av_dict_copy$handle() {
        return av_dict_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_dict_copy(AVDictionary **dst, const AVDictionary *src, int flags)
     * }
     */
    public static MemorySegment av_dict_copy$address() {
        return av_dict_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_dict_copy(AVDictionary **dst, const AVDictionary *src, int flags)
     * }
     */
    public static int av_dict_copy(MemorySegment dst, MemorySegment src, int flags) {
        var mh$ = av_dict_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_copy", dst, src, flags);
            }
            return (int)mh$.invokeExact(dst, src, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dict_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_dict_free(AVDictionary **m)
     * }
     */
    public static FunctionDescriptor av_dict_free$descriptor() {
        return av_dict_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_dict_free(AVDictionary **m)
     * }
     */
    public static MethodHandle av_dict_free$handle() {
        return av_dict_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_dict_free(AVDictionary **m)
     * }
     */
    public static MemorySegment av_dict_free$address() {
        return av_dict_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_dict_free(AVDictionary **m)
     * }
     */
    public static void av_dict_free(MemorySegment m) {
        var mh$ = av_dict_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_free", m);
            }
            mh$.invokeExact(m);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dict_get_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_CHAR,
            ffmpeg_includes_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dict_get_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dict_get_string(const AVDictionary *m, char **buffer, const char key_val_sep, const char pairs_sep)
     * }
     */
    public static FunctionDescriptor av_dict_get_string$descriptor() {
        return av_dict_get_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dict_get_string(const AVDictionary *m, char **buffer, const char key_val_sep, const char pairs_sep)
     * }
     */
    public static MethodHandle av_dict_get_string$handle() {
        return av_dict_get_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_dict_get_string(const AVDictionary *m, char **buffer, const char key_val_sep, const char pairs_sep)
     * }
     */
    public static MemorySegment av_dict_get_string$address() {
        return av_dict_get_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_dict_get_string(const AVDictionary *m, char **buffer, const char key_val_sep, const char pairs_sep)
     * }
     */
    public static int av_dict_get_string(MemorySegment m, MemorySegment buffer, byte key_val_sep, byte pairs_sep) {
        var mh$ = av_dict_get_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dict_get_string", m, buffer, key_val_sep, pairs_sep);
            }
            return (int)mh$.invokeExact(m, buffer, key_val_sep, pairs_sep);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_FRAME_DATA_PANSCAN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_PANSCAN = 0
     * }
     */
    public static int AV_FRAME_DATA_PANSCAN() {
        return AV_FRAME_DATA_PANSCAN;
    }
    private static final int AV_FRAME_DATA_A53_CC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_A53_CC = 1
     * }
     */
    public static int AV_FRAME_DATA_A53_CC() {
        return AV_FRAME_DATA_A53_CC;
    }
    private static final int AV_FRAME_DATA_STEREO3D = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_STEREO3D = 2
     * }
     */
    public static int AV_FRAME_DATA_STEREO3D() {
        return AV_FRAME_DATA_STEREO3D;
    }
    private static final int AV_FRAME_DATA_MATRIXENCODING = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_MATRIXENCODING = 3
     * }
     */
    public static int AV_FRAME_DATA_MATRIXENCODING() {
        return AV_FRAME_DATA_MATRIXENCODING;
    }
    private static final int AV_FRAME_DATA_DOWNMIX_INFO = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DOWNMIX_INFO = 4
     * }
     */
    public static int AV_FRAME_DATA_DOWNMIX_INFO() {
        return AV_FRAME_DATA_DOWNMIX_INFO;
    }
    private static final int AV_FRAME_DATA_REPLAYGAIN = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_REPLAYGAIN = 5
     * }
     */
    public static int AV_FRAME_DATA_REPLAYGAIN() {
        return AV_FRAME_DATA_REPLAYGAIN;
    }
    private static final int AV_FRAME_DATA_DISPLAYMATRIX = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DISPLAYMATRIX = 6
     * }
     */
    public static int AV_FRAME_DATA_DISPLAYMATRIX() {
        return AV_FRAME_DATA_DISPLAYMATRIX;
    }
    private static final int AV_FRAME_DATA_AFD = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_AFD = 7
     * }
     */
    public static int AV_FRAME_DATA_AFD() {
        return AV_FRAME_DATA_AFD;
    }
    private static final int AV_FRAME_DATA_MOTION_VECTORS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_MOTION_VECTORS = 8
     * }
     */
    public static int AV_FRAME_DATA_MOTION_VECTORS() {
        return AV_FRAME_DATA_MOTION_VECTORS;
    }
    private static final int AV_FRAME_DATA_SKIP_SAMPLES = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_SKIP_SAMPLES = 9
     * }
     */
    public static int AV_FRAME_DATA_SKIP_SAMPLES() {
        return AV_FRAME_DATA_SKIP_SAMPLES;
    }
    private static final int AV_FRAME_DATA_AUDIO_SERVICE_TYPE = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10
     * }
     */
    public static int AV_FRAME_DATA_AUDIO_SERVICE_TYPE() {
        return AV_FRAME_DATA_AUDIO_SERVICE_TYPE;
    }
    private static final int AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11
     * }
     */
    public static int AV_FRAME_DATA_MASTERING_DISPLAY_METADATA() {
        return AV_FRAME_DATA_MASTERING_DISPLAY_METADATA;
    }
    private static final int AV_FRAME_DATA_GOP_TIMECODE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_GOP_TIMECODE = 12
     * }
     */
    public static int AV_FRAME_DATA_GOP_TIMECODE() {
        return AV_FRAME_DATA_GOP_TIMECODE;
    }
    private static final int AV_FRAME_DATA_SPHERICAL = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_SPHERICAL = 13
     * }
     */
    public static int AV_FRAME_DATA_SPHERICAL() {
        return AV_FRAME_DATA_SPHERICAL;
    }
    private static final int AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = 14
     * }
     */
    public static int AV_FRAME_DATA_CONTENT_LIGHT_LEVEL() {
        return AV_FRAME_DATA_CONTENT_LIGHT_LEVEL;
    }
    private static final int AV_FRAME_DATA_ICC_PROFILE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_ICC_PROFILE = 15
     * }
     */
    public static int AV_FRAME_DATA_ICC_PROFILE() {
        return AV_FRAME_DATA_ICC_PROFILE;
    }
    private static final int AV_FRAME_DATA_S12M_TIMECODE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_S12M_TIMECODE = 16
     * }
     */
    public static int AV_FRAME_DATA_S12M_TIMECODE() {
        return AV_FRAME_DATA_S12M_TIMECODE;
    }
    private static final int AV_FRAME_DATA_DYNAMIC_HDR_PLUS = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DYNAMIC_HDR_PLUS = 17
     * }
     */
    public static int AV_FRAME_DATA_DYNAMIC_HDR_PLUS() {
        return AV_FRAME_DATA_DYNAMIC_HDR_PLUS;
    }
    private static final int AV_FRAME_DATA_REGIONS_OF_INTEREST = (int)18L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_REGIONS_OF_INTEREST = 18
     * }
     */
    public static int AV_FRAME_DATA_REGIONS_OF_INTEREST() {
        return AV_FRAME_DATA_REGIONS_OF_INTEREST;
    }
    private static final int AV_FRAME_DATA_VIDEO_ENC_PARAMS = (int)19L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_VIDEO_ENC_PARAMS = 19
     * }
     */
    public static int AV_FRAME_DATA_VIDEO_ENC_PARAMS() {
        return AV_FRAME_DATA_VIDEO_ENC_PARAMS;
    }
    private static final int AV_FRAME_DATA_SEI_UNREGISTERED = (int)20L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_SEI_UNREGISTERED = 20
     * }
     */
    public static int AV_FRAME_DATA_SEI_UNREGISTERED() {
        return AV_FRAME_DATA_SEI_UNREGISTERED;
    }
    private static final int AV_FRAME_DATA_FILM_GRAIN_PARAMS = (int)21L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_FILM_GRAIN_PARAMS = 21
     * }
     */
    public static int AV_FRAME_DATA_FILM_GRAIN_PARAMS() {
        return AV_FRAME_DATA_FILM_GRAIN_PARAMS;
    }
    private static final int AV_FRAME_DATA_DETECTION_BBOXES = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DETECTION_BBOXES = 22
     * }
     */
    public static int AV_FRAME_DATA_DETECTION_BBOXES() {
        return AV_FRAME_DATA_DETECTION_BBOXES;
    }
    private static final int AV_FRAME_DATA_DOVI_RPU_BUFFER = (int)23L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DOVI_RPU_BUFFER = 23
     * }
     */
    public static int AV_FRAME_DATA_DOVI_RPU_BUFFER() {
        return AV_FRAME_DATA_DOVI_RPU_BUFFER;
    }
    private static final int AV_FRAME_DATA_DOVI_METADATA = (int)24L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DOVI_METADATA = 24
     * }
     */
    public static int AV_FRAME_DATA_DOVI_METADATA() {
        return AV_FRAME_DATA_DOVI_METADATA;
    }
    private static final int AV_FRAME_DATA_DYNAMIC_HDR_VIVID = (int)25L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DYNAMIC_HDR_VIVID = 25
     * }
     */
    public static int AV_FRAME_DATA_DYNAMIC_HDR_VIVID() {
        return AV_FRAME_DATA_DYNAMIC_HDR_VIVID;
    }
    private static final int AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT = (int)26L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT = 26
     * }
     */
    public static int AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT() {
        return AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT;
    }
    private static final int AV_FRAME_DATA_VIDEO_HINT = (int)27L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_VIDEO_HINT = 27
     * }
     */
    public static int AV_FRAME_DATA_VIDEO_HINT() {
        return AV_FRAME_DATA_VIDEO_HINT;
    }
    private static final int AV_FRAME_DATA_LCEVC = (int)28L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_LCEVC = 28
     * }
     */
    public static int AV_FRAME_DATA_LCEVC() {
        return AV_FRAME_DATA_LCEVC;
    }
    private static final int AV_FRAME_DATA_VIEW_ID = (int)29L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_VIEW_ID = 29
     * }
     */
    public static int AV_FRAME_DATA_VIEW_ID() {
        return AV_FRAME_DATA_VIEW_ID;
    }
    private static final int AV_FRAME_DATA_3D_REFERENCE_DISPLAYS = (int)30L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_3D_REFERENCE_DISPLAYS = 30
     * }
     */
    public static int AV_FRAME_DATA_3D_REFERENCE_DISPLAYS() {
        return AV_FRAME_DATA_3D_REFERENCE_DISPLAYS;
    }
    private static final int AV_FRAME_DATA_EXIF = (int)31L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_EXIF = 31
     * }
     */
    public static int AV_FRAME_DATA_EXIF() {
        return AV_FRAME_DATA_EXIF;
    }
    private static final int AV_AFD_SAME = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_SAME = 8
     * }
     */
    public static int AV_AFD_SAME() {
        return AV_AFD_SAME;
    }
    private static final int AV_AFD_4_3 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_4_3 = 9
     * }
     */
    public static int AV_AFD_4_3() {
        return AV_AFD_4_3;
    }
    private static final int AV_AFD_16_9 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_16_9 = 10
     * }
     */
    public static int AV_AFD_16_9() {
        return AV_AFD_16_9;
    }
    private static final int AV_AFD_14_9 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_14_9 = 11
     * }
     */
    public static int AV_AFD_14_9() {
        return AV_AFD_14_9;
    }
    private static final int AV_AFD_4_3_SP_14_9 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_4_3_SP_14_9 = 13
     * }
     */
    public static int AV_AFD_4_3_SP_14_9() {
        return AV_AFD_4_3_SP_14_9;
    }
    private static final int AV_AFD_16_9_SP_14_9 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_16_9_SP_14_9 = 14
     * }
     */
    public static int AV_AFD_16_9_SP_14_9() {
        return AV_AFD_16_9_SP_14_9;
    }
    private static final int AV_AFD_SP_4_3 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_SP_4_3 = 15
     * }
     */
    public static int AV_AFD_SP_4_3() {
        return AV_AFD_SP_4_3;
    }
    private static final int AV_SIDE_DATA_PROP_GLOBAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVSideDataProps.AV_SIDE_DATA_PROP_GLOBAL = 1
     * }
     */
    public static int AV_SIDE_DATA_PROP_GLOBAL() {
        return AV_SIDE_DATA_PROP_GLOBAL;
    }
    private static final int AV_SIDE_DATA_PROP_MULTI = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVSideDataProps.AV_SIDE_DATA_PROP_MULTI = 2
     * }
     */
    public static int AV_SIDE_DATA_PROP_MULTI() {
        return AV_SIDE_DATA_PROP_MULTI;
    }
    private static final int AV_SIDE_DATA_PROP_SIZE_DEPENDENT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVSideDataProps.AV_SIDE_DATA_PROP_SIZE_DEPENDENT = 4
     * }
     */
    public static int AV_SIDE_DATA_PROP_SIZE_DEPENDENT() {
        return AV_SIDE_DATA_PROP_SIZE_DEPENDENT;
    }
    private static final int AV_SIDE_DATA_PROP_COLOR_DEPENDENT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVSideDataProps.AV_SIDE_DATA_PROP_COLOR_DEPENDENT = 8
     * }
     */
    public static int AV_SIDE_DATA_PROP_COLOR_DEPENDENT() {
        return AV_SIDE_DATA_PROP_COLOR_DEPENDENT;
    }
    private static final int AV_SIDE_DATA_PROP_CHANNEL_DEPENDENT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVSideDataProps.AV_SIDE_DATA_PROP_CHANNEL_DEPENDENT = 16
     * }
     */
    public static int AV_SIDE_DATA_PROP_CHANNEL_DEPENDENT() {
        return AV_SIDE_DATA_PROP_CHANNEL_DEPENDENT;
    }

    private static class av_frame_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrame *av_frame_alloc()
     * }
     */
    public static FunctionDescriptor av_frame_alloc$descriptor() {
        return av_frame_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrame *av_frame_alloc()
     * }
     */
    public static MethodHandle av_frame_alloc$handle() {
        return av_frame_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrame *av_frame_alloc()
     * }
     */
    public static MemorySegment av_frame_alloc$address() {
        return av_frame_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrame *av_frame_alloc()
     * }
     */
    public static MemorySegment av_frame_alloc() {
        var mh$ = av_frame_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_free(AVFrame **frame)
     * }
     */
    public static FunctionDescriptor av_frame_free$descriptor() {
        return av_frame_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_free(AVFrame **frame)
     * }
     */
    public static MethodHandle av_frame_free$handle() {
        return av_frame_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_free(AVFrame **frame)
     * }
     */
    public static MemorySegment av_frame_free$address() {
        return av_frame_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_free(AVFrame **frame)
     * }
     */
    public static void av_frame_free(MemorySegment frame) {
        var mh$ = av_frame_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_free", frame);
            }
            mh$.invokeExact(frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_ref(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_ref$descriptor() {
        return av_frame_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_ref(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_ref$handle() {
        return av_frame_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_ref(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_ref$address() {
        return av_frame_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_ref(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int av_frame_ref(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_ref", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_replace(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_replace$descriptor() {
        return av_frame_replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_replace(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_replace$handle() {
        return av_frame_replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_replace(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_replace$address() {
        return av_frame_replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_replace(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int av_frame_replace(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_replace", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrame *av_frame_clone(const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_clone$descriptor() {
        return av_frame_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrame *av_frame_clone(const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_clone$handle() {
        return av_frame_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrame *av_frame_clone(const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_clone$address() {
        return av_frame_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrame *av_frame_clone(const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_clone(MemorySegment src) {
        var mh$ = av_frame_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_clone", src);
            }
            return (MemorySegment)mh$.invokeExact(src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_unref(AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_frame_unref$descriptor() {
        return av_frame_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_unref(AVFrame *frame)
     * }
     */
    public static MethodHandle av_frame_unref$handle() {
        return av_frame_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_unref(AVFrame *frame)
     * }
     */
    public static MemorySegment av_frame_unref$address() {
        return av_frame_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_unref(AVFrame *frame)
     * }
     */
    public static void av_frame_unref(MemorySegment frame) {
        var mh$ = av_frame_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_unref", frame);
            }
            mh$.invokeExact(frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_move_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_move_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_move_ref(AVFrame *dst, AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_move_ref$descriptor() {
        return av_frame_move_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_move_ref(AVFrame *dst, AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_move_ref$handle() {
        return av_frame_move_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_move_ref(AVFrame *dst, AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_move_ref$address() {
        return av_frame_move_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_move_ref(AVFrame *dst, AVFrame *src)
     * }
     */
    public static void av_frame_move_ref(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_move_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_move_ref", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_get_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_get_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_get_buffer(AVFrame *frame, int align)
     * }
     */
    public static FunctionDescriptor av_frame_get_buffer$descriptor() {
        return av_frame_get_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_get_buffer(AVFrame *frame, int align)
     * }
     */
    public static MethodHandle av_frame_get_buffer$handle() {
        return av_frame_get_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_get_buffer(AVFrame *frame, int align)
     * }
     */
    public static MemorySegment av_frame_get_buffer$address() {
        return av_frame_get_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_get_buffer(AVFrame *frame, int align)
     * }
     */
    public static int av_frame_get_buffer(MemorySegment frame, int align) {
        var mh$ = av_frame_get_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_get_buffer", frame, align);
            }
            return (int)mh$.invokeExact(frame, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_is_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_is_writable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_is_writable(AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_frame_is_writable$descriptor() {
        return av_frame_is_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_is_writable(AVFrame *frame)
     * }
     */
    public static MethodHandle av_frame_is_writable$handle() {
        return av_frame_is_writable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_is_writable(AVFrame *frame)
     * }
     */
    public static MemorySegment av_frame_is_writable$address() {
        return av_frame_is_writable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_is_writable(AVFrame *frame)
     * }
     */
    public static int av_frame_is_writable(MemorySegment frame) {
        var mh$ = av_frame_is_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_is_writable", frame);
            }
            return (int)mh$.invokeExact(frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_make_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_make_writable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_make_writable(AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_frame_make_writable$descriptor() {
        return av_frame_make_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_make_writable(AVFrame *frame)
     * }
     */
    public static MethodHandle av_frame_make_writable$handle() {
        return av_frame_make_writable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_make_writable(AVFrame *frame)
     * }
     */
    public static MemorySegment av_frame_make_writable$address() {
        return av_frame_make_writable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_make_writable(AVFrame *frame)
     * }
     */
    public static int av_frame_make_writable(MemorySegment frame) {
        var mh$ = av_frame_make_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_make_writable", frame);
            }
            return (int)mh$.invokeExact(frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_copy(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_copy$descriptor() {
        return av_frame_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_copy(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_copy$handle() {
        return av_frame_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_copy(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_copy$address() {
        return av_frame_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_copy(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int av_frame_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_copy", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_copy_props {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_copy_props");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_copy_props(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_copy_props$descriptor() {
        return av_frame_copy_props.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_copy_props(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_copy_props$handle() {
        return av_frame_copy_props.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_copy_props(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_copy_props$address() {
        return av_frame_copy_props.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_copy_props(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int av_frame_copy_props(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_copy_props.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_copy_props", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_get_plane_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_get_plane_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_frame_get_plane_buffer(const AVFrame *frame, int plane)
     * }
     */
    public static FunctionDescriptor av_frame_get_plane_buffer$descriptor() {
        return av_frame_get_plane_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_frame_get_plane_buffer(const AVFrame *frame, int plane)
     * }
     */
    public static MethodHandle av_frame_get_plane_buffer$handle() {
        return av_frame_get_plane_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_frame_get_plane_buffer(const AVFrame *frame, int plane)
     * }
     */
    public static MemorySegment av_frame_get_plane_buffer$address() {
        return av_frame_get_plane_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_frame_get_plane_buffer(const AVFrame *frame, int plane)
     * }
     */
    public static MemorySegment av_frame_get_plane_buffer(MemorySegment frame, int plane) {
        var mh$ = av_frame_get_plane_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_get_plane_buffer", frame, plane);
            }
            return (MemorySegment)mh$.invokeExact(frame, plane);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_new_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_new_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data(AVFrame *frame, enum AVFrameSideDataType type, size_t size)
     * }
     */
    public static FunctionDescriptor av_frame_new_side_data$descriptor() {
        return av_frame_new_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data(AVFrame *frame, enum AVFrameSideDataType type, size_t size)
     * }
     */
    public static MethodHandle av_frame_new_side_data$handle() {
        return av_frame_new_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data(AVFrame *frame, enum AVFrameSideDataType type, size_t size)
     * }
     */
    public static MemorySegment av_frame_new_side_data$address() {
        return av_frame_new_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data(AVFrame *frame, enum AVFrameSideDataType type, size_t size)
     * }
     */
    public static MemorySegment av_frame_new_side_data(MemorySegment frame, int type, long size) {
        var mh$ = av_frame_new_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_new_side_data", frame, type, size);
            }
            return (MemorySegment)mh$.invokeExact(frame, type, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_new_side_data_from_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_new_side_data_from_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_frame_new_side_data_from_buf$descriptor() {
        return av_frame_new_side_data_from_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_frame_new_side_data_from_buf$handle() {
        return av_frame_new_side_data_from_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_frame_new_side_data_from_buf$address() {
        return av_frame_new_side_data_from_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_frame_new_side_data_from_buf(MemorySegment frame, int type, MemorySegment buf) {
        var mh$ = av_frame_new_side_data_from_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_new_side_data_from_buf", frame, type, buf);
            }
            return (MemorySegment)mh$.invokeExact(frame, type, buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_get_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_get_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_get_side_data(const AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_get_side_data$descriptor() {
        return av_frame_get_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_get_side_data(const AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_get_side_data$handle() {
        return av_frame_get_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_get_side_data(const AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_get_side_data$address() {
        return av_frame_get_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_get_side_data(const AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_get_side_data(MemorySegment frame, int type) {
        var mh$ = av_frame_get_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_get_side_data", frame, type);
            }
            return (MemorySegment)mh$.invokeExact(frame, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_remove_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_remove_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_remove_side_data$descriptor() {
        return av_frame_remove_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_remove_side_data$handle() {
        return av_frame_remove_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_remove_side_data$address() {
        return av_frame_remove_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static void av_frame_remove_side_data(MemorySegment frame, int type) {
        var mh$ = av_frame_remove_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_remove_side_data", frame, type);
            }
            mh$.invokeExact(frame, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_FRAME_CROP_UNALIGNED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_FRAME_CROP_UNALIGNED = 1
     * }
     */
    public static int AV_FRAME_CROP_UNALIGNED() {
        return AV_FRAME_CROP_UNALIGNED;
    }

    private static class av_frame_apply_cropping {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_apply_cropping");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_apply_cropping(AVFrame *frame, int flags)
     * }
     */
    public static FunctionDescriptor av_frame_apply_cropping$descriptor() {
        return av_frame_apply_cropping.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_apply_cropping(AVFrame *frame, int flags)
     * }
     */
    public static MethodHandle av_frame_apply_cropping$handle() {
        return av_frame_apply_cropping.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_apply_cropping(AVFrame *frame, int flags)
     * }
     */
    public static MemorySegment av_frame_apply_cropping$address() {
        return av_frame_apply_cropping.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_apply_cropping(AVFrame *frame, int flags)
     * }
     */
    public static int av_frame_apply_cropping(MemorySegment frame, int flags) {
        var mh$ = av_frame_apply_cropping.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_apply_cropping", frame, flags);
            }
            return (int)mh$.invokeExact(frame, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_frame_side_data_name(enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_name$descriptor() {
        return av_frame_side_data_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_frame_side_data_name(enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_side_data_name$handle() {
        return av_frame_side_data_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_frame_side_data_name(enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_name$address() {
        return av_frame_side_data_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_frame_side_data_name(enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_name(int type) {
        var mh$ = av_frame_side_data_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_name", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_desc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_desc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVSideDataDescriptor *av_frame_side_data_desc(enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_desc$descriptor() {
        return av_frame_side_data_desc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVSideDataDescriptor *av_frame_side_data_desc(enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_side_data_desc$handle() {
        return av_frame_side_data_desc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVSideDataDescriptor *av_frame_side_data_desc(enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_desc$address() {
        return av_frame_side_data_desc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVSideDataDescriptor *av_frame_side_data_desc(enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_desc(int type) {
        var mh$ = av_frame_side_data_desc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_desc", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_side_data_free(AVFrameSideData ***sd, int *nb_sd)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_free$descriptor() {
        return av_frame_side_data_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_side_data_free(AVFrameSideData ***sd, int *nb_sd)
     * }
     */
    public static MethodHandle av_frame_side_data_free$handle() {
        return av_frame_side_data_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_side_data_free(AVFrameSideData ***sd, int *nb_sd)
     * }
     */
    public static MemorySegment av_frame_side_data_free$address() {
        return av_frame_side_data_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_side_data_free(AVFrameSideData ***sd, int *nb_sd)
     * }
     */
    public static void av_frame_side_data_free(MemorySegment sd, MemorySegment nb_sd) {
        var mh$ = av_frame_side_data_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_free", sd, nb_sd);
            }
            mh$.invokeExact(sd, nb_sd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_new(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, size_t size, unsigned int flags)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_new$descriptor() {
        return av_frame_side_data_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_new(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, size_t size, unsigned int flags)
     * }
     */
    public static MethodHandle av_frame_side_data_new$handle() {
        return av_frame_side_data_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_new(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, size_t size, unsigned int flags)
     * }
     */
    public static MemorySegment av_frame_side_data_new$address() {
        return av_frame_side_data_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_new(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, size_t size, unsigned int flags)
     * }
     */
    public static MemorySegment av_frame_side_data_new(MemorySegment sd, MemorySegment nb_sd, int type, long size, int flags) {
        var mh$ = av_frame_side_data_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_new", sd, nb_sd, type, size, flags);
            }
            return (MemorySegment)mh$.invokeExact(sd, nb_sd, type, size, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_add(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, AVBufferRef **buf, unsigned int flags)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_add$descriptor() {
        return av_frame_side_data_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_add(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, AVBufferRef **buf, unsigned int flags)
     * }
     */
    public static MethodHandle av_frame_side_data_add$handle() {
        return av_frame_side_data_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_add(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, AVBufferRef **buf, unsigned int flags)
     * }
     */
    public static MemorySegment av_frame_side_data_add$address() {
        return av_frame_side_data_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_add(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, AVBufferRef **buf, unsigned int flags)
     * }
     */
    public static MemorySegment av_frame_side_data_add(MemorySegment sd, MemorySegment nb_sd, int type, MemorySegment buf, int flags) {
        var mh$ = av_frame_side_data_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_add", sd, nb_sd, type, buf, flags);
            }
            return (MemorySegment)mh$.invokeExact(sd, nb_sd, type, buf, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_side_data_clone(AVFrameSideData ***sd, int *nb_sd, const AVFrameSideData *src, unsigned int flags)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_clone$descriptor() {
        return av_frame_side_data_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_side_data_clone(AVFrameSideData ***sd, int *nb_sd, const AVFrameSideData *src, unsigned int flags)
     * }
     */
    public static MethodHandle av_frame_side_data_clone$handle() {
        return av_frame_side_data_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_side_data_clone(AVFrameSideData ***sd, int *nb_sd, const AVFrameSideData *src, unsigned int flags)
     * }
     */
    public static MemorySegment av_frame_side_data_clone$address() {
        return av_frame_side_data_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_side_data_clone(AVFrameSideData ***sd, int *nb_sd, const AVFrameSideData *src, unsigned int flags)
     * }
     */
    public static int av_frame_side_data_clone(MemorySegment sd, MemorySegment nb_sd, MemorySegment src, int flags) {
        var mh$ = av_frame_side_data_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_clone", sd, nb_sd, src, flags);
            }
            return (int)mh$.invokeExact(sd, nb_sd, src, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_get_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_get_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVFrameSideData *av_frame_side_data_get_c(const AVFrameSideData *const *sd, const int nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_get_c$descriptor() {
        return av_frame_side_data_get_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVFrameSideData *av_frame_side_data_get_c(const AVFrameSideData *const *sd, const int nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_side_data_get_c$handle() {
        return av_frame_side_data_get_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVFrameSideData *av_frame_side_data_get_c(const AVFrameSideData *const *sd, const int nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_get_c$address() {
        return av_frame_side_data_get_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVFrameSideData *av_frame_side_data_get_c(const AVFrameSideData *const *sd, const int nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_get_c(MemorySegment sd, int nb_sd, int type) {
        var mh$ = av_frame_side_data_get_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_get_c", sd, nb_sd, type);
            }
            return (MemorySegment)mh$.invokeExact(sd, nb_sd, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_side_data_remove(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_remove$descriptor() {
        return av_frame_side_data_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_side_data_remove(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_side_data_remove$handle() {
        return av_frame_side_data_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_side_data_remove(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_remove$address() {
        return av_frame_side_data_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_side_data_remove(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static void av_frame_side_data_remove(MemorySegment sd, MemorySegment nb_sd, int type) {
        var mh$ = av_frame_side_data_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_remove", sd, nb_sd, type);
            }
            mh$.invokeExact(sd, nb_sd, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_remove_by_props {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_remove_by_props");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_side_data_remove_by_props(AVFrameSideData ***sd, int *nb_sd, int props)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_remove_by_props$descriptor() {
        return av_frame_side_data_remove_by_props.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_side_data_remove_by_props(AVFrameSideData ***sd, int *nb_sd, int props)
     * }
     */
    public static MethodHandle av_frame_side_data_remove_by_props$handle() {
        return av_frame_side_data_remove_by_props.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_side_data_remove_by_props(AVFrameSideData ***sd, int *nb_sd, int props)
     * }
     */
    public static MemorySegment av_frame_side_data_remove_by_props$address() {
        return av_frame_side_data_remove_by_props.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_side_data_remove_by_props(AVFrameSideData ***sd, int *nb_sd, int props)
     * }
     */
    public static void av_frame_side_data_remove_by_props(MemorySegment sd, MemorySegment nb_sd, int props) {
        var mh$ = av_frame_side_data_remove_by_props.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_remove_by_props", sd, nb_sd, props);
            }
            mh$.invokeExact(sd, nb_sd, props);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_HWDEVICE_TYPE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_NONE = 0
     * }
     */
    public static int AV_HWDEVICE_TYPE_NONE() {
        return AV_HWDEVICE_TYPE_NONE;
    }
    private static final int AV_HWDEVICE_TYPE_VDPAU = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_VDPAU = 1
     * }
     */
    public static int AV_HWDEVICE_TYPE_VDPAU() {
        return AV_HWDEVICE_TYPE_VDPAU;
    }
}

