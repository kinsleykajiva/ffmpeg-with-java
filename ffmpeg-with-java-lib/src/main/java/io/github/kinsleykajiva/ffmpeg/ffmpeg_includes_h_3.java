// Generated by jextract

package io.github.kinsleykajiva.ffmpeg;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

class ffmpeg_includes_h_3 extends ffmpeg_includes_h$shared {

    ffmpeg_includes_h_3() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    private static final int _VCRT_COMPILER_PREPROCESSOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _VCRT_COMPILER_PREPROCESSOR 1
     * }
     */
    public static int _VCRT_COMPILER_PREPROCESSOR() {
        return _VCRT_COMPILER_PREPROCESSOR;
    }
    private static final int _SAL_VERSION = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SAL_VERSION 20
     * }
     */
    public static int _SAL_VERSION() {
        return _SAL_VERSION;
    }
    private static final int __SAL_H_VERSION = (int)180000000L;
    /**
     * {@snippet lang=c :
     * #define __SAL_H_VERSION 180000000
     * }
     */
    public static int __SAL_H_VERSION() {
        return __SAL_H_VERSION;
    }
    private static final int _USE_DECLSPECS_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_DECLSPECS_FOR_SAL 0
     * }
     */
    public static int _USE_DECLSPECS_FOR_SAL() {
        return _USE_DECLSPECS_FOR_SAL;
    }
    private static final int _USE_ATTRIBUTES_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_ATTRIBUTES_FOR_SAL 0
     * }
     */
    public static int _USE_ATTRIBUTES_FOR_SAL() {
        return _USE_ATTRIBUTES_FOR_SAL;
    }
    private static final int _CRT_PACKING = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _CRT_PACKING 8
     * }
     */
    public static int _CRT_PACKING() {
        return _CRT_PACKING;
    }
    private static final int _HAS_EXCEPTIONS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _HAS_EXCEPTIONS 1
     * }
     */
    public static int _HAS_EXCEPTIONS() {
        return _HAS_EXCEPTIONS;
    }
    private static final int _HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX17 0
     * }
     */
    public static int _HAS_CXX17() {
        return _HAS_CXX17;
    }
    private static final int _HAS_CXX20 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX20 0
     * }
     */
    public static int _HAS_CXX20() {
        return _HAS_CXX20;
    }
    private static final int _HAS_CXX23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX23 0
     * }
     */
    public static int _HAS_CXX23() {
        return _HAS_CXX23;
    }
    private static final int _HAS_CXX26 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX26 0
     * }
     */
    public static int _HAS_CXX26() {
        return _HAS_CXX26;
    }
    private static final int _HAS_NODISCARD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_NODISCARD 0
     * }
     */
    public static int _HAS_NODISCARD() {
        return _HAS_NODISCARD;
    }
    private static final int WCHAR_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN 0
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 65535
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 65535
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int FF_LAMBDA_SHIFT = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FF_LAMBDA_SHIFT 7
     * }
     */
    public static int FF_LAMBDA_SHIFT() {
        return FF_LAMBDA_SHIFT;
    }
    private static final int FF_QP2LAMBDA = (int)118L;
    /**
     * {@snippet lang=c :
     * #define FF_QP2LAMBDA 118
     * }
     */
    public static int FF_QP2LAMBDA() {
        return FF_QP2LAMBDA;
    }
    private static final int AV_TIME_BASE = (int)1000000L;
    /**
     * {@snippet lang=c :
     * #define AV_TIME_BASE 1000000
     * }
     */
    public static int AV_TIME_BASE() {
        return AV_TIME_BASE;
    }
    private static final int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 1
     * }
     */
    public static int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE() {
        return _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE;
    }
    private static final int _CRT_BUILD_DESKTOP_APP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_BUILD_DESKTOP_APP 1
     * }
     */
    public static int _CRT_BUILD_DESKTOP_APP() {
        return _CRT_BUILD_DESKTOP_APP;
    }
    private static final int _ARGMAX = (int)100L;
    /**
     * {@snippet lang=c :
     * #define _ARGMAX 100
     * }
     */
    public static int _ARGMAX() {
        return _ARGMAX;
    }
    private static final int _CRT_INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INT_MAX 2147483647
     * }
     */
    public static int _CRT_INT_MAX() {
        return _CRT_INT_MAX;
    }
    private static final int _CRT_FUNCTIONS_REQUIRED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_FUNCTIONS_REQUIRED 1
     * }
     */
    public static int _CRT_FUNCTIONS_REQUIRED() {
        return _CRT_FUNCTIONS_REQUIRED;
    }
    private static final int _CRT_HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_HAS_CXX17 0
     * }
     */
    public static int _CRT_HAS_CXX17() {
        return _CRT_HAS_CXX17;
    }
    private static final int _CRT_HAS_C11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_HAS_C11 1
     * }
     */
    public static int _CRT_HAS_C11() {
        return _CRT_HAS_C11;
    }
    private static final int _CRT_INTERNAL_NONSTDC_NAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_NONSTDC_NAMES 1
     * }
     */
    public static int _CRT_INTERNAL_NONSTDC_NAMES() {
        return _CRT_INTERNAL_NONSTDC_NAMES;
    }
    private static final int __STDC_WANT_SECURE_LIB__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_SECURE_LIB__ 1
     * }
     */
    public static int __STDC_WANT_SECURE_LIB__() {
        return __STDC_WANT_SECURE_LIB__;
    }
    private static final int _SECURECRT_FILL_BUFFER_PATTERN = (int)254L;
    /**
     * {@snippet lang=c :
     * #define _SECURECRT_FILL_BUFFER_PATTERN 254
     * }
     */
    public static int _SECURECRT_FILL_BUFFER_PATTERN() {
        return _SECURECRT_FILL_BUFFER_PATTERN;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 1
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY;
    }
    private static final int EPERM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EPERM 1
     * }
     */
    public static int EPERM() {
        return EPERM;
    }
    private static final int ENOENT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ENOENT 2
     * }
     */
    public static int ENOENT() {
        return ENOENT;
    }
    private static final int ESRCH = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ESRCH 3
     * }
     */
    public static int ESRCH() {
        return ESRCH;
    }
    private static final int EINTR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EINTR 4
     * }
     */
    public static int EINTR() {
        return EINTR;
    }
    private static final int EIO = (int)5L;
    /**
     * {@snippet lang=c :
     * #define EIO 5
     * }
     */
    public static int EIO() {
        return EIO;
    }
    private static final int ENXIO = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ENXIO 6
     * }
     */
    public static int ENXIO() {
        return ENXIO;
    }
    private static final int E2BIG = (int)7L;
    /**
     * {@snippet lang=c :
     * #define E2BIG 7
     * }
     */
    public static int E2BIG() {
        return E2BIG;
    }
    private static final int ENOEXEC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ENOEXEC 8
     * }
     */
    public static int ENOEXEC() {
        return ENOEXEC;
    }
    private static final int EBADF = (int)9L;
    /**
     * {@snippet lang=c :
     * #define EBADF 9
     * }
     */
    public static int EBADF() {
        return EBADF;
    }
    private static final int ECHILD = (int)10L;
    /**
     * {@snippet lang=c :
     * #define ECHILD 10
     * }
     */
    public static int ECHILD() {
        return ECHILD;
    }
    private static final int EAGAIN = (int)11L;
    /**
     * {@snippet lang=c :
     * #define EAGAIN 11
     * }
     */
    public static int EAGAIN() {
        return EAGAIN;
    }
    private static final int ENOMEM = (int)12L;
    /**
     * {@snippet lang=c :
     * #define ENOMEM 12
     * }
     */
    public static int ENOMEM() {
        return ENOMEM;
    }
    private static final int EACCES = (int)13L;
    /**
     * {@snippet lang=c :
     * #define EACCES 13
     * }
     */
    public static int EACCES() {
        return EACCES;
    }
    private static final int EFAULT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define EFAULT 14
     * }
     */
    public static int EFAULT() {
        return EFAULT;
    }
    private static final int EBUSY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EBUSY 16
     * }
     */
    public static int EBUSY() {
        return EBUSY;
    }
    private static final int EEXIST = (int)17L;
    /**
     * {@snippet lang=c :
     * #define EEXIST 17
     * }
     */
    public static int EEXIST() {
        return EEXIST;
    }
    private static final int EXDEV = (int)18L;
    /**
     * {@snippet lang=c :
     * #define EXDEV 18
     * }
     */
    public static int EXDEV() {
        return EXDEV;
    }
    private static final int ENODEV = (int)19L;
    /**
     * {@snippet lang=c :
     * #define ENODEV 19
     * }
     */
    public static int ENODEV() {
        return ENODEV;
    }
    private static final int ENOTDIR = (int)20L;
    /**
     * {@snippet lang=c :
     * #define ENOTDIR 20
     * }
     */
    public static int ENOTDIR() {
        return ENOTDIR;
    }
    private static final int EISDIR = (int)21L;
    /**
     * {@snippet lang=c :
     * #define EISDIR 21
     * }
     */
    public static int EISDIR() {
        return EISDIR;
    }
    private static final int ENFILE = (int)23L;
    /**
     * {@snippet lang=c :
     * #define ENFILE 23
     * }
     */
    public static int ENFILE() {
        return ENFILE;
    }
    private static final int EMFILE = (int)24L;
    /**
     * {@snippet lang=c :
     * #define EMFILE 24
     * }
     */
    public static int EMFILE() {
        return EMFILE;
    }
    private static final int ENOTTY = (int)25L;
    /**
     * {@snippet lang=c :
     * #define ENOTTY 25
     * }
     */
    public static int ENOTTY() {
        return ENOTTY;
    }
    private static final int EFBIG = (int)27L;
    /**
     * {@snippet lang=c :
     * #define EFBIG 27
     * }
     */
    public static int EFBIG() {
        return EFBIG;
    }
    private static final int ENOSPC = (int)28L;
    /**
     * {@snippet lang=c :
     * #define ENOSPC 28
     * }
     */
    public static int ENOSPC() {
        return ENOSPC;
    }
    private static final int ESPIPE = (int)29L;
    /**
     * {@snippet lang=c :
     * #define ESPIPE 29
     * }
     */
    public static int ESPIPE() {
        return ESPIPE;
    }
    private static final int EROFS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define EROFS 30
     * }
     */
    public static int EROFS() {
        return EROFS;
    }
    private static final int EMLINK = (int)31L;
    /**
     * {@snippet lang=c :
     * #define EMLINK 31
     * }
     */
    public static int EMLINK() {
        return EMLINK;
    }
    private static final int EPIPE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EPIPE 32
     * }
     */
    public static int EPIPE() {
        return EPIPE;
    }
    private static final int EDOM = (int)33L;
    /**
     * {@snippet lang=c :
     * #define EDOM 33
     * }
     */
    public static int EDOM() {
        return EDOM;
    }
    private static final int EDEADLK = (int)36L;
    /**
     * {@snippet lang=c :
     * #define EDEADLK 36
     * }
     */
    public static int EDEADLK() {
        return EDEADLK;
    }
    private static final int ENAMETOOLONG = (int)38L;
    /**
     * {@snippet lang=c :
     * #define ENAMETOOLONG 38
     * }
     */
    public static int ENAMETOOLONG() {
        return ENAMETOOLONG;
    }
    private static final int ENOLCK = (int)39L;
    /**
     * {@snippet lang=c :
     * #define ENOLCK 39
     * }
     */
    public static int ENOLCK() {
        return ENOLCK;
    }
    private static final int ENOSYS = (int)40L;
    /**
     * {@snippet lang=c :
     * #define ENOSYS 40
     * }
     */
    public static int ENOSYS() {
        return ENOSYS;
    }
    private static final int ENOTEMPTY = (int)41L;
    /**
     * {@snippet lang=c :
     * #define ENOTEMPTY 41
     * }
     */
    public static int ENOTEMPTY() {
        return ENOTEMPTY;
    }
    private static final int EINVAL = (int)22L;
    /**
     * {@snippet lang=c :
     * #define EINVAL 22
     * }
     */
    public static int EINVAL() {
        return EINVAL;
    }
    private static final int ERANGE = (int)34L;
    /**
     * {@snippet lang=c :
     * #define ERANGE 34
     * }
     */
    public static int ERANGE() {
        return ERANGE;
    }
    private static final int EILSEQ = (int)42L;
    /**
     * {@snippet lang=c :
     * #define EILSEQ 42
     * }
     */
    public static int EILSEQ() {
        return EILSEQ;
    }
    private static final int STRUNCATE = (int)80L;
    /**
     * {@snippet lang=c :
     * #define STRUNCATE 80
     * }
     */
    public static int STRUNCATE() {
        return STRUNCATE;
    }
    private static final int EADDRINUSE = (int)100L;
    /**
     * {@snippet lang=c :
     * #define EADDRINUSE 100
     * }
     */
    public static int EADDRINUSE() {
        return EADDRINUSE;
    }
    private static final int EADDRNOTAVAIL = (int)101L;
    /**
     * {@snippet lang=c :
     * #define EADDRNOTAVAIL 101
     * }
     */
    public static int EADDRNOTAVAIL() {
        return EADDRNOTAVAIL;
    }
    private static final int EAFNOSUPPORT = (int)102L;
    /**
     * {@snippet lang=c :
     * #define EAFNOSUPPORT 102
     * }
     */
    public static int EAFNOSUPPORT() {
        return EAFNOSUPPORT;
    }
    private static final int EALREADY = (int)103L;
    /**
     * {@snippet lang=c :
     * #define EALREADY 103
     * }
     */
    public static int EALREADY() {
        return EALREADY;
    }
    private static final int EBADMSG = (int)104L;
    /**
     * {@snippet lang=c :
     * #define EBADMSG 104
     * }
     */
    public static int EBADMSG() {
        return EBADMSG;
    }
    private static final int ECANCELED = (int)105L;
    /**
     * {@snippet lang=c :
     * #define ECANCELED 105
     * }
     */
    public static int ECANCELED() {
        return ECANCELED;
    }
    private static final int ECONNABORTED = (int)106L;
    /**
     * {@snippet lang=c :
     * #define ECONNABORTED 106
     * }
     */
    public static int ECONNABORTED() {
        return ECONNABORTED;
    }
    private static final int ECONNREFUSED = (int)107L;
    /**
     * {@snippet lang=c :
     * #define ECONNREFUSED 107
     * }
     */
    public static int ECONNREFUSED() {
        return ECONNREFUSED;
    }
    private static final int ECONNRESET = (int)108L;
    /**
     * {@snippet lang=c :
     * #define ECONNRESET 108
     * }
     */
    public static int ECONNRESET() {
        return ECONNRESET;
    }
    private static final int EDESTADDRREQ = (int)109L;
    /**
     * {@snippet lang=c :
     * #define EDESTADDRREQ 109
     * }
     */
    public static int EDESTADDRREQ() {
        return EDESTADDRREQ;
    }
    private static final int EHOSTUNREACH = (int)110L;
    /**
     * {@snippet lang=c :
     * #define EHOSTUNREACH 110
     * }
     */
    public static int EHOSTUNREACH() {
        return EHOSTUNREACH;
    }
    private static final int EIDRM = (int)111L;
    /**
     * {@snippet lang=c :
     * #define EIDRM 111
     * }
     */
    public static int EIDRM() {
        return EIDRM;
    }
    private static final int EINPROGRESS = (int)112L;
    /**
     * {@snippet lang=c :
     * #define EINPROGRESS 112
     * }
     */
    public static int EINPROGRESS() {
        return EINPROGRESS;
    }
    private static final int EISCONN = (int)113L;
    /**
     * {@snippet lang=c :
     * #define EISCONN 113
     * }
     */
    public static int EISCONN() {
        return EISCONN;
    }
    private static final int ELOOP = (int)114L;
    /**
     * {@snippet lang=c :
     * #define ELOOP 114
     * }
     */
    public static int ELOOP() {
        return ELOOP;
    }
    private static final int EMSGSIZE = (int)115L;
    /**
     * {@snippet lang=c :
     * #define EMSGSIZE 115
     * }
     */
    public static int EMSGSIZE() {
        return EMSGSIZE;
    }
    private static final int ENETDOWN = (int)116L;
    /**
     * {@snippet lang=c :
     * #define ENETDOWN 116
     * }
     */
    public static int ENETDOWN() {
        return ENETDOWN;
    }
    private static final int ENETRESET = (int)117L;
    /**
     * {@snippet lang=c :
     * #define ENETRESET 117
     * }
     */
    public static int ENETRESET() {
        return ENETRESET;
    }
    private static final int ENETUNREACH = (int)118L;
    /**
     * {@snippet lang=c :
     * #define ENETUNREACH 118
     * }
     */
    public static int ENETUNREACH() {
        return ENETUNREACH;
    }
    private static final int ENOBUFS = (int)119L;
    /**
     * {@snippet lang=c :
     * #define ENOBUFS 119
     * }
     */
    public static int ENOBUFS() {
        return ENOBUFS;
    }
    private static final int ENODATA = (int)120L;
    /**
     * {@snippet lang=c :
     * #define ENODATA 120
     * }
     */
    public static int ENODATA() {
        return ENODATA;
    }
    private static final int ENOLINK = (int)121L;
    /**
     * {@snippet lang=c :
     * #define ENOLINK 121
     * }
     */
    public static int ENOLINK() {
        return ENOLINK;
    }
    private static final int ENOMSG = (int)122L;
    /**
     * {@snippet lang=c :
     * #define ENOMSG 122
     * }
     */
    public static int ENOMSG() {
        return ENOMSG;
    }
    private static final int ENOPROTOOPT = (int)123L;
    /**
     * {@snippet lang=c :
     * #define ENOPROTOOPT 123
     * }
     */
    public static int ENOPROTOOPT() {
        return ENOPROTOOPT;
    }
    private static final int ENOSR = (int)124L;
    /**
     * {@snippet lang=c :
     * #define ENOSR 124
     * }
     */
    public static int ENOSR() {
        return ENOSR;
    }
    private static final int ENOSTR = (int)125L;
    /**
     * {@snippet lang=c :
     * #define ENOSTR 125
     * }
     */
    public static int ENOSTR() {
        return ENOSTR;
    }
    private static final int ENOTCONN = (int)126L;
    /**
     * {@snippet lang=c :
     * #define ENOTCONN 126
     * }
     */
    public static int ENOTCONN() {
        return ENOTCONN;
    }
    private static final int ENOTRECOVERABLE = (int)127L;
    /**
     * {@snippet lang=c :
     * #define ENOTRECOVERABLE 127
     * }
     */
    public static int ENOTRECOVERABLE() {
        return ENOTRECOVERABLE;
    }
    private static final int ENOTSOCK = (int)128L;
    /**
     * {@snippet lang=c :
     * #define ENOTSOCK 128
     * }
     */
    public static int ENOTSOCK() {
        return ENOTSOCK;
    }
    private static final int ENOTSUP = (int)129L;
    /**
     * {@snippet lang=c :
     * #define ENOTSUP 129
     * }
     */
    public static int ENOTSUP() {
        return ENOTSUP;
    }
    private static final int EOPNOTSUPP = (int)130L;
    /**
     * {@snippet lang=c :
     * #define EOPNOTSUPP 130
     * }
     */
    public static int EOPNOTSUPP() {
        return EOPNOTSUPP;
    }
    private static final int EOTHER = (int)131L;
    /**
     * {@snippet lang=c :
     * #define EOTHER 131
     * }
     */
    public static int EOTHER() {
        return EOTHER;
    }
    private static final int EOVERFLOW = (int)132L;
    /**
     * {@snippet lang=c :
     * #define EOVERFLOW 132
     * }
     */
    public static int EOVERFLOW() {
        return EOVERFLOW;
    }
    private static final int EOWNERDEAD = (int)133L;
    /**
     * {@snippet lang=c :
     * #define EOWNERDEAD 133
     * }
     */
    public static int EOWNERDEAD() {
        return EOWNERDEAD;
    }
    private static final int EPROTO = (int)134L;
    /**
     * {@snippet lang=c :
     * #define EPROTO 134
     * }
     */
    public static int EPROTO() {
        return EPROTO;
    }
    private static final int EPROTONOSUPPORT = (int)135L;
    /**
     * {@snippet lang=c :
     * #define EPROTONOSUPPORT 135
     * }
     */
    public static int EPROTONOSUPPORT() {
        return EPROTONOSUPPORT;
    }
    private static final int EPROTOTYPE = (int)136L;
    /**
     * {@snippet lang=c :
     * #define EPROTOTYPE 136
     * }
     */
    public static int EPROTOTYPE() {
        return EPROTOTYPE;
    }
    private static final int ETIME = (int)137L;
    /**
     * {@snippet lang=c :
     * #define ETIME 137
     * }
     */
    public static int ETIME() {
        return ETIME;
    }
    private static final int ETIMEDOUT = (int)138L;
    /**
     * {@snippet lang=c :
     * #define ETIMEDOUT 138
     * }
     */
    public static int ETIMEDOUT() {
        return ETIMEDOUT;
    }
    private static final int ETXTBSY = (int)139L;
    /**
     * {@snippet lang=c :
     * #define ETXTBSY 139
     * }
     */
    public static int ETXTBSY() {
        return ETXTBSY;
    }
    private static final int EWOULDBLOCK = (int)140L;
    /**
     * {@snippet lang=c :
     * #define EWOULDBLOCK 140
     * }
     */
    public static int EWOULDBLOCK() {
        return EWOULDBLOCK;
    }
    private static final int CHAR_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CHAR_BIT 8
     * }
     */
    public static int CHAR_BIT() {
        return CHAR_BIT;
    }
    private static final int SCHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MAX 127
     * }
     */
    public static int SCHAR_MAX() {
        return SCHAR_MAX;
    }
    private static final int UCHAR_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UCHAR_MAX 255
     * }
     */
    public static int UCHAR_MAX() {
        return UCHAR_MAX;
    }
    private static final int MB_LEN_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define MB_LEN_MAX 5
     * }
     */
    public static int MB_LEN_MAX() {
        return MB_LEN_MAX;
    }
    private static final int SHRT_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MAX 32767
     * }
     */
    public static int SHRT_MAX() {
        return SHRT_MAX;
    }
    private static final int USHRT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define USHRT_MAX 65535
     * }
     */
    public static int USHRT_MAX() {
        return USHRT_MAX;
    }
    private static final int INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_MAX 2147483647
     * }
     */
    public static int INT_MAX() {
        return INT_MAX;
    }
    private static final int _DOMAIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DOMAIN 1
     * }
     */
    public static int _DOMAIN() {
        return _DOMAIN;
    }
    private static final int _SING = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _SING 2
     * }
     */
    public static int _SING() {
        return _SING;
    }
    private static final int _OVERFLOW = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _OVERFLOW 3
     * }
     */
    public static int _OVERFLOW() {
        return _OVERFLOW;
    }
    private static final int _UNDERFLOW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _UNDERFLOW 4
     * }
     */
    public static int _UNDERFLOW() {
        return _UNDERFLOW;
    }
    private static final int _TLOSS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _TLOSS 5
     * }
     */
    public static int _TLOSS() {
        return _TLOSS;
    }
    private static final int _PLOSS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _PLOSS 6
     * }
     */
    public static int _PLOSS() {
        return _PLOSS;
    }
    private static final int _INFCODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _INFCODE 1
     * }
     */
    public static int _INFCODE() {
        return _INFCODE;
    }
    private static final int _NANCODE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _NANCODE 2
     * }
     */
    public static int _NANCODE() {
        return _NANCODE;
    }
    private static final int FP_ZERO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FP_ZERO 0
     * }
     */
    public static int FP_ZERO() {
        return FP_ZERO;
    }
    private static final int _C2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _C2 1
     * }
     */
    public static int _C2() {
        return _C2;
    }
    private static final int FP_ILOGBNAN = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define FP_ILOGBNAN 2147483647
     * }
     */
    public static int FP_ILOGBNAN() {
        return FP_ILOGBNAN;
    }
    private static final int MATH_ERRNO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MATH_ERRNO 1
     * }
     */
    public static int MATH_ERRNO() {
        return MATH_ERRNO;
    }
    private static final int MATH_ERREXCEPT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MATH_ERREXCEPT 2
     * }
     */
    public static int MATH_ERREXCEPT() {
        return MATH_ERREXCEPT;
    }
    private static final int _FE_DIVBYZERO = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _FE_DIVBYZERO 4
     * }
     */
    public static int _FE_DIVBYZERO() {
        return _FE_DIVBYZERO;
    }
    private static final int _FE_INEXACT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _FE_INEXACT 32
     * }
     */
    public static int _FE_INEXACT() {
        return _FE_INEXACT;
    }
    private static final int _FE_INVALID = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FE_INVALID 1
     * }
     */
    public static int _FE_INVALID() {
        return _FE_INVALID;
    }
    private static final int _FE_OVERFLOW = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _FE_OVERFLOW 8
     * }
     */
    public static int _FE_OVERFLOW() {
        return _FE_OVERFLOW;
    }
    private static final int _FE_UNDERFLOW = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _FE_UNDERFLOW 16
     * }
     */
    public static int _FE_UNDERFLOW() {
        return _FE_UNDERFLOW;
    }
    private static final int _D0_C = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _D0_C 3
     * }
     */
    public static int _D0_C() {
        return _D0_C;
    }
    private static final int _D1_C = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _D1_C 2
     * }
     */
    public static int _D1_C() {
        return _D1_C;
    }
    private static final int _D2_C = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _D2_C 1
     * }
     */
    public static int _D2_C() {
        return _D2_C;
    }
    private static final int _D3_C = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _D3_C 0
     * }
     */
    public static int _D3_C() {
        return _D3_C;
    }
    private static final int _DBIAS = (int)1022L;
    /**
     * {@snippet lang=c :
     * #define _DBIAS 1022
     * }
     */
    public static int _DBIAS() {
        return _DBIAS;
    }
    private static final int _DOFF = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _DOFF 4
     * }
     */
    public static int _DOFF() {
        return _DOFF;
    }
    private static final int _F0_C = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _F0_C 1
     * }
     */
    public static int _F0_C() {
        return _F0_C;
    }
    private static final int _F1_C = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _F1_C 0
     * }
     */
    public static int _F1_C() {
        return _F1_C;
    }
    private static final int _FBIAS = (int)126L;
    /**
     * {@snippet lang=c :
     * #define _FBIAS 126
     * }
     */
    public static int _FBIAS() {
        return _FBIAS;
    }
    private static final int _FOFF = (int)7L;
    /**
     * {@snippet lang=c :
     * #define _FOFF 7
     * }
     */
    public static int _FOFF() {
        return _FOFF;
    }
    private static final int _FRND = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FRND 1
     * }
     */
    public static int _FRND() {
        return _FRND;
    }
    private static final int _L0_C = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _L0_C 3
     * }
     */
    public static int _L0_C() {
        return _L0_C;
    }
    private static final int _L1_C = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _L1_C 2
     * }
     */
    public static int _L1_C() {
        return _L1_C;
    }
    private static final int _L2_C = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _L2_C 1
     * }
     */
    public static int _L2_C() {
        return _L2_C;
    }
    private static final int _L3_C = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _L3_C 0
     * }
     */
    public static int _L3_C() {
        return _L3_C;
    }
    private static final int _LBIAS = (int)1022L;
    /**
     * {@snippet lang=c :
     * #define _LBIAS 1022
     * }
     */
    public static int _LBIAS() {
        return _LBIAS;
    }
    private static final int _LOFF = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _LOFF 4
     * }
     */
    public static int _LOFF() {
        return _LOFF;
    }
    private static final int _FP_LT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FP_LT 1
     * }
     */
    public static int _FP_LT() {
        return _FP_LT;
    }
    private static final int _FP_EQ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _FP_EQ 2
     * }
     */
    public static int _FP_EQ() {
        return _FP_EQ;
    }
    private static final int _FP_GT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _FP_GT 4
     * }
     */
    public static int _FP_GT() {
        return _FP_GT;
    }
    private static final int BUFSIZ = (int)512L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 512
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int _NSTREAM_ = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _NSTREAM_ 512
     * }
     */
    public static int _NSTREAM_() {
        return _NSTREAM_;
    }
    private static final int _IOB_ENTRIES = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _IOB_ENTRIES 3
     * }
     */
    public static int _IOB_ENTRIES() {
        return _IOB_ENTRIES;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 64
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 4
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int L_tmpnam = (int)260L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 260
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int FILENAME_MAX = (int)260L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 260
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int FOPEN_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 20
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int _SYS_OPEN = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SYS_OPEN 20
     * }
     */
    public static int _SYS_OPEN() {
        return _SYS_OPEN;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int _WRITE_ABORT_MSG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _WRITE_ABORT_MSG 1
     * }
     */
    public static int _WRITE_ABORT_MSG() {
        return _WRITE_ABORT_MSG;
    }
    private static final int _CALL_REPORTFAULT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _CALL_REPORTFAULT 2
     * }
     */
    public static int _CALL_REPORTFAULT() {
        return _CALL_REPORTFAULT;
    }
    private static final int _OUT_TO_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _OUT_TO_DEFAULT 0
     * }
     */
    public static int _OUT_TO_DEFAULT() {
        return _OUT_TO_DEFAULT;
    }
    private static final int _OUT_TO_STDERR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _OUT_TO_STDERR 1
     * }
     */
    public static int _OUT_TO_STDERR() {
        return _OUT_TO_STDERR;
    }
    private static final int _OUT_TO_MSGBOX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _OUT_TO_MSGBOX 2
     * }
     */
    public static int _OUT_TO_MSGBOX() {
        return _OUT_TO_MSGBOX;
    }
    private static final int _REPORT_ERRMODE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _REPORT_ERRMODE 3
     * }
     */
    public static int _REPORT_ERRMODE() {
        return _REPORT_ERRMODE;
    }
    private static final int RAND_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 32767
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int _MAX_PATH = (int)260L;
    /**
     * {@snippet lang=c :
     * #define _MAX_PATH 260
     * }
     */
    public static int _MAX_PATH() {
        return _MAX_PATH;
    }
    private static final int _MAX_DRIVE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _MAX_DRIVE 3
     * }
     */
    public static int _MAX_DRIVE() {
        return _MAX_DRIVE;
    }
    private static final int _MAX_DIR = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _MAX_DIR 256
     * }
     */
    public static int _MAX_DIR() {
        return _MAX_DIR;
    }
    private static final int _MAX_FNAME = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _MAX_FNAME 256
     * }
     */
    public static int _MAX_FNAME() {
        return _MAX_FNAME;
    }
    private static final int _MAX_EXT = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _MAX_EXT 256
     * }
     */
    public static int _MAX_EXT() {
        return _MAX_EXT;
    }
    private static final int _MAX_ENV = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ENV 32767
     * }
     */
    public static int _MAX_ENV() {
        return _MAX_ENV;
    }
    private static final int AV_HAVE_BIGENDIAN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_HAVE_BIGENDIAN 0
     * }
     */
    public static int AV_HAVE_BIGENDIAN() {
        return AV_HAVE_BIGENDIAN;
    }
    private static final int AV_HAVE_FAST_UNALIGNED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_HAVE_FAST_UNALIGNED 1
     * }
     */
    public static int AV_HAVE_FAST_UNALIGNED() {
        return AV_HAVE_FAST_UNALIGNED;
    }
    private static final int AV_ERROR_MAX_STRING_SIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AV_ERROR_MAX_STRING_SIZE 64
     * }
     */
    public static int AV_ERROR_MAX_STRING_SIZE() {
        return AV_ERROR_MAX_STRING_SIZE;
    }
    private static final int LIBAVUTIL_VERSION_MAJOR = (int)60L;
    /**
     * {@snippet lang=c :
     * #define LIBAVUTIL_VERSION_MAJOR 60
     * }
     */
    public static int LIBAVUTIL_VERSION_MAJOR() {
        return LIBAVUTIL_VERSION_MAJOR;
    }
    private static final int LIBAVUTIL_VERSION_MINOR = (int)25L;
    /**
     * {@snippet lang=c :
     * #define LIBAVUTIL_VERSION_MINOR 25
     * }
     */
    public static int LIBAVUTIL_VERSION_MINOR() {
        return LIBAVUTIL_VERSION_MINOR;
    }
    private static final int LIBAVUTIL_VERSION_MICRO = (int)100L;
    /**
     * {@snippet lang=c :
     * #define LIBAVUTIL_VERSION_MICRO 100
     * }
     */
    public static int LIBAVUTIL_VERSION_MICRO() {
        return LIBAVUTIL_VERSION_MICRO;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int AV_LOG_PANIC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_PANIC 0
     * }
     */
    public static int AV_LOG_PANIC() {
        return AV_LOG_PANIC;
    }
    private static final int AV_LOG_FATAL = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_FATAL 8
     * }
     */
    public static int AV_LOG_FATAL() {
        return AV_LOG_FATAL;
    }
    private static final int AV_LOG_ERROR = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_ERROR 16
     * }
     */
    public static int AV_LOG_ERROR() {
        return AV_LOG_ERROR;
    }
    private static final int AV_LOG_WARNING = (int)24L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_WARNING 24
     * }
     */
    public static int AV_LOG_WARNING() {
        return AV_LOG_WARNING;
    }
    private static final int AV_LOG_INFO = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_INFO 32
     * }
     */
    public static int AV_LOG_INFO() {
        return AV_LOG_INFO;
    }
    private static final int AV_LOG_VERBOSE = (int)40L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_VERBOSE 40
     * }
     */
    public static int AV_LOG_VERBOSE() {
        return AV_LOG_VERBOSE;
    }
    private static final int AV_LOG_DEBUG = (int)48L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_DEBUG 48
     * }
     */
    public static int AV_LOG_DEBUG() {
        return AV_LOG_DEBUG;
    }
    private static final int AV_LOG_TRACE = (int)56L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_TRACE 56
     * }
     */
    public static int AV_LOG_TRACE() {
        return AV_LOG_TRACE;
    }
    private static final int AV_LOG_SKIP_REPEATED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_SKIP_REPEATED 1
     * }
     */
    public static int AV_LOG_SKIP_REPEATED() {
        return AV_LOG_SKIP_REPEATED;
    }
    private static final int AV_LOG_PRINT_LEVEL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_PRINT_LEVEL 2
     * }
     */
    public static int AV_LOG_PRINT_LEVEL() {
        return AV_LOG_PRINT_LEVEL;
    }
    private static final int AV_LOG_PRINT_TIME = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_PRINT_TIME 4
     * }
     */
    public static int AV_LOG_PRINT_TIME() {
        return AV_LOG_PRINT_TIME;
    }
    private static final int AV_LOG_PRINT_DATETIME = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_PRINT_DATETIME 8
     * }
     */
    public static int AV_LOG_PRINT_DATETIME() {
        return AV_LOG_PRINT_DATETIME;
    }
    private static final int AVPALETTE_SIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define AVPALETTE_SIZE 1024
     * }
     */
    public static int AVPALETTE_SIZE() {
        return AVPALETTE_SIZE;
    }
    private static final int AVPALETTE_COUNT = (int)256L;
    /**
     * {@snippet lang=c :
     * #define AVPALETTE_COUNT 256
     * }
     */
    public static int AVPALETTE_COUNT() {
        return AVPALETTE_COUNT;
    }
    private static final int AV_VIDEO_MAX_PLANES = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_VIDEO_MAX_PLANES 4
     * }
     */
    public static int AV_VIDEO_MAX_PLANES() {
        return AV_VIDEO_MAX_PLANES;
    }
    private static final int AV_FOURCC_MAX_STRING_SIZE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AV_FOURCC_MAX_STRING_SIZE 32
     * }
     */
    public static int AV_FOURCC_MAX_STRING_SIZE() {
        return AV_FOURCC_MAX_STRING_SIZE;
    }
    private static final int AV_DICT_MATCH_CASE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_MATCH_CASE 1
     * }
     */
    public static int AV_DICT_MATCH_CASE() {
        return AV_DICT_MATCH_CASE;
    }
    private static final int AV_DICT_IGNORE_SUFFIX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_IGNORE_SUFFIX 2
     * }
     */
    public static int AV_DICT_IGNORE_SUFFIX() {
        return AV_DICT_IGNORE_SUFFIX;
    }
    private static final int AV_DICT_DONT_STRDUP_KEY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_DONT_STRDUP_KEY 4
     * }
     */
    public static int AV_DICT_DONT_STRDUP_KEY() {
        return AV_DICT_DONT_STRDUP_KEY;
    }
    private static final int AV_DICT_DONT_STRDUP_VAL = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_DONT_STRDUP_VAL 8
     * }
     */
    public static int AV_DICT_DONT_STRDUP_VAL() {
        return AV_DICT_DONT_STRDUP_VAL;
    }
    private static final int AV_DICT_DONT_OVERWRITE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_DONT_OVERWRITE 16
     * }
     */
    public static int AV_DICT_DONT_OVERWRITE() {
        return AV_DICT_DONT_OVERWRITE;
    }
    private static final int AV_DICT_APPEND = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_APPEND 32
     * }
     */
    public static int AV_DICT_APPEND() {
        return AV_DICT_APPEND;
    }
    private static final int AV_DICT_MULTIKEY = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_MULTIKEY 64
     * }
     */
    public static int AV_DICT_MULTIKEY() {
        return AV_DICT_MULTIKEY;
    }
    private static final int AV_DICT_DEDUP = (int)128L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_DEDUP 128
     * }
     */
    public static int AV_DICT_DEDUP() {
        return AV_DICT_DEDUP;
    }
    private static final int AV_NUM_DATA_POINTERS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_NUM_DATA_POINTERS 8
     * }
     */
    public static int AV_NUM_DATA_POINTERS() {
        return AV_NUM_DATA_POINTERS;
    }
    private static final int FF_DECODE_ERROR_INVALID_BITSTREAM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_DECODE_ERROR_INVALID_BITSTREAM 1
     * }
     */
    public static int FF_DECODE_ERROR_INVALID_BITSTREAM() {
        return FF_DECODE_ERROR_INVALID_BITSTREAM;
    }
    private static final int FF_DECODE_ERROR_MISSING_REFERENCE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_DECODE_ERROR_MISSING_REFERENCE 2
     * }
     */
    public static int FF_DECODE_ERROR_MISSING_REFERENCE() {
        return FF_DECODE_ERROR_MISSING_REFERENCE;
    }
    private static final int FF_DECODE_ERROR_CONCEALMENT_ACTIVE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_DECODE_ERROR_CONCEALMENT_ACTIVE 4
     * }
     */
    public static int FF_DECODE_ERROR_CONCEALMENT_ACTIVE() {
        return FF_DECODE_ERROR_CONCEALMENT_ACTIVE;
    }
    private static final int FF_DECODE_ERROR_DECODE_SLICES = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_DECODE_ERROR_DECODE_SLICES 8
     * }
     */
    public static int FF_DECODE_ERROR_DECODE_SLICES() {
        return FF_DECODE_ERROR_DECODE_SLICES;
    }
    private static final int LIBAVCODEC_VERSION_MAJOR = (int)62L;
    /**
     * {@snippet lang=c :
     * #define LIBAVCODEC_VERSION_MAJOR 62
     * }
     */
    public static int LIBAVCODEC_VERSION_MAJOR() {
        return LIBAVCODEC_VERSION_MAJOR;
    }
    private static final int AV_INPUT_BUFFER_PADDING_SIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AV_INPUT_BUFFER_PADDING_SIZE 64
     * }
     */
    public static int AV_INPUT_BUFFER_PADDING_SIZE() {
        return AV_INPUT_BUFFER_PADDING_SIZE;
    }
    private static final int FF_COMPLIANCE_VERY_STRICT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_COMPLIANCE_VERY_STRICT 2
     * }
     */
    public static int FF_COMPLIANCE_VERY_STRICT() {
        return FF_COMPLIANCE_VERY_STRICT;
    }
    private static final int FF_COMPLIANCE_STRICT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_COMPLIANCE_STRICT 1
     * }
     */
    public static int FF_COMPLIANCE_STRICT() {
        return FF_COMPLIANCE_STRICT;
    }
    private static final int FF_COMPLIANCE_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_COMPLIANCE_NORMAL 0
     * }
     */
    public static int FF_COMPLIANCE_NORMAL() {
        return FF_COMPLIANCE_NORMAL;
    }
    private static final int AV_PROFILE_AAC_MAIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_MAIN 0
     * }
     */
    public static int AV_PROFILE_AAC_MAIN() {
        return AV_PROFILE_AAC_MAIN;
    }
    private static final int AV_PROFILE_AAC_LOW = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_LOW 1
     * }
     */
    public static int AV_PROFILE_AAC_LOW() {
        return AV_PROFILE_AAC_LOW;
    }
    private static final int AV_PROFILE_AAC_SSR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_SSR 2
     * }
     */
    public static int AV_PROFILE_AAC_SSR() {
        return AV_PROFILE_AAC_SSR;
    }
    private static final int AV_PROFILE_AAC_LTP = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_LTP 3
     * }
     */
    public static int AV_PROFILE_AAC_LTP() {
        return AV_PROFILE_AAC_LTP;
    }
    private static final int AV_PROFILE_AAC_HE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_HE 4
     * }
     */
    public static int AV_PROFILE_AAC_HE() {
        return AV_PROFILE_AAC_HE;
    }
    private static final int AV_PROFILE_AAC_HE_V2 = (int)28L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_HE_V2 28
     * }
     */
    public static int AV_PROFILE_AAC_HE_V2() {
        return AV_PROFILE_AAC_HE_V2;
    }
    private static final int AV_PROFILE_AAC_LD = (int)22L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_LD 22
     * }
     */
    public static int AV_PROFILE_AAC_LD() {
        return AV_PROFILE_AAC_LD;
    }
    private static final int AV_PROFILE_AAC_ELD = (int)38L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_ELD 38
     * }
     */
    public static int AV_PROFILE_AAC_ELD() {
        return AV_PROFILE_AAC_ELD;
    }
    private static final int AV_PROFILE_AAC_USAC = (int)41L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AAC_USAC 41
     * }
     */
    public static int AV_PROFILE_AAC_USAC() {
        return AV_PROFILE_AAC_USAC;
    }
    private static final int AV_PROFILE_MPEG2_AAC_LOW = (int)128L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_AAC_LOW 128
     * }
     */
    public static int AV_PROFILE_MPEG2_AAC_LOW() {
        return AV_PROFILE_MPEG2_AAC_LOW;
    }
    private static final int AV_PROFILE_MPEG2_AAC_HE = (int)131L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_AAC_HE 131
     * }
     */
    public static int AV_PROFILE_MPEG2_AAC_HE() {
        return AV_PROFILE_MPEG2_AAC_HE;
    }
    private static final int AV_PROFILE_DNXHD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DNXHD 0
     * }
     */
    public static int AV_PROFILE_DNXHD() {
        return AV_PROFILE_DNXHD;
    }
    private static final int AV_PROFILE_DNXHR_LB = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DNXHR_LB 1
     * }
     */
    public static int AV_PROFILE_DNXHR_LB() {
        return AV_PROFILE_DNXHR_LB;
    }
    private static final int AV_PROFILE_DNXHR_SQ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DNXHR_SQ 2
     * }
     */
    public static int AV_PROFILE_DNXHR_SQ() {
        return AV_PROFILE_DNXHR_SQ;
    }
    private static final int AV_PROFILE_DNXHR_HQ = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DNXHR_HQ 3
     * }
     */
    public static int AV_PROFILE_DNXHR_HQ() {
        return AV_PROFILE_DNXHR_HQ;
    }
    private static final int AV_PROFILE_DNXHR_HQX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DNXHR_HQX 4
     * }
     */
    public static int AV_PROFILE_DNXHR_HQX() {
        return AV_PROFILE_DNXHR_HQX;
    }
    private static final int AV_PROFILE_DNXHR_444 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DNXHR_444 5
     * }
     */
    public static int AV_PROFILE_DNXHR_444() {
        return AV_PROFILE_DNXHR_444;
    }
    private static final int AV_PROFILE_DTS = (int)20L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS 20
     * }
     */
    public static int AV_PROFILE_DTS() {
        return AV_PROFILE_DTS;
    }
    private static final int AV_PROFILE_DTS_ES = (int)30L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS_ES 30
     * }
     */
    public static int AV_PROFILE_DTS_ES() {
        return AV_PROFILE_DTS_ES;
    }
    private static final int AV_PROFILE_DTS_96_24 = (int)40L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS_96_24 40
     * }
     */
    public static int AV_PROFILE_DTS_96_24() {
        return AV_PROFILE_DTS_96_24;
    }
    private static final int AV_PROFILE_DTS_HD_HRA = (int)50L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS_HD_HRA 50
     * }
     */
    public static int AV_PROFILE_DTS_HD_HRA() {
        return AV_PROFILE_DTS_HD_HRA;
    }
    private static final int AV_PROFILE_DTS_HD_MA = (int)60L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS_HD_MA 60
     * }
     */
    public static int AV_PROFILE_DTS_HD_MA() {
        return AV_PROFILE_DTS_HD_MA;
    }
    private static final int AV_PROFILE_DTS_EXPRESS = (int)70L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS_EXPRESS 70
     * }
     */
    public static int AV_PROFILE_DTS_EXPRESS() {
        return AV_PROFILE_DTS_EXPRESS;
    }
    private static final int AV_PROFILE_DTS_HD_MA_X = (int)61L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS_HD_MA_X 61
     * }
     */
    public static int AV_PROFILE_DTS_HD_MA_X() {
        return AV_PROFILE_DTS_HD_MA_X;
    }
    private static final int AV_PROFILE_DTS_HD_MA_X_IMAX = (int)62L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_DTS_HD_MA_X_IMAX 62
     * }
     */
    public static int AV_PROFILE_DTS_HD_MA_X_IMAX() {
        return AV_PROFILE_DTS_HD_MA_X_IMAX;
    }
    private static final int AV_PROFILE_EAC3_DDP_ATMOS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_EAC3_DDP_ATMOS 30
     * }
     */
    public static int AV_PROFILE_EAC3_DDP_ATMOS() {
        return AV_PROFILE_EAC3_DDP_ATMOS;
    }
    private static final int AV_PROFILE_TRUEHD_ATMOS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_TRUEHD_ATMOS 30
     * }
     */
    public static int AV_PROFILE_TRUEHD_ATMOS() {
        return AV_PROFILE_TRUEHD_ATMOS;
    }
    private static final int AV_PROFILE_MPEG2_422 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_422 0
     * }
     */
    public static int AV_PROFILE_MPEG2_422() {
        return AV_PROFILE_MPEG2_422;
    }
    private static final int AV_PROFILE_MPEG2_HIGH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_HIGH 1
     * }
     */
    public static int AV_PROFILE_MPEG2_HIGH() {
        return AV_PROFILE_MPEG2_HIGH;
    }
    private static final int AV_PROFILE_MPEG2_SS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_SS 2
     * }
     */
    public static int AV_PROFILE_MPEG2_SS() {
        return AV_PROFILE_MPEG2_SS;
    }
    private static final int AV_PROFILE_MPEG2_SNR_SCALABLE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_SNR_SCALABLE 3
     * }
     */
    public static int AV_PROFILE_MPEG2_SNR_SCALABLE() {
        return AV_PROFILE_MPEG2_SNR_SCALABLE;
    }
    private static final int AV_PROFILE_MPEG2_MAIN = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_MAIN 4
     * }
     */
    public static int AV_PROFILE_MPEG2_MAIN() {
        return AV_PROFILE_MPEG2_MAIN;
    }
    private static final int AV_PROFILE_MPEG2_SIMPLE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG2_SIMPLE 5
     * }
     */
    public static int AV_PROFILE_MPEG2_SIMPLE() {
        return AV_PROFILE_MPEG2_SIMPLE;
    }
    private static final int AV_PROFILE_H264_BASELINE = (int)66L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_BASELINE 66
     * }
     */
    public static int AV_PROFILE_H264_BASELINE() {
        return AV_PROFILE_H264_BASELINE;
    }
    private static final int AV_PROFILE_H264_MAIN = (int)77L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_MAIN 77
     * }
     */
    public static int AV_PROFILE_H264_MAIN() {
        return AV_PROFILE_H264_MAIN;
    }
    private static final int AV_PROFILE_H264_EXTENDED = (int)88L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_EXTENDED 88
     * }
     */
    public static int AV_PROFILE_H264_EXTENDED() {
        return AV_PROFILE_H264_EXTENDED;
    }
    private static final int AV_PROFILE_H264_HIGH = (int)100L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_HIGH 100
     * }
     */
    public static int AV_PROFILE_H264_HIGH() {
        return AV_PROFILE_H264_HIGH;
    }
    private static final int AV_PROFILE_H264_HIGH_10 = (int)110L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_HIGH_10 110
     * }
     */
    public static int AV_PROFILE_H264_HIGH_10() {
        return AV_PROFILE_H264_HIGH_10;
    }
    private static final int AV_PROFILE_H264_MULTIVIEW_HIGH = (int)118L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_MULTIVIEW_HIGH 118
     * }
     */
    public static int AV_PROFILE_H264_MULTIVIEW_HIGH() {
        return AV_PROFILE_H264_MULTIVIEW_HIGH;
    }
    private static final int AV_PROFILE_H264_HIGH_422 = (int)122L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_HIGH_422 122
     * }
     */
    public static int AV_PROFILE_H264_HIGH_422() {
        return AV_PROFILE_H264_HIGH_422;
    }
    private static final int AV_PROFILE_H264_STEREO_HIGH = (int)128L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_STEREO_HIGH 128
     * }
     */
    public static int AV_PROFILE_H264_STEREO_HIGH() {
        return AV_PROFILE_H264_STEREO_HIGH;
    }
    private static final int AV_PROFILE_H264_HIGH_444 = (int)144L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_HIGH_444 144
     * }
     */
    public static int AV_PROFILE_H264_HIGH_444() {
        return AV_PROFILE_H264_HIGH_444;
    }
    private static final int AV_PROFILE_H264_HIGH_444_PREDICTIVE = (int)244L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_HIGH_444_PREDICTIVE 244
     * }
     */
    public static int AV_PROFILE_H264_HIGH_444_PREDICTIVE() {
        return AV_PROFILE_H264_HIGH_444_PREDICTIVE;
    }
    private static final int AV_PROFILE_H264_CAVLC_444 = (int)44L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_H264_CAVLC_444 44
     * }
     */
    public static int AV_PROFILE_H264_CAVLC_444() {
        return AV_PROFILE_H264_CAVLC_444;
    }
    private static final int AV_PROFILE_VC1_SIMPLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VC1_SIMPLE 0
     * }
     */
    public static int AV_PROFILE_VC1_SIMPLE() {
        return AV_PROFILE_VC1_SIMPLE;
    }
    private static final int AV_PROFILE_VC1_MAIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VC1_MAIN 1
     * }
     */
    public static int AV_PROFILE_VC1_MAIN() {
        return AV_PROFILE_VC1_MAIN;
    }
    private static final int AV_PROFILE_VC1_COMPLEX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VC1_COMPLEX 2
     * }
     */
    public static int AV_PROFILE_VC1_COMPLEX() {
        return AV_PROFILE_VC1_COMPLEX;
    }
    private static final int AV_PROFILE_VC1_ADVANCED = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VC1_ADVANCED 3
     * }
     */
    public static int AV_PROFILE_VC1_ADVANCED() {
        return AV_PROFILE_VC1_ADVANCED;
    }
    private static final int AV_PROFILE_MPEG4_SIMPLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_SIMPLE 0
     * }
     */
    public static int AV_PROFILE_MPEG4_SIMPLE() {
        return AV_PROFILE_MPEG4_SIMPLE;
    }
    private static final int AV_PROFILE_MPEG4_SIMPLE_SCALABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_SIMPLE_SCALABLE 1
     * }
     */
    public static int AV_PROFILE_MPEG4_SIMPLE_SCALABLE() {
        return AV_PROFILE_MPEG4_SIMPLE_SCALABLE;
    }
    private static final int AV_PROFILE_MPEG4_CORE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_CORE 2
     * }
     */
    public static int AV_PROFILE_MPEG4_CORE() {
        return AV_PROFILE_MPEG4_CORE;
    }
    private static final int AV_PROFILE_MPEG4_MAIN = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_MAIN 3
     * }
     */
    public static int AV_PROFILE_MPEG4_MAIN() {
        return AV_PROFILE_MPEG4_MAIN;
    }
    private static final int AV_PROFILE_MPEG4_N_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_N_BIT 4
     * }
     */
    public static int AV_PROFILE_MPEG4_N_BIT() {
        return AV_PROFILE_MPEG4_N_BIT;
    }
    private static final int AV_PROFILE_MPEG4_SCALABLE_TEXTURE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_SCALABLE_TEXTURE 5
     * }
     */
    public static int AV_PROFILE_MPEG4_SCALABLE_TEXTURE() {
        return AV_PROFILE_MPEG4_SCALABLE_TEXTURE;
    }
    private static final int AV_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION = (int)6L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION 6
     * }
     */
    public static int AV_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION() {
        return AV_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION;
    }
    private static final int AV_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE = (int)7L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE 7
     * }
     */
    public static int AV_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE() {
        return AV_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE;
    }
    private static final int AV_PROFILE_MPEG4_HYBRID = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_HYBRID 8
     * }
     */
    public static int AV_PROFILE_MPEG4_HYBRID() {
        return AV_PROFILE_MPEG4_HYBRID;
    }
    private static final int AV_PROFILE_MPEG4_ADVANCED_REAL_TIME = (int)9L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_ADVANCED_REAL_TIME 9
     * }
     */
    public static int AV_PROFILE_MPEG4_ADVANCED_REAL_TIME() {
        return AV_PROFILE_MPEG4_ADVANCED_REAL_TIME;
    }
    private static final int AV_PROFILE_MPEG4_CORE_SCALABLE = (int)10L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_CORE_SCALABLE 10
     * }
     */
    public static int AV_PROFILE_MPEG4_CORE_SCALABLE() {
        return AV_PROFILE_MPEG4_CORE_SCALABLE;
    }
    private static final int AV_PROFILE_MPEG4_ADVANCED_CODING = (int)11L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_ADVANCED_CODING 11
     * }
     */
    public static int AV_PROFILE_MPEG4_ADVANCED_CODING() {
        return AV_PROFILE_MPEG4_ADVANCED_CODING;
    }
    private static final int AV_PROFILE_MPEG4_ADVANCED_CORE = (int)12L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_ADVANCED_CORE 12
     * }
     */
    public static int AV_PROFILE_MPEG4_ADVANCED_CORE() {
        return AV_PROFILE_MPEG4_ADVANCED_CORE;
    }
    private static final int AV_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = (int)13L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE 13
     * }
     */
    public static int AV_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE() {
        return AV_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE;
    }
    private static final int AV_PROFILE_MPEG4_SIMPLE_STUDIO = (int)14L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_SIMPLE_STUDIO 14
     * }
     */
    public static int AV_PROFILE_MPEG4_SIMPLE_STUDIO() {
        return AV_PROFILE_MPEG4_SIMPLE_STUDIO;
    }
    private static final int AV_PROFILE_MPEG4_ADVANCED_SIMPLE = (int)15L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MPEG4_ADVANCED_SIMPLE 15
     * }
     */
    public static int AV_PROFILE_MPEG4_ADVANCED_SIMPLE() {
        return AV_PROFILE_MPEG4_ADVANCED_SIMPLE;
    }
    private static final int AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 1
     * }
     */
    public static int AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0() {
        return AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0;
    }
    private static final int AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 2
     * }
     */
    public static int AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1() {
        return AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1;
    }
    private static final int AV_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION 32768
     * }
     */
    public static int AV_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION() {
        return AV_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION;
    }
    private static final int AV_PROFILE_JPEG2000_DCINEMA_2K = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_JPEG2000_DCINEMA_2K 3
     * }
     */
    public static int AV_PROFILE_JPEG2000_DCINEMA_2K() {
        return AV_PROFILE_JPEG2000_DCINEMA_2K;
    }
    private static final int AV_PROFILE_JPEG2000_DCINEMA_4K = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_JPEG2000_DCINEMA_4K 4
     * }
     */
    public static int AV_PROFILE_JPEG2000_DCINEMA_4K() {
        return AV_PROFILE_JPEG2000_DCINEMA_4K;
    }
    private static final int AV_PROFILE_VP9_0 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VP9_0 0
     * }
     */
    public static int AV_PROFILE_VP9_0() {
        return AV_PROFILE_VP9_0;
    }
    private static final int AV_PROFILE_VP9_1 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VP9_1 1
     * }
     */
    public static int AV_PROFILE_VP9_1() {
        return AV_PROFILE_VP9_1;
    }
    private static final int AV_PROFILE_VP9_2 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VP9_2 2
     * }
     */
    public static int AV_PROFILE_VP9_2() {
        return AV_PROFILE_VP9_2;
    }
    private static final int AV_PROFILE_VP9_3 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VP9_3 3
     * }
     */
    public static int AV_PROFILE_VP9_3() {
        return AV_PROFILE_VP9_3;
    }
    private static final int AV_PROFILE_HEVC_MAIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_HEVC_MAIN 1
     * }
     */
    public static int AV_PROFILE_HEVC_MAIN() {
        return AV_PROFILE_HEVC_MAIN;
    }
    private static final int AV_PROFILE_HEVC_MAIN_10 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_HEVC_MAIN_10 2
     * }
     */
    public static int AV_PROFILE_HEVC_MAIN_10() {
        return AV_PROFILE_HEVC_MAIN_10;
    }
    private static final int AV_PROFILE_HEVC_MAIN_STILL_PICTURE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_HEVC_MAIN_STILL_PICTURE 3
     * }
     */
    public static int AV_PROFILE_HEVC_MAIN_STILL_PICTURE() {
        return AV_PROFILE_HEVC_MAIN_STILL_PICTURE;
    }
    private static final int AV_PROFILE_HEVC_REXT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_HEVC_REXT 4
     * }
     */
    public static int AV_PROFILE_HEVC_REXT() {
        return AV_PROFILE_HEVC_REXT;
    }
    private static final int AV_PROFILE_HEVC_MULTIVIEW_MAIN = (int)6L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_HEVC_MULTIVIEW_MAIN 6
     * }
     */
    public static int AV_PROFILE_HEVC_MULTIVIEW_MAIN() {
        return AV_PROFILE_HEVC_MULTIVIEW_MAIN;
    }
    private static final int AV_PROFILE_HEVC_SCC = (int)9L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_HEVC_SCC 9
     * }
     */
    public static int AV_PROFILE_HEVC_SCC() {
        return AV_PROFILE_HEVC_SCC;
    }
    private static final int AV_PROFILE_VVC_MAIN_10 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VVC_MAIN_10 1
     * }
     */
    public static int AV_PROFILE_VVC_MAIN_10() {
        return AV_PROFILE_VVC_MAIN_10;
    }
    private static final int AV_PROFILE_VVC_MAIN_10_444 = (int)33L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_VVC_MAIN_10_444 33
     * }
     */
    public static int AV_PROFILE_VVC_MAIN_10_444() {
        return AV_PROFILE_VVC_MAIN_10_444;
    }
    private static final int AV_PROFILE_AV1_MAIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AV1_MAIN 0
     * }
     */
    public static int AV_PROFILE_AV1_MAIN() {
        return AV_PROFILE_AV1_MAIN;
    }
    private static final int AV_PROFILE_AV1_HIGH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AV1_HIGH 1
     * }
     */
    public static int AV_PROFILE_AV1_HIGH() {
        return AV_PROFILE_AV1_HIGH;
    }
    private static final int AV_PROFILE_AV1_PROFESSIONAL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_AV1_PROFESSIONAL 2
     * }
     */
    public static int AV_PROFILE_AV1_PROFESSIONAL() {
        return AV_PROFILE_AV1_PROFESSIONAL;
    }
    private static final int AV_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT = (int)192L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT 192
     * }
     */
    public static int AV_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT() {
        return AV_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT;
    }
    private static final int AV_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT = (int)193L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT 193
     * }
     */
    public static int AV_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT() {
        return AV_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT;
    }
    private static final int AV_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT = (int)194L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT 194
     * }
     */
    public static int AV_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT() {
        return AV_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT;
    }
    private static final int AV_PROFILE_MJPEG_HUFFMAN_LOSSLESS = (int)195L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MJPEG_HUFFMAN_LOSSLESS 195
     * }
     */
    public static int AV_PROFILE_MJPEG_HUFFMAN_LOSSLESS() {
        return AV_PROFILE_MJPEG_HUFFMAN_LOSSLESS;
    }
    private static final int AV_PROFILE_MJPEG_JPEG_LS = (int)247L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_MJPEG_JPEG_LS 247
     * }
     */
    public static int AV_PROFILE_MJPEG_JPEG_LS() {
        return AV_PROFILE_MJPEG_JPEG_LS;
    }
    private static final int AV_PROFILE_SBC_MSBC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_SBC_MSBC 1
     * }
     */
    public static int AV_PROFILE_SBC_MSBC() {
        return AV_PROFILE_SBC_MSBC;
    }
    private static final int AV_PROFILE_PRORES_PROXY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_PROXY 0
     * }
     */
    public static int AV_PROFILE_PRORES_PROXY() {
        return AV_PROFILE_PRORES_PROXY;
    }
    private static final int AV_PROFILE_PRORES_LT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_LT 1
     * }
     */
    public static int AV_PROFILE_PRORES_LT() {
        return AV_PROFILE_PRORES_LT;
    }
    private static final int AV_PROFILE_PRORES_STANDARD = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_STANDARD 2
     * }
     */
    public static int AV_PROFILE_PRORES_STANDARD() {
        return AV_PROFILE_PRORES_STANDARD;
    }
    private static final int AV_PROFILE_PRORES_HQ = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_HQ 3
     * }
     */
    public static int AV_PROFILE_PRORES_HQ() {
        return AV_PROFILE_PRORES_HQ;
    }
    private static final int AV_PROFILE_PRORES_4444 = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_4444 4
     * }
     */
    public static int AV_PROFILE_PRORES_4444() {
        return AV_PROFILE_PRORES_4444;
    }
    private static final int AV_PROFILE_PRORES_XQ = (int)5L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_XQ 5
     * }
     */
    public static int AV_PROFILE_PRORES_XQ() {
        return AV_PROFILE_PRORES_XQ;
    }
    private static final int AV_PROFILE_PRORES_RAW = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_RAW 0
     * }
     */
    public static int AV_PROFILE_PRORES_RAW() {
        return AV_PROFILE_PRORES_RAW;
    }
    private static final int AV_PROFILE_PRORES_RAW_HQ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_PRORES_RAW_HQ 1
     * }
     */
    public static int AV_PROFILE_PRORES_RAW_HQ() {
        return AV_PROFILE_PRORES_RAW_HQ;
    }
    private static final int AV_PROFILE_ARIB_PROFILE_A = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_ARIB_PROFILE_A 0
     * }
     */
    public static int AV_PROFILE_ARIB_PROFILE_A() {
        return AV_PROFILE_ARIB_PROFILE_A;
    }
    private static final int AV_PROFILE_ARIB_PROFILE_C = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_ARIB_PROFILE_C 1
     * }
     */
    public static int AV_PROFILE_ARIB_PROFILE_C() {
        return AV_PROFILE_ARIB_PROFILE_C;
    }
    private static final int AV_PROFILE_KLVA_SYNC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_KLVA_SYNC 0
     * }
     */
    public static int AV_PROFILE_KLVA_SYNC() {
        return AV_PROFILE_KLVA_SYNC;
    }
    private static final int AV_PROFILE_KLVA_ASYNC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_KLVA_ASYNC 1
     * }
     */
    public static int AV_PROFILE_KLVA_ASYNC() {
        return AV_PROFILE_KLVA_ASYNC;
    }
    private static final int AV_PROFILE_EVC_BASELINE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_EVC_BASELINE 0
     * }
     */
    public static int AV_PROFILE_EVC_BASELINE() {
        return AV_PROFILE_EVC_BASELINE;
    }
    private static final int AV_PROFILE_EVC_MAIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_EVC_MAIN 1
     * }
     */
    public static int AV_PROFILE_EVC_MAIN() {
        return AV_PROFILE_EVC_MAIN;
    }
    private static final int AV_PROFILE_APV_422_10 = (int)33L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_422_10 33
     * }
     */
    public static int AV_PROFILE_APV_422_10() {
        return AV_PROFILE_APV_422_10;
    }
    private static final int AV_PROFILE_APV_422_12 = (int)44L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_422_12 44
     * }
     */
    public static int AV_PROFILE_APV_422_12() {
        return AV_PROFILE_APV_422_12;
    }
    private static final int AV_PROFILE_APV_444_10 = (int)55L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_444_10 55
     * }
     */
    public static int AV_PROFILE_APV_444_10() {
        return AV_PROFILE_APV_444_10;
    }
    private static final int AV_PROFILE_APV_444_12 = (int)66L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_444_12 66
     * }
     */
    public static int AV_PROFILE_APV_444_12() {
        return AV_PROFILE_APV_444_12;
    }
    private static final int AV_PROFILE_APV_4444_10 = (int)77L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_4444_10 77
     * }
     */
    public static int AV_PROFILE_APV_4444_10() {
        return AV_PROFILE_APV_4444_10;
    }
    private static final int AV_PROFILE_APV_4444_12 = (int)88L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_4444_12 88
     * }
     */
    public static int AV_PROFILE_APV_4444_12() {
        return AV_PROFILE_APV_4444_12;
    }
    private static final int AV_PROFILE_APV_400_10 = (int)99L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_400_10 99
     * }
     */
    public static int AV_PROFILE_APV_400_10() {
        return AV_PROFILE_APV_400_10;
    }
    private static final int AV_PKT_FLAG_KEY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PKT_FLAG_KEY 1
     * }
     */
    public static int AV_PKT_FLAG_KEY() {
        return AV_PKT_FLAG_KEY;
    }
    private static final int AV_PKT_FLAG_CORRUPT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PKT_FLAG_CORRUPT 2
     * }
     */
    public static int AV_PKT_FLAG_CORRUPT() {
        return AV_PKT_FLAG_CORRUPT;
    }
    private static final int AV_PKT_FLAG_DISCARD = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PKT_FLAG_DISCARD 4
     * }
     */
    public static int AV_PKT_FLAG_DISCARD() {
        return AV_PKT_FLAG_DISCARD;
    }
    private static final int AV_PKT_FLAG_TRUSTED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_PKT_FLAG_TRUSTED 8
     * }
     */
    public static int AV_PKT_FLAG_TRUSTED() {
        return AV_PKT_FLAG_TRUSTED;
    }
    private static final int AV_PKT_FLAG_DISPOSABLE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AV_PKT_FLAG_DISPOSABLE 16
     * }
     */
    public static int AV_PKT_FLAG_DISPOSABLE() {
        return AV_PKT_FLAG_DISPOSABLE;
    }
    private static final int LIBAVCODEC_VERSION_MINOR = (int)23L;
    /**
     * {@snippet lang=c :
     * #define LIBAVCODEC_VERSION_MINOR 23
     * }
     */
    public static int LIBAVCODEC_VERSION_MINOR() {
        return LIBAVCODEC_VERSION_MINOR;
    }
    private static final int LIBAVCODEC_VERSION_MICRO = (int)103L;
    /**
     * {@snippet lang=c :
     * #define LIBAVCODEC_VERSION_MICRO 103
     * }
     */
    public static int LIBAVCODEC_VERSION_MICRO() {
        return LIBAVCODEC_VERSION_MICRO;
    }
    private static final int SLICE_FLAG_CODED_ORDER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SLICE_FLAG_CODED_ORDER 1
     * }
     */
    public static int SLICE_FLAG_CODED_ORDER() {
        return SLICE_FLAG_CODED_ORDER;
    }
    private static final int SLICE_FLAG_ALLOW_FIELD = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SLICE_FLAG_ALLOW_FIELD 2
     * }
     */
    public static int SLICE_FLAG_ALLOW_FIELD() {
        return SLICE_FLAG_ALLOW_FIELD;
    }
    private static final int SLICE_FLAG_ALLOW_PLANE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SLICE_FLAG_ALLOW_PLANE 4
     * }
     */
    public static int SLICE_FLAG_ALLOW_PLANE() {
        return SLICE_FLAG_ALLOW_PLANE;
    }
    private static final int FF_CMP_SAD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_SAD 0
     * }
     */
    public static int FF_CMP_SAD() {
        return FF_CMP_SAD;
    }
    private static final int FF_CMP_SSE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_SSE 1
     * }
     */
    public static int FF_CMP_SSE() {
        return FF_CMP_SSE;
    }
    private static final int FF_CMP_SATD = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_SATD 2
     * }
     */
    public static int FF_CMP_SATD() {
        return FF_CMP_SATD;
    }
    private static final int FF_CMP_DCT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_DCT 3
     * }
     */
    public static int FF_CMP_DCT() {
        return FF_CMP_DCT;
    }
    private static final int FF_CMP_PSNR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_PSNR 4
     * }
     */
    public static int FF_CMP_PSNR() {
        return FF_CMP_PSNR;
    }
    private static final int FF_CMP_BIT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_BIT 5
     * }
     */
    public static int FF_CMP_BIT() {
        return FF_CMP_BIT;
    }
    private static final int FF_CMP_RD = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_RD 6
     * }
     */
    public static int FF_CMP_RD() {
        return FF_CMP_RD;
    }
    private static final int FF_CMP_ZERO = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_ZERO 7
     * }
     */
    public static int FF_CMP_ZERO() {
        return FF_CMP_ZERO;
    }
    private static final int FF_CMP_VSAD = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_VSAD 8
     * }
     */
    public static int FF_CMP_VSAD() {
        return FF_CMP_VSAD;
    }
    private static final int FF_CMP_VSSE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_VSSE 9
     * }
     */
    public static int FF_CMP_VSSE() {
        return FF_CMP_VSSE;
    }
    private static final int FF_CMP_NSSE = (int)10L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_NSSE 10
     * }
     */
    public static int FF_CMP_NSSE() {
        return FF_CMP_NSSE;
    }
    private static final int FF_CMP_W53 = (int)11L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_W53 11
     * }
     */
    public static int FF_CMP_W53() {
        return FF_CMP_W53;
    }
    private static final int FF_CMP_W97 = (int)12L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_W97 12
     * }
     */
    public static int FF_CMP_W97() {
        return FF_CMP_W97;
    }
    private static final int FF_CMP_DCTMAX = (int)13L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_DCTMAX 13
     * }
     */
    public static int FF_CMP_DCTMAX() {
        return FF_CMP_DCTMAX;
    }
    private static final int FF_CMP_DCT264 = (int)14L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_DCT264 14
     * }
     */
    public static int FF_CMP_DCT264() {
        return FF_CMP_DCT264;
    }
    private static final int FF_CMP_MEDIAN_SAD = (int)15L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_MEDIAN_SAD 15
     * }
     */
    public static int FF_CMP_MEDIAN_SAD() {
        return FF_CMP_MEDIAN_SAD;
    }
    private static final int FF_CMP_CHROMA = (int)256L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_CHROMA 256
     * }
     */
    public static int FF_CMP_CHROMA() {
        return FF_CMP_CHROMA;
    }
    private static final int FF_MB_DECISION_SIMPLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_MB_DECISION_SIMPLE 0
     * }
     */
    public static int FF_MB_DECISION_SIMPLE() {
        return FF_MB_DECISION_SIMPLE;
    }
    private static final int FF_MB_DECISION_BITS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_MB_DECISION_BITS 1
     * }
     */
    public static int FF_MB_DECISION_BITS() {
        return FF_MB_DECISION_BITS;
    }
    private static final int FF_MB_DECISION_RD = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_MB_DECISION_RD 2
     * }
     */
    public static int FF_MB_DECISION_RD() {
        return FF_MB_DECISION_RD;
    }
    private static final int FF_BUG_AUTODETECT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_AUTODETECT 1
     * }
     */
    public static int FF_BUG_AUTODETECT() {
        return FF_BUG_AUTODETECT;
    }
    private static final int FF_BUG_XVID_ILACE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_XVID_ILACE 4
     * }
     */
    public static int FF_BUG_XVID_ILACE() {
        return FF_BUG_XVID_ILACE;
    }
    private static final int FF_BUG_UMP4 = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_UMP4 8
     * }
     */
    public static int FF_BUG_UMP4() {
        return FF_BUG_UMP4;
    }
    private static final int FF_BUG_NO_PADDING = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_NO_PADDING 16
     * }
     */
    public static int FF_BUG_NO_PADDING() {
        return FF_BUG_NO_PADDING;
    }
    private static final int FF_BUG_AMV = (int)32L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_AMV 32
     * }
     */
    public static int FF_BUG_AMV() {
        return FF_BUG_AMV;
    }
    private static final int FF_BUG_QPEL_CHROMA = (int)64L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_QPEL_CHROMA 64
     * }
     */
    public static int FF_BUG_QPEL_CHROMA() {
        return FF_BUG_QPEL_CHROMA;
    }
    private static final int FF_BUG_STD_QPEL = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_STD_QPEL 128
     * }
     */
    public static int FF_BUG_STD_QPEL() {
        return FF_BUG_STD_QPEL;
    }
    private static final int FF_BUG_QPEL_CHROMA2 = (int)256L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_QPEL_CHROMA2 256
     * }
     */
    public static int FF_BUG_QPEL_CHROMA2() {
        return FF_BUG_QPEL_CHROMA2;
    }
    private static final int FF_BUG_DIRECT_BLOCKSIZE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_DIRECT_BLOCKSIZE 512
     * }
     */
    public static int FF_BUG_DIRECT_BLOCKSIZE() {
        return FF_BUG_DIRECT_BLOCKSIZE;
    }
    private static final int FF_BUG_EDGE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_EDGE 1024
     * }
     */
    public static int FF_BUG_EDGE() {
        return FF_BUG_EDGE;
    }
    private static final int FF_BUG_HPEL_CHROMA = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_HPEL_CHROMA 2048
     * }
     */
    public static int FF_BUG_HPEL_CHROMA() {
        return FF_BUG_HPEL_CHROMA;
    }
    private static final int FF_BUG_DC_CLIP = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_DC_CLIP 4096
     * }
     */
    public static int FF_BUG_DC_CLIP() {
        return FF_BUG_DC_CLIP;
    }
    private static final int FF_BUG_MS = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_MS 8192
     * }
     */
    public static int FF_BUG_MS() {
        return FF_BUG_MS;
    }
    private static final int FF_BUG_TRUNCATED = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_TRUNCATED 16384
     * }
     */
    public static int FF_BUG_TRUNCATED() {
        return FF_BUG_TRUNCATED;
    }
    private static final int FF_BUG_IEDGE = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_IEDGE 32768
     * }
     */
    public static int FF_BUG_IEDGE() {
        return FF_BUG_IEDGE;
    }
    private static final int FF_EC_GUESS_MVS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_EC_GUESS_MVS 1
     * }
     */
    public static int FF_EC_GUESS_MVS() {
        return FF_EC_GUESS_MVS;
    }
    private static final int FF_EC_DEBLOCK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_EC_DEBLOCK 2
     * }
     */
    public static int FF_EC_DEBLOCK() {
        return FF_EC_DEBLOCK;
    }
    private static final int FF_EC_FAVOR_INTER = (int)256L;
    /**
     * {@snippet lang=c :
     * #define FF_EC_FAVOR_INTER 256
     * }
     */
    public static int FF_EC_FAVOR_INTER() {
        return FF_EC_FAVOR_INTER;
    }
    private static final int FF_DEBUG_PICT_INFO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_PICT_INFO 1
     * }
     */
    public static int FF_DEBUG_PICT_INFO() {
        return FF_DEBUG_PICT_INFO;
    }
    private static final int FF_DEBUG_RC = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_RC 2
     * }
     */
    public static int FF_DEBUG_RC() {
        return FF_DEBUG_RC;
    }
    private static final int FF_DEBUG_BITSTREAM = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_BITSTREAM 4
     * }
     */
    public static int FF_DEBUG_BITSTREAM() {
        return FF_DEBUG_BITSTREAM;
    }
    private static final int FF_DEBUG_MB_TYPE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_MB_TYPE 8
     * }
     */
    public static int FF_DEBUG_MB_TYPE() {
        return FF_DEBUG_MB_TYPE;
    }
    private static final int FF_DEBUG_QP = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_QP 16
     * }
     */
    public static int FF_DEBUG_QP() {
        return FF_DEBUG_QP;
    }
    private static final int FF_DEBUG_DCT_COEFF = (int)64L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_DCT_COEFF 64
     * }
     */
    public static int FF_DEBUG_DCT_COEFF() {
        return FF_DEBUG_DCT_COEFF;
    }
    private static final int FF_DEBUG_SKIP = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_SKIP 128
     * }
     */
    public static int FF_DEBUG_SKIP() {
        return FF_DEBUG_SKIP;
    }
    private static final int FF_DEBUG_STARTCODE = (int)256L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_STARTCODE 256
     * }
     */
    public static int FF_DEBUG_STARTCODE() {
        return FF_DEBUG_STARTCODE;
    }
    private static final int FF_DEBUG_ER = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_ER 1024
     * }
     */
    public static int FF_DEBUG_ER() {
        return FF_DEBUG_ER;
    }
    private static final int FF_DEBUG_MMCO = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_MMCO 2048
     * }
     */
    public static int FF_DEBUG_MMCO() {
        return FF_DEBUG_MMCO;
    }
    private static final int FF_DEBUG_BUGS = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_BUGS 4096
     * }
     */
    public static int FF_DEBUG_BUGS() {
        return FF_DEBUG_BUGS;
    }
    private static final int FF_DEBUG_BUFFERS = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_BUFFERS 32768
     * }
     */
    public static int FF_DEBUG_BUFFERS() {
        return FF_DEBUG_BUFFERS;
    }
    private static final int FF_DEBUG_THREADS = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_THREADS 65536
     * }
     */
    public static int FF_DEBUG_THREADS() {
        return FF_DEBUG_THREADS;
    }
    private static final int FF_DEBUG_GREEN_MD = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_GREEN_MD 8388608
     * }
     */
    public static int FF_DEBUG_GREEN_MD() {
        return FF_DEBUG_GREEN_MD;
    }
    private static final int FF_DEBUG_NOMC = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_NOMC 16777216
     * }
     */
    public static int FF_DEBUG_NOMC() {
        return FF_DEBUG_NOMC;
    }
    private static final int FF_DCT_AUTO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_AUTO 0
     * }
     */
    public static int FF_DCT_AUTO() {
        return FF_DCT_AUTO;
    }
    private static final int FF_DCT_FASTINT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_FASTINT 1
     * }
     */
    public static int FF_DCT_FASTINT() {
        return FF_DCT_FASTINT;
    }
    private static final int FF_DCT_INT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_INT 2
     * }
     */
    public static int FF_DCT_INT() {
        return FF_DCT_INT;
    }
    private static final int FF_DCT_MMX = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_MMX 3
     * }
     */
    public static int FF_DCT_MMX() {
        return FF_DCT_MMX;
    }
    private static final int FF_DCT_ALTIVEC = (int)5L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_ALTIVEC 5
     * }
     */
    public static int FF_DCT_ALTIVEC() {
        return FF_DCT_ALTIVEC;
    }
    private static final int FF_DCT_FAAN = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_FAAN 6
     * }
     */
    public static int FF_DCT_FAAN() {
        return FF_DCT_FAAN;
    }
    private static final int FF_DCT_NEON = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_NEON 7
     * }
     */
    public static int FF_DCT_NEON() {
        return FF_DCT_NEON;
    }
    private static final int FF_IDCT_AUTO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_AUTO 0
     * }
     */
    public static int FF_IDCT_AUTO() {
        return FF_IDCT_AUTO;
    }
    private static final int FF_IDCT_INT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_INT 1
     * }
     */
    public static int FF_IDCT_INT() {
        return FF_IDCT_INT;
    }
    private static final int FF_IDCT_SIMPLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLE 2
     * }
     */
    public static int FF_IDCT_SIMPLE() {
        return FF_IDCT_SIMPLE;
    }
    private static final int FF_IDCT_SIMPLEMMX = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLEMMX 3
     * }
     */
    public static int FF_IDCT_SIMPLEMMX() {
        return FF_IDCT_SIMPLEMMX;
    }
    private static final int FF_IDCT_ARM = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_ARM 7
     * }
     */
    public static int FF_IDCT_ARM() {
        return FF_IDCT_ARM;
    }
    private static final int FF_IDCT_ALTIVEC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_ALTIVEC 8
     * }
     */
    public static int FF_IDCT_ALTIVEC() {
        return FF_IDCT_ALTIVEC;
    }
    private static final int FF_IDCT_SIMPLEARM = (int)10L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLEARM 10
     * }
     */
    public static int FF_IDCT_SIMPLEARM() {
        return FF_IDCT_SIMPLEARM;
    }
    private static final int FF_IDCT_XVID = (int)14L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_XVID 14
     * }
     */
    public static int FF_IDCT_XVID() {
        return FF_IDCT_XVID;
    }
    private static final int FF_IDCT_SIMPLEARMV5TE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLEARMV5TE 16
     * }
     */
    public static int FF_IDCT_SIMPLEARMV5TE() {
        return FF_IDCT_SIMPLEARMV5TE;
    }
    private static final int FF_IDCT_SIMPLEARMV6 = (int)17L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLEARMV6 17
     * }
     */
    public static int FF_IDCT_SIMPLEARMV6() {
        return FF_IDCT_SIMPLEARMV6;
    }
    private static final int FF_IDCT_FAAN = (int)20L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_FAAN 20
     * }
     */
    public static int FF_IDCT_FAAN() {
        return FF_IDCT_FAAN;
    }
    private static final int FF_IDCT_SIMPLENEON = (int)22L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLENEON 22
     * }
     */
    public static int FF_IDCT_SIMPLENEON() {
        return FF_IDCT_SIMPLENEON;
    }
    private static final int FF_IDCT_SIMPLEAUTO = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLEAUTO 128
     * }
     */
    public static int FF_IDCT_SIMPLEAUTO() {
        return FF_IDCT_SIMPLEAUTO;
    }
    private static final int FF_THREAD_FRAME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_THREAD_FRAME 1
     * }
     */
    public static int FF_THREAD_FRAME() {
        return FF_THREAD_FRAME;
    }
    private static final int FF_THREAD_SLICE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_THREAD_SLICE 2
     * }
     */
    public static int FF_THREAD_SLICE() {
        return FF_THREAD_SLICE;
    }
    private static final int FF_CODEC_PROPERTY_LOSSLESS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_CODEC_PROPERTY_LOSSLESS 1
     * }
     */
    public static int FF_CODEC_PROPERTY_LOSSLESS() {
        return FF_CODEC_PROPERTY_LOSSLESS;
    }
    private static final int FF_CODEC_PROPERTY_CLOSED_CAPTIONS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_CODEC_PROPERTY_CLOSED_CAPTIONS 2
     * }
     */
    public static int FF_CODEC_PROPERTY_CLOSED_CAPTIONS() {
        return FF_CODEC_PROPERTY_CLOSED_CAPTIONS;
    }
    private static final int FF_CODEC_PROPERTY_FILM_GRAIN = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_CODEC_PROPERTY_FILM_GRAIN 4
     * }
     */
    public static int FF_CODEC_PROPERTY_FILM_GRAIN() {
        return FF_CODEC_PROPERTY_FILM_GRAIN;
    }
    private static final int FF_SUB_CHARENC_MODE_AUTOMATIC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_SUB_CHARENC_MODE_AUTOMATIC 0
     * }
     */
    public static int FF_SUB_CHARENC_MODE_AUTOMATIC() {
        return FF_SUB_CHARENC_MODE_AUTOMATIC;
    }
    private static final int FF_SUB_CHARENC_MODE_PRE_DECODER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_SUB_CHARENC_MODE_PRE_DECODER 1
     * }
     */
    public static int FF_SUB_CHARENC_MODE_PRE_DECODER() {
        return FF_SUB_CHARENC_MODE_PRE_DECODER;
    }
    private static final int FF_SUB_CHARENC_MODE_IGNORE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_SUB_CHARENC_MODE_IGNORE 2
     * }
     */
    public static int FF_SUB_CHARENC_MODE_IGNORE() {
        return FF_SUB_CHARENC_MODE_IGNORE;
    }
    private static final int AV_HWACCEL_CODEC_CAP_EXPERIMENTAL = (int)512L;
    /**
     * {@snippet lang=c :
     * #define AV_HWACCEL_CODEC_CAP_EXPERIMENTAL 512
     * }
     */
    public static int AV_HWACCEL_CODEC_CAP_EXPERIMENTAL() {
        return AV_HWACCEL_CODEC_CAP_EXPERIMENTAL;
    }
    private static final int AV_SUBTITLE_FLAG_FORCED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_SUBTITLE_FLAG_FORCED 1
     * }
     */
    public static int AV_SUBTITLE_FLAG_FORCED() {
        return AV_SUBTITLE_FLAG_FORCED;
    }
    private static final int AV_PARSER_PTS_NB = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PARSER_PTS_NB 4
     * }
     */
    public static int AV_PARSER_PTS_NB() {
        return AV_PARSER_PTS_NB;
    }
    private static final int PARSER_FLAG_COMPLETE_FRAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PARSER_FLAG_COMPLETE_FRAMES 1
     * }
     */
    public static int PARSER_FLAG_COMPLETE_FRAMES() {
        return PARSER_FLAG_COMPLETE_FRAMES;
    }
    private static final int PARSER_FLAG_ONCE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PARSER_FLAG_ONCE 2
     * }
     */
    public static int PARSER_FLAG_ONCE() {
        return PARSER_FLAG_ONCE;
    }
    private static final int PARSER_FLAG_FETCHED_OFFSET = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PARSER_FLAG_FETCHED_OFFSET 4
     * }
     */
    public static int PARSER_FLAG_FETCHED_OFFSET() {
        return PARSER_FLAG_FETCHED_OFFSET;
    }
    private static final int PARSER_FLAG_USE_CODEC_TS = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PARSER_FLAG_USE_CODEC_TS 4096
     * }
     */
    public static int PARSER_FLAG_USE_CODEC_TS() {
        return PARSER_FLAG_USE_CODEC_TS;
    }
    private static final int LIBAVFORMAT_VERSION_MAJOR = (int)62L;
    /**
     * {@snippet lang=c :
     * #define LIBAVFORMAT_VERSION_MAJOR 62
     * }
     */
    public static int LIBAVFORMAT_VERSION_MAJOR() {
        return LIBAVFORMAT_VERSION_MAJOR;
    }
    private static final int FF_API_R_FRAME_RATE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_API_R_FRAME_RATE 1
     * }
     */
    public static int FF_API_R_FRAME_RATE() {
        return FF_API_R_FRAME_RATE;
    }
    private static final int AVSEEK_SIZE = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_SIZE 65536
     * }
     */
    public static int AVSEEK_SIZE() {
        return AVSEEK_SIZE;
    }
    private static final int AVSEEK_FORCE = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_FORCE 131072
     * }
     */
    public static int AVSEEK_FORCE() {
        return AVSEEK_FORCE;
    }
    private static final int AVIO_FLAG_READ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVIO_FLAG_READ 1
     * }
     */
    public static int AVIO_FLAG_READ() {
        return AVIO_FLAG_READ;
    }
    private static final int AVIO_FLAG_WRITE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVIO_FLAG_WRITE 2
     * }
     */
    public static int AVIO_FLAG_WRITE() {
        return AVIO_FLAG_WRITE;
    }
    private static final int AVIO_FLAG_NONBLOCK = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AVIO_FLAG_NONBLOCK 8
     * }
     */
    public static int AVIO_FLAG_NONBLOCK() {
        return AVIO_FLAG_NONBLOCK;
    }
    private static final int AVIO_FLAG_DIRECT = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define AVIO_FLAG_DIRECT 32768
     * }
     */
    public static int AVIO_FLAG_DIRECT() {
        return AVIO_FLAG_DIRECT;
    }
    private static final int LIBAVFORMAT_VERSION_MINOR = (int)9L;
    /**
     * {@snippet lang=c :
     * #define LIBAVFORMAT_VERSION_MINOR 9
     * }
     */
    public static int LIBAVFORMAT_VERSION_MINOR() {
        return LIBAVFORMAT_VERSION_MINOR;
    }
    private static final int LIBAVFORMAT_VERSION_MICRO = (int)101L;
    /**
     * {@snippet lang=c :
     * #define LIBAVFORMAT_VERSION_MICRO 101
     * }
     */
    public static int LIBAVFORMAT_VERSION_MICRO() {
        return LIBAVFORMAT_VERSION_MICRO;
    }
    private static final int AVPROBE_SCORE_EXTENSION = (int)50L;
    /**
     * {@snippet lang=c :
     * #define AVPROBE_SCORE_EXTENSION 50
     * }
     */
    public static int AVPROBE_SCORE_EXTENSION() {
        return AVPROBE_SCORE_EXTENSION;
    }
    private static final int AVPROBE_SCORE_MIME_BONUS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define AVPROBE_SCORE_MIME_BONUS 30
     * }
     */
    public static int AVPROBE_SCORE_MIME_BONUS() {
        return AVPROBE_SCORE_MIME_BONUS;
    }
    private static final int AVPROBE_SCORE_MAX = (int)100L;
    /**
     * {@snippet lang=c :
     * #define AVPROBE_SCORE_MAX 100
     * }
     */
    public static int AVPROBE_SCORE_MAX() {
        return AVPROBE_SCORE_MAX;
    }
    private static final int AVPROBE_PADDING_SIZE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AVPROBE_PADDING_SIZE 32
     * }
     */
    public static int AVPROBE_PADDING_SIZE() {
        return AVPROBE_PADDING_SIZE;
    }
    private static final int AVFMT_NOFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NOFILE 1
     * }
     */
    public static int AVFMT_NOFILE() {
        return AVFMT_NOFILE;
    }
    private static final int AVFMT_NEEDNUMBER = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NEEDNUMBER 2
     * }
     */
    public static int AVFMT_NEEDNUMBER() {
        return AVFMT_NEEDNUMBER;
    }
    private static final int AVFMT_EXPERIMENTAL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_EXPERIMENTAL 4
     * }
     */
    public static int AVFMT_EXPERIMENTAL() {
        return AVFMT_EXPERIMENTAL;
    }
    private static final int AVFMT_SHOW_IDS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_SHOW_IDS 8
     * }
     */
    public static int AVFMT_SHOW_IDS() {
        return AVFMT_SHOW_IDS;
    }
    private static final int AVFMT_GLOBALHEADER = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_GLOBALHEADER 64
     * }
     */
    public static int AVFMT_GLOBALHEADER() {
        return AVFMT_GLOBALHEADER;
    }
    private static final int AVFMT_NOTIMESTAMPS = (int)128L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NOTIMESTAMPS 128
     * }
     */
    public static int AVFMT_NOTIMESTAMPS() {
        return AVFMT_NOTIMESTAMPS;
    }
    private static final int AVFMT_GENERIC_INDEX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_GENERIC_INDEX 256
     * }
     */
    public static int AVFMT_GENERIC_INDEX() {
        return AVFMT_GENERIC_INDEX;
    }
    private static final int AVFMT_TS_DISCONT = (int)512L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_TS_DISCONT 512
     * }
     */
    public static int AVFMT_TS_DISCONT() {
        return AVFMT_TS_DISCONT;
    }
    private static final int AVFMT_VARIABLE_FPS = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_VARIABLE_FPS 1024
     * }
     */
    public static int AVFMT_VARIABLE_FPS() {
        return AVFMT_VARIABLE_FPS;
    }
    private static final int AVFMT_NODIMENSIONS = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NODIMENSIONS 2048
     * }
     */
    public static int AVFMT_NODIMENSIONS() {
        return AVFMT_NODIMENSIONS;
    }
    private static final int AVFMT_NOSTREAMS = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NOSTREAMS 4096
     * }
     */
    public static int AVFMT_NOSTREAMS() {
        return AVFMT_NOSTREAMS;
    }
    private static final int AVFMT_NOBINSEARCH = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NOBINSEARCH 8192
     * }
     */
    public static int AVFMT_NOBINSEARCH() {
        return AVFMT_NOBINSEARCH;
    }
    private static final int AVFMT_NOGENSEARCH = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NOGENSEARCH 16384
     * }
     */
    public static int AVFMT_NOGENSEARCH() {
        return AVFMT_NOGENSEARCH;
    }
    private static final int AVFMT_NO_BYTE_SEEK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NO_BYTE_SEEK 32768
     * }
     */
    public static int AVFMT_NO_BYTE_SEEK() {
        return AVFMT_NO_BYTE_SEEK;
    }
    private static final int AVFMT_TS_NONSTRICT = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_TS_NONSTRICT 131072
     * }
     */
    public static int AVFMT_TS_NONSTRICT() {
        return AVFMT_TS_NONSTRICT;
    }
    private static final int AVFMT_TS_NEGATIVE = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_TS_NEGATIVE 262144
     * }
     */
    public static int AVFMT_TS_NEGATIVE() {
        return AVFMT_TS_NEGATIVE;
    }
    private static final int AVFMT_SEEK_TO_PTS = (int)67108864L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_SEEK_TO_PTS 67108864
     * }
     */
    public static int AVFMT_SEEK_TO_PTS() {
        return AVFMT_SEEK_TO_PTS;
    }
    private static final int AVINDEX_KEYFRAME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVINDEX_KEYFRAME 1
     * }
     */
    public static int AVINDEX_KEYFRAME() {
        return AVINDEX_KEYFRAME;
    }
    private static final int AVINDEX_DISCARD_FRAME = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVINDEX_DISCARD_FRAME 2
     * }
     */
    public static int AVINDEX_DISCARD_FRAME() {
        return AVINDEX_DISCARD_FRAME;
    }
    private static final int AV_PTS_WRAP_IGNORE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PTS_WRAP_IGNORE 0
     * }
     */
    public static int AV_PTS_WRAP_IGNORE() {
        return AV_PTS_WRAP_IGNORE;
    }
    private static final int AV_PTS_WRAP_ADD_OFFSET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PTS_WRAP_ADD_OFFSET 1
     * }
     */
    public static int AV_PTS_WRAP_ADD_OFFSET() {
        return AV_PTS_WRAP_ADD_OFFSET;
    }
    private static final int AVSTREAM_EVENT_FLAG_METADATA_UPDATED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVSTREAM_EVENT_FLAG_METADATA_UPDATED 1
     * }
     */
    public static int AVSTREAM_EVENT_FLAG_METADATA_UPDATED() {
        return AVSTREAM_EVENT_FLAG_METADATA_UPDATED;
    }
    private static final int AV_PROGRAM_RUNNING = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROGRAM_RUNNING 1
     * }
     */
    public static int AV_PROGRAM_RUNNING() {
        return AV_PROGRAM_RUNNING;
    }
    private static final int AVFMTCTX_NOHEADER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFMTCTX_NOHEADER 1
     * }
     */
    public static int AVFMTCTX_NOHEADER() {
        return AVFMTCTX_NOHEADER;
    }
    private static final int AVFMTCTX_UNSEEKABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVFMTCTX_UNSEEKABLE 2
     * }
     */
    public static int AVFMTCTX_UNSEEKABLE() {
        return AVFMTCTX_UNSEEKABLE;
    }
    private static final int AVFMT_FLAG_GENPTS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_GENPTS 1
     * }
     */
    public static int AVFMT_FLAG_GENPTS() {
        return AVFMT_FLAG_GENPTS;
    }
    private static final int AVFMT_FLAG_IGNIDX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_IGNIDX 2
     * }
     */
    public static int AVFMT_FLAG_IGNIDX() {
        return AVFMT_FLAG_IGNIDX;
    }
    private static final int AVFMT_FLAG_NONBLOCK = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_NONBLOCK 4
     * }
     */
    public static int AVFMT_FLAG_NONBLOCK() {
        return AVFMT_FLAG_NONBLOCK;
    }
    private static final int AVFMT_FLAG_IGNDTS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_IGNDTS 8
     * }
     */
    public static int AVFMT_FLAG_IGNDTS() {
        return AVFMT_FLAG_IGNDTS;
    }
    private static final int AVFMT_FLAG_NOFILLIN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_NOFILLIN 16
     * }
     */
    public static int AVFMT_FLAG_NOFILLIN() {
        return AVFMT_FLAG_NOFILLIN;
    }
    private static final int AVFMT_FLAG_NOPARSE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_NOPARSE 32
     * }
     */
    public static int AVFMT_FLAG_NOPARSE() {
        return AVFMT_FLAG_NOPARSE;
    }
    private static final int AVFMT_FLAG_NOBUFFER = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_NOBUFFER 64
     * }
     */
    public static int AVFMT_FLAG_NOBUFFER() {
        return AVFMT_FLAG_NOBUFFER;
    }
    private static final int AVFMT_FLAG_CUSTOM_IO = (int)128L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_CUSTOM_IO 128
     * }
     */
    public static int AVFMT_FLAG_CUSTOM_IO() {
        return AVFMT_FLAG_CUSTOM_IO;
    }
    private static final int AVFMT_FLAG_DISCARD_CORRUPT = (int)256L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_DISCARD_CORRUPT 256
     * }
     */
    public static int AVFMT_FLAG_DISCARD_CORRUPT() {
        return AVFMT_FLAG_DISCARD_CORRUPT;
    }
    private static final int AVFMT_FLAG_FLUSH_PACKETS = (int)512L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_FLUSH_PACKETS 512
     * }
     */
    public static int AVFMT_FLAG_FLUSH_PACKETS() {
        return AVFMT_FLAG_FLUSH_PACKETS;
    }
    private static final int AVFMT_FLAG_BITEXACT = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_BITEXACT 1024
     * }
     */
    public static int AVFMT_FLAG_BITEXACT() {
        return AVFMT_FLAG_BITEXACT;
    }
    private static final int AVFMT_FLAG_SORT_DTS = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_SORT_DTS 65536
     * }
     */
    public static int AVFMT_FLAG_SORT_DTS() {
        return AVFMT_FLAG_SORT_DTS;
    }
    private static final int AVFMT_FLAG_FAST_SEEK = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_FAST_SEEK 524288
     * }
     */
    public static int AVFMT_FLAG_FAST_SEEK() {
        return AVFMT_FLAG_FAST_SEEK;
    }
    private static final int AVFMT_FLAG_AUTO_BSF = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_AUTO_BSF 2097152
     * }
     */
    public static int AVFMT_FLAG_AUTO_BSF() {
        return AVFMT_FLAG_AUTO_BSF;
    }
    private static final int FF_FDEBUG_TS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_FDEBUG_TS 1
     * }
     */
    public static int FF_FDEBUG_TS() {
        return FF_FDEBUG_TS;
    }
    private static final int AVFMT_EVENT_FLAG_METADATA_UPDATED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_EVENT_FLAG_METADATA_UPDATED 1
     * }
     */
    public static int AVFMT_EVENT_FLAG_METADATA_UPDATED() {
        return AVFMT_EVENT_FLAG_METADATA_UPDATED;
    }
    private static final int AVFMT_AVOID_NEG_TS_DISABLED = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_AVOID_NEG_TS_DISABLED 0
     * }
     */
    public static int AVFMT_AVOID_NEG_TS_DISABLED() {
        return AVFMT_AVOID_NEG_TS_DISABLED;
    }
    private static final int AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE 1
     * }
     */
    public static int AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE() {
        return AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE;
    }
    private static final int AVFMT_AVOID_NEG_TS_MAKE_ZERO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_AVOID_NEG_TS_MAKE_ZERO 2
     * }
     */
    public static int AVFMT_AVOID_NEG_TS_MAKE_ZERO() {
        return AVFMT_AVOID_NEG_TS_MAKE_ZERO;
    }
    private static final int AVSEEK_FLAG_BACKWARD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_FLAG_BACKWARD 1
     * }
     */
    public static int AVSEEK_FLAG_BACKWARD() {
        return AVSEEK_FLAG_BACKWARD;
    }
    private static final int AVSEEK_FLAG_BYTE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_FLAG_BYTE 2
     * }
     */
    public static int AVSEEK_FLAG_BYTE() {
        return AVSEEK_FLAG_BYTE;
    }
    private static final int AVSEEK_FLAG_ANY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_FLAG_ANY 4
     * }
     */
    public static int AVSEEK_FLAG_ANY() {
        return AVSEEK_FLAG_ANY;
    }
    private static final int AVSEEK_FLAG_FRAME = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_FLAG_FRAME 8
     * }
     */
    public static int AVSEEK_FLAG_FRAME() {
        return AVSEEK_FLAG_FRAME;
    }
    private static final int AVSTREAM_INIT_IN_WRITE_HEADER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AVSTREAM_INIT_IN_WRITE_HEADER 0
     * }
     */
    public static int AVSTREAM_INIT_IN_WRITE_HEADER() {
        return AVSTREAM_INIT_IN_WRITE_HEADER;
    }
    private static final int AVSTREAM_INIT_IN_INIT_OUTPUT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVSTREAM_INIT_IN_INIT_OUTPUT 1
     * }
     */
    public static int AVSTREAM_INIT_IN_INIT_OUTPUT() {
        return AVSTREAM_INIT_IN_INIT_OUTPUT;
    }
    private static final int AV_FRAME_FILENAME_FLAGS_MULTIPLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_FRAME_FILENAME_FLAGS_MULTIPLE 1
     * }
     */
    public static int AV_FRAME_FILENAME_FLAGS_MULTIPLE() {
        return AV_FRAME_FILENAME_FLAGS_MULTIPLE;
    }
    private static final int AV_FRAME_FILENAME_FLAGS_IGNORE_TRUNCATION = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_FRAME_FILENAME_FLAGS_IGNORE_TRUNCATION 2
     * }
     */
    public static int AV_FRAME_FILENAME_FLAGS_IGNORE_TRUNCATION() {
        return AV_FRAME_FILENAME_FLAGS_IGNORE_TRUNCATION;
    }
    private static final int FF_LOSS_RESOLUTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_RESOLUTION 1
     * }
     */
    public static int FF_LOSS_RESOLUTION() {
        return FF_LOSS_RESOLUTION;
    }
    private static final int FF_LOSS_DEPTH = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_DEPTH 2
     * }
     */
    public static int FF_LOSS_DEPTH() {
        return FF_LOSS_DEPTH;
    }
    private static final int FF_LOSS_COLORSPACE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_COLORSPACE 4
     * }
     */
    public static int FF_LOSS_COLORSPACE() {
        return FF_LOSS_COLORSPACE;
    }
    private static final int FF_LOSS_ALPHA = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_ALPHA 8
     * }
     */
    public static int FF_LOSS_ALPHA() {
        return FF_LOSS_ALPHA;
    }
    private static final int FF_LOSS_COLORQUANT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_COLORQUANT 16
     * }
     */
    public static int FF_LOSS_COLORQUANT() {
        return FF_LOSS_COLORQUANT;
    }
    private static final int FF_LOSS_CHROMA = (int)32L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_CHROMA 32
     * }
     */
    public static int FF_LOSS_CHROMA() {
        return FF_LOSS_CHROMA;
    }
    private static final int FF_LOSS_EXCESS_RESOLUTION = (int)64L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_EXCESS_RESOLUTION 64
     * }
     */
    public static int FF_LOSS_EXCESS_RESOLUTION() {
        return FF_LOSS_EXCESS_RESOLUTION;
    }
    private static final int FF_LOSS_EXCESS_DEPTH = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_EXCESS_DEPTH 128
     * }
     */
    public static int FF_LOSS_EXCESS_DEPTH() {
        return FF_LOSS_EXCESS_DEPTH;
    }
    private static final int LIBSWRESAMPLE_VERSION_MAJOR = (int)6L;
    /**
     * {@snippet lang=c :
     * #define LIBSWRESAMPLE_VERSION_MAJOR 6
     * }
     */
    public static int LIBSWRESAMPLE_VERSION_MAJOR() {
        return LIBSWRESAMPLE_VERSION_MAJOR;
    }
    private static final int LIBSWRESAMPLE_VERSION_MINOR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LIBSWRESAMPLE_VERSION_MINOR 2
     * }
     */
    public static int LIBSWRESAMPLE_VERSION_MINOR() {
        return LIBSWRESAMPLE_VERSION_MINOR;
    }
    private static final int LIBSWRESAMPLE_VERSION_MICRO = (int)100L;
    /**
     * {@snippet lang=c :
     * #define LIBSWRESAMPLE_VERSION_MICRO 100
     * }
     */
    public static int LIBSWRESAMPLE_VERSION_MICRO() {
        return LIBSWRESAMPLE_VERSION_MICRO;
    }
    private static final int SWR_FLAG_RESAMPLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SWR_FLAG_RESAMPLE 1
     * }
     */
    public static int SWR_FLAG_RESAMPLE() {
        return SWR_FLAG_RESAMPLE;
    }
    private static final int LIBSWSCALE_VERSION_MAJOR = (int)9L;
    /**
     * {@snippet lang=c :
     * #define LIBSWSCALE_VERSION_MAJOR 9
     * }
     */
    public static int LIBSWSCALE_VERSION_MAJOR() {
        return LIBSWSCALE_VERSION_MAJOR;
    }
    private static final int LIBSWSCALE_VERSION_MINOR = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LIBSWSCALE_VERSION_MINOR 3
     * }
     */
    public static int LIBSWSCALE_VERSION_MINOR() {
        return LIBSWSCALE_VERSION_MINOR;
    }
    private static final int LIBSWSCALE_VERSION_MICRO = (int)100L;
    /**
     * {@snippet lang=c :
     * #define LIBSWSCALE_VERSION_MICRO 100
     * }
     */
    public static int LIBSWSCALE_VERSION_MICRO() {
        return LIBSWSCALE_VERSION_MICRO;
    }
    private static final int SWS_SRC_V_CHR_DROP_MASK = (int)196608L;
    /**
     * {@snippet lang=c :
     * #define SWS_SRC_V_CHR_DROP_MASK 196608
     * }
     */
    public static int SWS_SRC_V_CHR_DROP_MASK() {
        return SWS_SRC_V_CHR_DROP_MASK;
    }
    private static final int SWS_SRC_V_CHR_DROP_SHIFT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SWS_SRC_V_CHR_DROP_SHIFT 16
     * }
     */
    public static int SWS_SRC_V_CHR_DROP_SHIFT() {
        return SWS_SRC_V_CHR_DROP_SHIFT;
    }
    private static final int SWS_PARAM_DEFAULT = (int)123456L;
    /**
     * {@snippet lang=c :
     * #define SWS_PARAM_DEFAULT 123456
     * }
     */
    public static int SWS_PARAM_DEFAULT() {
        return SWS_PARAM_DEFAULT;
    }
    private static final int SWS_CS_ITU709 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_ITU709 1
     * }
     */
    public static int SWS_CS_ITU709() {
        return SWS_CS_ITU709;
    }
    private static final int SWS_CS_FCC = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_FCC 4
     * }
     */
    public static int SWS_CS_FCC() {
        return SWS_CS_FCC;
    }
    private static final int SWS_CS_ITU601 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_ITU601 5
     * }
     */
    public static int SWS_CS_ITU601() {
        return SWS_CS_ITU601;
    }
    private static final int SWS_CS_ITU624 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_ITU624 5
     * }
     */
    public static int SWS_CS_ITU624() {
        return SWS_CS_ITU624;
    }
    private static final int SWS_CS_SMPTE170M = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_SMPTE170M 5
     * }
     */
    public static int SWS_CS_SMPTE170M() {
        return SWS_CS_SMPTE170M;
    }
    private static final int SWS_CS_SMPTE240M = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_SMPTE240M 7
     * }
     */
    public static int SWS_CS_SMPTE240M() {
        return SWS_CS_SMPTE240M;
    }
    private static final int SWS_CS_DEFAULT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_DEFAULT 5
     * }
     */
    public static int SWS_CS_DEFAULT() {
        return SWS_CS_DEFAULT;
    }
    private static final int SWS_CS_BT2020 = (int)9L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_BT2020 9
     * }
     */
    public static int SWS_CS_BT2020() {
        return SWS_CS_BT2020;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = ffmpeg_includes_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *va_list
     * }
     */
    public static final AddressLayout va_list = ffmpeg_includes_h.C_POINTER;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __va_start(va_list *, ...)
     * }
     */
    public static class __va_start {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                ffmpeg_includes_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__va_start");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __va_start(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __va_start(va_list *, ...)
         * }
         */
        public static __va_start makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __va_start(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__va_start", x0, x1);
                }
                 spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long size_t
     * }
     */
    public static final OfLong size_t = ffmpeg_includes_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = ffmpeg_includes_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long intptr_t
     * }
     */
    public static final OfLong intptr_t = ffmpeg_includes_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef _Bool __vcrt_bool
     * }
     */
    public static final OfBoolean __vcrt_bool = ffmpeg_includes_h.C_BOOL;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wchar_t
     * }
     */
    public static final OfShort wchar_t = ffmpeg_includes_h.C_SHORT;

    private static class __security_init_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__security_init_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static FunctionDescriptor __security_init_cookie$descriptor() {
        return __security_init_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MethodHandle __security_init_cookie$handle() {
        return __security_init_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MemorySegment __security_init_cookie$address() {
        return __security_init_cookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static void __security_init_cookie() {
        var mh$ = __security_init_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_init_cookie");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_check_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__security_check_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __security_check_cookie$descriptor() {
        return __security_check_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __security_check_cookie$handle() {
        return __security_check_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __security_check_cookie$address() {
        return __security_check_cookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static void __security_check_cookie(long _StackCookie) {
        var mh$ = __security_check_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_check_cookie", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __report_gsfailure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__report_gsfailure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __report_gsfailure$descriptor() {
        return __report_gsfailure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __report_gsfailure$handle() {
        return __report_gsfailure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __report_gsfailure$address() {
        return __report_gsfailure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static void __report_gsfailure(long _StackCookie) {
        var mh$ = __report_gsfailure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__report_gsfailure", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_cookie$constants {
        public static final OfLong LAYOUT = ffmpeg_includes_h.C_LONG_LONG;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__security_cookie").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static OfLong __security_cookie$layout() {
        return __security_cookie$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static MemorySegment __security_cookie$segment() {
        return __security_cookie$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static long __security_cookie() {
        return __security_cookie$constants.SEGMENT.get(__security_cookie$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static void __security_cookie(long varValue) {
        __security_cookie$constants.SEGMENT.set(__security_cookie$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = ffmpeg_includes_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = ffmpeg_includes_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = ffmpeg_includes_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = ffmpeg_includes_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = ffmpeg_includes_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = ffmpeg_includes_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = ffmpeg_includes_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = ffmpeg_includes_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_least8_t
     * }
     */
    public static final OfByte int_least8_t = ffmpeg_includes_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int_least16_t
     * }
     */
    public static final OfShort int_least16_t = ffmpeg_includes_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int_least32_t
     * }
     */
    public static final OfInt int_least32_t = ffmpeg_includes_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int_least64_t
     * }
     */
    public static final OfLong int_least64_t = ffmpeg_includes_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = ffmpeg_includes_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = ffmpeg_includes_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = ffmpeg_includes_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = ffmpeg_includes_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = ffmpeg_includes_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int int_fast16_t
     * }
     */
    public static final OfInt int_fast16_t = ffmpeg_includes_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = ffmpeg_includes_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = ffmpeg_includes_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = ffmpeg_includes_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_fast16_t
     * }
     */
    public static final OfInt uint_fast16_t = ffmpeg_includes_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = ffmpeg_includes_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = ffmpeg_includes_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long intmax_t
     * }
     */
    public static final OfLong intmax_t = ffmpeg_includes_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = ffmpeg_includes_h.C_LONG_LONG;
    private static final int AV_SAMPLE_FMT_NONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_NONE = -1
     * }
     */
    public static int AV_SAMPLE_FMT_NONE() {
        return AV_SAMPLE_FMT_NONE;
    }
    private static final int AV_SAMPLE_FMT_U8 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_U8 = 0
     * }
     */
    public static int AV_SAMPLE_FMT_U8() {
        return AV_SAMPLE_FMT_U8;
    }
    private static final int AV_SAMPLE_FMT_S16 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_S16 = 1
     * }
     */
    public static int AV_SAMPLE_FMT_S16() {
        return AV_SAMPLE_FMT_S16;
    }
    private static final int AV_SAMPLE_FMT_S32 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_S32 = 2
     * }
     */
    public static int AV_SAMPLE_FMT_S32() {
        return AV_SAMPLE_FMT_S32;
    }
    private static final int AV_SAMPLE_FMT_FLT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_FLT = 3
     * }
     */
    public static int AV_SAMPLE_FMT_FLT() {
        return AV_SAMPLE_FMT_FLT;
    }
    private static final int AV_SAMPLE_FMT_DBL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_DBL = 4
     * }
     */
    public static int AV_SAMPLE_FMT_DBL() {
        return AV_SAMPLE_FMT_DBL;
    }
    private static final int AV_SAMPLE_FMT_U8P = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_U8P = 5
     * }
     */
    public static int AV_SAMPLE_FMT_U8P() {
        return AV_SAMPLE_FMT_U8P;
    }
    private static final int AV_SAMPLE_FMT_S16P = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_S16P = 6
     * }
     */
    public static int AV_SAMPLE_FMT_S16P() {
        return AV_SAMPLE_FMT_S16P;
    }
    private static final int AV_SAMPLE_FMT_S32P = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_S32P = 7
     * }
     */
    public static int AV_SAMPLE_FMT_S32P() {
        return AV_SAMPLE_FMT_S32P;
    }
    private static final int AV_SAMPLE_FMT_FLTP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_FLTP = 8
     * }
     */
    public static int AV_SAMPLE_FMT_FLTP() {
        return AV_SAMPLE_FMT_FLTP;
    }
    private static final int AV_SAMPLE_FMT_DBLP = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_DBLP = 9
     * }
     */
    public static int AV_SAMPLE_FMT_DBLP() {
        return AV_SAMPLE_FMT_DBLP;
    }
    private static final int AV_SAMPLE_FMT_S64 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_S64 = 10
     * }
     */
    public static int AV_SAMPLE_FMT_S64() {
        return AV_SAMPLE_FMT_S64;
    }
    private static final int AV_SAMPLE_FMT_S64P = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_S64P = 11
     * }
     */
    public static int AV_SAMPLE_FMT_S64P() {
        return AV_SAMPLE_FMT_S64P;
    }
    private static final int AV_SAMPLE_FMT_NB = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVSampleFormat.AV_SAMPLE_FMT_NB = 12
     * }
     */
    public static int AV_SAMPLE_FMT_NB() {
        return AV_SAMPLE_FMT_NB;
    }

    private static class av_get_sample_fmt_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_sample_fmt_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_get_sample_fmt_name(enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_get_sample_fmt_name$descriptor() {
        return av_get_sample_fmt_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_get_sample_fmt_name(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_get_sample_fmt_name$handle() {
        return av_get_sample_fmt_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_get_sample_fmt_name(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_get_sample_fmt_name$address() {
        return av_get_sample_fmt_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_get_sample_fmt_name(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_get_sample_fmt_name(int sample_fmt) {
        var mh$ = av_get_sample_fmt_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_sample_fmt_name", sample_fmt);
            }
            return (MemorySegment)mh$.invokeExact(sample_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_sample_fmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_sample_fmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_sample_fmt(const char *name)
     * }
     */
    public static FunctionDescriptor av_get_sample_fmt$descriptor() {
        return av_get_sample_fmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_sample_fmt(const char *name)
     * }
     */
    public static MethodHandle av_get_sample_fmt$handle() {
        return av_get_sample_fmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_sample_fmt(const char *name)
     * }
     */
    public static MemorySegment av_get_sample_fmt$address() {
        return av_get_sample_fmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_sample_fmt(const char *name)
     * }
     */
    public static int av_get_sample_fmt(MemorySegment name) {
        var mh$ = av_get_sample_fmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_sample_fmt", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_alt_sample_fmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_alt_sample_fmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_alt_sample_fmt(enum AVSampleFormat sample_fmt, int planar)
     * }
     */
    public static FunctionDescriptor av_get_alt_sample_fmt$descriptor() {
        return av_get_alt_sample_fmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_alt_sample_fmt(enum AVSampleFormat sample_fmt, int planar)
     * }
     */
    public static MethodHandle av_get_alt_sample_fmt$handle() {
        return av_get_alt_sample_fmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_alt_sample_fmt(enum AVSampleFormat sample_fmt, int planar)
     * }
     */
    public static MemorySegment av_get_alt_sample_fmt$address() {
        return av_get_alt_sample_fmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_alt_sample_fmt(enum AVSampleFormat sample_fmt, int planar)
     * }
     */
    public static int av_get_alt_sample_fmt(int sample_fmt, int planar) {
        var mh$ = av_get_alt_sample_fmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_alt_sample_fmt", sample_fmt, planar);
            }
            return (int)mh$.invokeExact(sample_fmt, planar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_packed_sample_fmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_packed_sample_fmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_packed_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_get_packed_sample_fmt$descriptor() {
        return av_get_packed_sample_fmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_packed_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_get_packed_sample_fmt$handle() {
        return av_get_packed_sample_fmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_packed_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_get_packed_sample_fmt$address() {
        return av_get_packed_sample_fmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_packed_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static int av_get_packed_sample_fmt(int sample_fmt) {
        var mh$ = av_get_packed_sample_fmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_packed_sample_fmt", sample_fmt);
            }
            return (int)mh$.invokeExact(sample_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_planar_sample_fmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_planar_sample_fmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_planar_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_get_planar_sample_fmt$descriptor() {
        return av_get_planar_sample_fmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_planar_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_get_planar_sample_fmt$handle() {
        return av_get_planar_sample_fmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_planar_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_get_planar_sample_fmt$address() {
        return av_get_planar_sample_fmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVSampleFormat av_get_planar_sample_fmt(enum AVSampleFormat sample_fmt)
     * }
     */
    public static int av_get_planar_sample_fmt(int sample_fmt) {
        var mh$ = av_get_planar_sample_fmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_planar_sample_fmt", sample_fmt);
            }
            return (int)mh$.invokeExact(sample_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_sample_fmt_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_sample_fmt_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_get_sample_fmt_string(char *buf, int buf_size, enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_get_sample_fmt_string$descriptor() {
        return av_get_sample_fmt_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_get_sample_fmt_string(char *buf, int buf_size, enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_get_sample_fmt_string$handle() {
        return av_get_sample_fmt_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *av_get_sample_fmt_string(char *buf, int buf_size, enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_get_sample_fmt_string$address() {
        return av_get_sample_fmt_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *av_get_sample_fmt_string(char *buf, int buf_size, enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_get_sample_fmt_string(MemorySegment buf, int buf_size, int sample_fmt) {
        var mh$ = av_get_sample_fmt_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_sample_fmt_string", buf, buf_size, sample_fmt);
            }
            return (MemorySegment)mh$.invokeExact(buf, buf_size, sample_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_bytes_per_sample {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_bytes_per_sample");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_bytes_per_sample(enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_get_bytes_per_sample$descriptor() {
        return av_get_bytes_per_sample.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_bytes_per_sample(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_get_bytes_per_sample$handle() {
        return av_get_bytes_per_sample.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_bytes_per_sample(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_get_bytes_per_sample$address() {
        return av_get_bytes_per_sample.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_bytes_per_sample(enum AVSampleFormat sample_fmt)
     * }
     */
    public static int av_get_bytes_per_sample(int sample_fmt) {
        var mh$ = av_get_bytes_per_sample.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_bytes_per_sample", sample_fmt);
            }
            return (int)mh$.invokeExact(sample_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_sample_fmt_is_planar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_sample_fmt_is_planar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_sample_fmt_is_planar(enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_sample_fmt_is_planar$descriptor() {
        return av_sample_fmt_is_planar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_sample_fmt_is_planar(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_sample_fmt_is_planar$handle() {
        return av_sample_fmt_is_planar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_sample_fmt_is_planar(enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_sample_fmt_is_planar$address() {
        return av_sample_fmt_is_planar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_sample_fmt_is_planar(enum AVSampleFormat sample_fmt)
     * }
     */
    public static int av_sample_fmt_is_planar(int sample_fmt) {
        var mh$ = av_sample_fmt_is_planar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_sample_fmt_is_planar", sample_fmt);
            }
            return (int)mh$.invokeExact(sample_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_samples_get_buffer_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_samples_get_buffer_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_samples_get_buffer_size(int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static FunctionDescriptor av_samples_get_buffer_size$descriptor() {
        return av_samples_get_buffer_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_samples_get_buffer_size(int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MethodHandle av_samples_get_buffer_size$handle() {
        return av_samples_get_buffer_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_samples_get_buffer_size(int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MemorySegment av_samples_get_buffer_size$address() {
        return av_samples_get_buffer_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_samples_get_buffer_size(int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static int av_samples_get_buffer_size(MemorySegment linesize, int nb_channels, int nb_samples, int sample_fmt, int align) {
        var mh$ = av_samples_get_buffer_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_samples_get_buffer_size", linesize, nb_channels, nb_samples, sample_fmt, align);
            }
            return (int)mh$.invokeExact(linesize, nb_channels, nb_samples, sample_fmt, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_samples_fill_arrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_samples_fill_arrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_samples_fill_arrays(uint8_t **audio_data, int *linesize, const uint8_t *buf, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static FunctionDescriptor av_samples_fill_arrays$descriptor() {
        return av_samples_fill_arrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_samples_fill_arrays(uint8_t **audio_data, int *linesize, const uint8_t *buf, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MethodHandle av_samples_fill_arrays$handle() {
        return av_samples_fill_arrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_samples_fill_arrays(uint8_t **audio_data, int *linesize, const uint8_t *buf, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MemorySegment av_samples_fill_arrays$address() {
        return av_samples_fill_arrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_samples_fill_arrays(uint8_t **audio_data, int *linesize, const uint8_t *buf, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static int av_samples_fill_arrays(MemorySegment audio_data, MemorySegment linesize, MemorySegment buf, int nb_channels, int nb_samples, int sample_fmt, int align) {
        var mh$ = av_samples_fill_arrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_samples_fill_arrays", audio_data, linesize, buf, nb_channels, nb_samples, sample_fmt, align);
            }
            return (int)mh$.invokeExact(audio_data, linesize, buf, nb_channels, nb_samples, sample_fmt, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_samples_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_samples_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_samples_alloc(uint8_t **audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static FunctionDescriptor av_samples_alloc$descriptor() {
        return av_samples_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_samples_alloc(uint8_t **audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MethodHandle av_samples_alloc$handle() {
        return av_samples_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_samples_alloc(uint8_t **audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MemorySegment av_samples_alloc$address() {
        return av_samples_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_samples_alloc(uint8_t **audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static int av_samples_alloc(MemorySegment audio_data, MemorySegment linesize, int nb_channels, int nb_samples, int sample_fmt, int align) {
        var mh$ = av_samples_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_samples_alloc", audio_data, linesize, nb_channels, nb_samples, sample_fmt, align);
            }
            return (int)mh$.invokeExact(audio_data, linesize, nb_channels, nb_samples, sample_fmt, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_samples_alloc_array_and_samples {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_samples_alloc_array_and_samples");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_samples_alloc_array_and_samples(uint8_t ***audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static FunctionDescriptor av_samples_alloc_array_and_samples$descriptor() {
        return av_samples_alloc_array_and_samples.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_samples_alloc_array_and_samples(uint8_t ***audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MethodHandle av_samples_alloc_array_and_samples$handle() {
        return av_samples_alloc_array_and_samples.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_samples_alloc_array_and_samples(uint8_t ***audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static MemorySegment av_samples_alloc_array_and_samples$address() {
        return av_samples_alloc_array_and_samples.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_samples_alloc_array_and_samples(uint8_t ***audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     * }
     */
    public static int av_samples_alloc_array_and_samples(MemorySegment audio_data, MemorySegment linesize, int nb_channels, int nb_samples, int sample_fmt, int align) {
        var mh$ = av_samples_alloc_array_and_samples.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_samples_alloc_array_and_samples", audio_data, linesize, nb_channels, nb_samples, sample_fmt, align);
            }
            return (int)mh$.invokeExact(audio_data, linesize, nb_channels, nb_samples, sample_fmt, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_samples_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_samples_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_samples_copy(uint8_t *const *dst, uint8_t *const *src, int dst_offset, int src_offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_samples_copy$descriptor() {
        return av_samples_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_samples_copy(uint8_t *const *dst, uint8_t *const *src, int dst_offset, int src_offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_samples_copy$handle() {
        return av_samples_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_samples_copy(uint8_t *const *dst, uint8_t *const *src, int dst_offset, int src_offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_samples_copy$address() {
        return av_samples_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_samples_copy(uint8_t *const *dst, uint8_t *const *src, int dst_offset, int src_offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static int av_samples_copy(MemorySegment dst, MemorySegment src, int dst_offset, int src_offset, int nb_samples, int nb_channels, int sample_fmt) {
        var mh$ = av_samples_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_samples_copy", dst, src, dst_offset, src_offset, nb_samples, nb_channels, sample_fmt);
            }
            return (int)mh$.invokeExact(dst, src, dst_offset, src_offset, nb_samples, nb_channels, sample_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_samples_set_silence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_samples_set_silence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_samples_set_silence(uint8_t *const *audio_data, int offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static FunctionDescriptor av_samples_set_silence$descriptor() {
        return av_samples_set_silence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_samples_set_silence(uint8_t *const *audio_data, int offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static MethodHandle av_samples_set_silence$handle() {
        return av_samples_set_silence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_samples_set_silence(uint8_t *const *audio_data, int offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static MemorySegment av_samples_set_silence$address() {
        return av_samples_set_silence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_samples_set_silence(uint8_t *const *audio_data, int offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
     * }
     */
    public static int av_samples_set_silence(MemorySegment audio_data, int offset, int nb_samples, int nb_channels, int sample_fmt) {
        var mh$ = av_samples_set_silence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_samples_set_silence", audio_data, offset, nb_samples, nb_channels, sample_fmt);
            }
            return (int)mh$.invokeExact(audio_data, offset, nb_samples, nb_channels, sample_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avutil_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avutil_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static FunctionDescriptor avutil_version$descriptor() {
        return avutil_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static MethodHandle avutil_version$handle() {
        return avutil_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static MemorySegment avutil_version$address() {
        return avutil_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static int avutil_version() {
        var mh$ = avutil_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avutil_version");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_version_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_version_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static FunctionDescriptor av_version_info$descriptor() {
        return av_version_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static MethodHandle av_version_info$handle() {
        return av_version_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static MemorySegment av_version_info$address() {
        return av_version_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static MemorySegment av_version_info() {
        var mh$ = av_version_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_version_info");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avutil_configuration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avutil_configuration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static FunctionDescriptor avutil_configuration$descriptor() {
        return avutil_configuration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static MethodHandle avutil_configuration$handle() {
        return avutil_configuration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static MemorySegment avutil_configuration$address() {
        return avutil_configuration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static MemorySegment avutil_configuration() {
        var mh$ = avutil_configuration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avutil_configuration");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avutil_license {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avutil_license");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static FunctionDescriptor avutil_license$descriptor() {
        return avutil_license.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static MethodHandle avutil_license$handle() {
        return avutil_license.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static MemorySegment avutil_license$address() {
        return avutil_license.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static MemorySegment avutil_license() {
        var mh$ = avutil_license.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avutil_license");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AVMEDIA_TYPE_UNKNOWN = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_UNKNOWN = -1
     * }
     */
    public static int AVMEDIA_TYPE_UNKNOWN() {
        return AVMEDIA_TYPE_UNKNOWN;
    }
    private static final int AVMEDIA_TYPE_VIDEO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_VIDEO = 0
     * }
     */
    public static int AVMEDIA_TYPE_VIDEO() {
        return AVMEDIA_TYPE_VIDEO;
    }
    private static final int AVMEDIA_TYPE_AUDIO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_AUDIO = 1
     * }
     */
    public static int AVMEDIA_TYPE_AUDIO() {
        return AVMEDIA_TYPE_AUDIO;
    }
    private static final int AVMEDIA_TYPE_DATA = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_DATA = 2
     * }
     */
    public static int AVMEDIA_TYPE_DATA() {
        return AVMEDIA_TYPE_DATA;
    }
    private static final int AVMEDIA_TYPE_SUBTITLE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_SUBTITLE = 3
     * }
     */
    public static int AVMEDIA_TYPE_SUBTITLE() {
        return AVMEDIA_TYPE_SUBTITLE;
    }
    private static final int AVMEDIA_TYPE_ATTACHMENT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_ATTACHMENT = 4
     * }
     */
    public static int AVMEDIA_TYPE_ATTACHMENT() {
        return AVMEDIA_TYPE_ATTACHMENT;
    }
    private static final int AVMEDIA_TYPE_NB = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_NB = 5
     * }
     */
    public static int AVMEDIA_TYPE_NB() {
        return AVMEDIA_TYPE_NB;
    }

    private static class av_get_media_type_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_media_type_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static FunctionDescriptor av_get_media_type_string$descriptor() {
        return av_get_media_type_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static MethodHandle av_get_media_type_string$handle() {
        return av_get_media_type_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static MemorySegment av_get_media_type_string$address() {
        return av_get_media_type_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static MemorySegment av_get_media_type_string(int media_type) {
        var mh$ = av_get_media_type_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_media_type_string", media_type);
            }
            return (MemorySegment)mh$.invokeExact(media_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_PICTURE_TYPE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_NONE = 0
     * }
     */
    public static int AV_PICTURE_TYPE_NONE() {
        return AV_PICTURE_TYPE_NONE;
    }
    private static final int AV_PICTURE_TYPE_I = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_I = 1
     * }
     */
    public static int AV_PICTURE_TYPE_I() {
        return AV_PICTURE_TYPE_I;
    }
    private static final int AV_PICTURE_TYPE_P = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_P = 2
     * }
     */
    public static int AV_PICTURE_TYPE_P() {
        return AV_PICTURE_TYPE_P;
    }
    private static final int AV_PICTURE_TYPE_B = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_B = 3
     * }
     */
    public static int AV_PICTURE_TYPE_B() {
        return AV_PICTURE_TYPE_B;
    }
    private static final int AV_PICTURE_TYPE_S = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_S = 4
     * }
     */
    public static int AV_PICTURE_TYPE_S() {
        return AV_PICTURE_TYPE_S;
    }
    private static final int AV_PICTURE_TYPE_SI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_SI = 5
     * }
     */
    public static int AV_PICTURE_TYPE_SI() {
        return AV_PICTURE_TYPE_SI;
    }
    private static final int AV_PICTURE_TYPE_SP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_SP = 6
     * }
     */
    public static int AV_PICTURE_TYPE_SP() {
        return AV_PICTURE_TYPE_SP;
    }
    private static final int AV_PICTURE_TYPE_BI = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_BI = 7
     * }
     */
    public static int AV_PICTURE_TYPE_BI() {
        return AV_PICTURE_TYPE_BI;
    }

    private static class av_get_picture_type_char {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_CHAR,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_picture_type_char");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static FunctionDescriptor av_get_picture_type_char$descriptor() {
        return av_get_picture_type_char.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static MethodHandle av_get_picture_type_char$handle() {
        return av_get_picture_type_char.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static MemorySegment av_get_picture_type_char$address() {
        return av_get_picture_type_char.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static byte av_get_picture_type_char(int pict_type) {
        var mh$ = av_get_picture_type_char.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_picture_type_char", pict_type);
            }
            return (byte)mh$.invokeExact(pict_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef _Bool __crt_bool
     * }
     */
    public static final OfBoolean __crt_bool = ffmpeg_includes_h.C_BOOL;

    private static class _invalid_parameter_noinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_invalid_parameter_noinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo$descriptor() {
        return _invalid_parameter_noinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo$handle() {
        return _invalid_parameter_noinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static MemorySegment _invalid_parameter_noinfo$address() {
        return _invalid_parameter_noinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static void _invalid_parameter_noinfo() {
        var mh$ = _invalid_parameter_noinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invalid_parameter_noinfo_noreturn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_invalid_parameter_noinfo_noreturn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo_noreturn$descriptor() {
        return _invalid_parameter_noinfo_noreturn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo_noreturn$handle() {
        return _invalid_parameter_noinfo_noreturn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MemorySegment _invalid_parameter_noinfo_noreturn$address() {
        return _invalid_parameter_noinfo_noreturn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static void _invalid_parameter_noinfo_noreturn() {
        var mh$ = _invalid_parameter_noinfo_noreturn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo_noreturn");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invoke_watson {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_invoke_watson");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static FunctionDescriptor _invoke_watson$descriptor() {
        return _invoke_watson.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MethodHandle _invoke_watson$handle() {
        return _invoke_watson.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MemorySegment _invoke_watson$address() {
        return _invoke_watson.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static void _invoke_watson(MemorySegment _Expression, MemorySegment _FunctionName, MemorySegment _FileName, int _LineNo, long _Reserved) {
        var mh$ = _invoke_watson.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invoke_watson", _Expression, _FunctionName, _FileName, _LineNo, _Reserved);
            }
            mh$.invokeExact(_Expression, _FunctionName, _FileName, _LineNo, _Reserved);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = ffmpeg_includes_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wint_t
     * }
     */
    public static final OfShort wint_t = ffmpeg_includes_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wctype_t
     * }
     */
    public static final OfShort wctype_t = ffmpeg_includes_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef long __time32_t
     * }
     */
    public static final OfInt __time32_t = ffmpeg_includes_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __time64_t
     * }
     */
    public static final OfLong __time64_t = ffmpeg_includes_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __crt_locale_pointers *_locale_t
     * }
     */
    public static final AddressLayout _locale_t = ffmpeg_includes_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __time64_t time_t
     * }
     */
    public static final OfLong time_t = ffmpeg_includes_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = ffmpeg_includes_h.C_LONG_LONG;

    private static class _errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static FunctionDescriptor _errno$descriptor() {
        return _errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MethodHandle _errno$handle() {
        return _errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MemorySegment _errno$address() {
        return _errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MemorySegment _errno() {
        var mh$ = _errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_errno");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static FunctionDescriptor _set_errno$descriptor() {
        return _set_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static MethodHandle _set_errno$handle() {
        return _set_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static MemorySegment _set_errno$address() {
        return _set_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static int _set_errno(int _Value) {
        var mh$ = _set_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_errno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static FunctionDescriptor _get_errno$descriptor() {
        return _get_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static MethodHandle _get_errno$handle() {
        return _get_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static MemorySegment _get_errno$address() {
        return _get_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static int _get_errno(MemorySegment _Value) {
        var mh$ = _get_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_errno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static FunctionDescriptor __doserrno$descriptor() {
        return __doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MethodHandle __doserrno$handle() {
        return __doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MemorySegment __doserrno$address() {
        return __doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MemorySegment __doserrno() {
        var mh$ = __doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__doserrno");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static FunctionDescriptor _set_doserrno$descriptor() {
        return _set_doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static MethodHandle _set_doserrno$handle() {
        return _set_doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static MemorySegment _set_doserrno$address() {
        return _set_doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static int _set_doserrno(int _Value) {
        var mh$ = _set_doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_doserrno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static FunctionDescriptor _get_doserrno$descriptor() {
        return _get_doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static MethodHandle _get_doserrno$handle() {
        return _get_doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static MemorySegment _get_doserrno$address() {
        return _get_doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static int _get_doserrno(MemorySegment _Value) {
        var mh$ = _get_doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_doserrno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static long imaxabs(long _Number) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _Lldiv_t.layout(),
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long _Numerator, long _Denominator) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoimax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoimax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoimax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoimax_l$descriptor() {
        return _strtoimax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoimax_l$handle() {
        return _strtoimax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoimax_l$address() {
        return _strtoimax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoimax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoimax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoimax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoumax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoumax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_strtoumax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoumax_l$descriptor() {
        return _strtoumax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoumax_l$handle() {
        return _strtoumax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoumax_l$address() {
        return _strtoumax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoumax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoumax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoumax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoimax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoimax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoimax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoimax_l$descriptor() {
        return _wcstoimax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoimax_l$handle() {
        return _wcstoimax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoimax_l$address() {
        return _wcstoimax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoimax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoimax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoimax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoumax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoumax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wcstoumax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoumax_l$descriptor() {
        return _wcstoumax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoumax_l$handle() {
        return _wcstoumax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoumax_l$address() {
        return _wcstoumax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoumax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoumax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoumax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float float_t
     * }
     */
    public static final OfFloat float_t = ffmpeg_includes_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double double_t
     * }
     */
    public static final OfDouble double_t = ffmpeg_includes_h.C_DOUBLE;

    private static class _HUGE$constants {
        public static final OfDouble LAYOUT = ffmpeg_includes_h.C_DOUBLE;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_HUGE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static OfDouble _HUGE$layout() {
        return _HUGE$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static MemorySegment _HUGE$segment() {
        return _HUGE$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static double _HUGE() {
        return _HUGE$constants.SEGMENT.get(_HUGE$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static void _HUGE(double varValue) {
        _HUGE$constants.SEGMENT.set(_HUGE$constants.LAYOUT, 0L, varValue);
    }

    private static class _fperrraise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fperrraise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static FunctionDescriptor _fperrraise$descriptor() {
        return _fperrraise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static MethodHandle _fperrraise$handle() {
        return _fperrraise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static MemorySegment _fperrraise$address() {
        return _fperrraise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static void _fperrraise(int _Except) {
        var mh$ = _fperrraise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fperrraise", _Except);
            }
            mh$.invokeExact(_Except);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_dclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static FunctionDescriptor _dclass$descriptor() {
        return _dclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static MethodHandle _dclass$handle() {
        return _dclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static MemorySegment _dclass$address() {
        return _dclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static short _dclass(double _X) {
        var mh$ = _dclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dclass", _X);
            }
            return (short)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ldclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static FunctionDescriptor _ldclass$descriptor() {
        return _ldclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static MethodHandle _ldclass$handle() {
        return _ldclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static MemorySegment _ldclass$address() {
        return _ldclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static short _ldclass(double _X) {
        var mh$ = _ldclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldclass", _X);
            }
            return (short)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fdclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static FunctionDescriptor _fdclass$descriptor() {
        return _fdclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static MethodHandle _fdclass$handle() {
        return _fdclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static MemorySegment _fdclass$address() {
        return _fdclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static short _fdclass(float _X) {
        var mh$ = _fdclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdclass", _X);
            }
            return (short)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_dsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static FunctionDescriptor _dsign$descriptor() {
        return _dsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static MethodHandle _dsign$handle() {
        return _dsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static MemorySegment _dsign$address() {
        return _dsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static int _dsign(double _X) {
        var mh$ = _dsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dsign", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ldsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static FunctionDescriptor _ldsign$descriptor() {
        return _ldsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static MethodHandle _ldsign$handle() {
        return _ldsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static MemorySegment _ldsign$address() {
        return _ldsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static int _ldsign(double _X) {
        var mh$ = _ldsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldsign", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fdsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static FunctionDescriptor _fdsign$descriptor() {
        return _fdsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static MethodHandle _fdsign$handle() {
        return _fdsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static MemorySegment _fdsign$address() {
        return _fdsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static int _fdsign(float _X) {
        var mh$ = _fdsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdsign", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dpcomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_dpcomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor _dpcomp$descriptor() {
        return _dpcomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static MethodHandle _dpcomp$handle() {
        return _dpcomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static MemorySegment _dpcomp$address() {
        return _dpcomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static int _dpcomp(double _X, double _Y) {
        var mh$ = _dpcomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dpcomp", _X, _Y);
            }
            return (int)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldpcomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ldpcomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor _ldpcomp$descriptor() {
        return _ldpcomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static MethodHandle _ldpcomp$handle() {
        return _ldpcomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static MemorySegment _ldpcomp$address() {
        return _ldpcomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static int _ldpcomp(double _X, double _Y) {
        var mh$ = _ldpcomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldpcomp", _X, _Y);
            }
            return (int)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdpcomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fdpcomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor _fdpcomp$descriptor() {
        return _fdpcomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static MethodHandle _fdpcomp$handle() {
        return _fdpcomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static MemorySegment _fdpcomp$address() {
        return _fdpcomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static int _fdpcomp(float _X, float _Y) {
        var mh$ = _fdpcomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdpcomp", _X, _Y);
            }
            return (int)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dtest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_dtest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static FunctionDescriptor _dtest$descriptor() {
        return _dtest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static MethodHandle _dtest$handle() {
        return _dtest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static MemorySegment _dtest$address() {
        return _dtest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static short _dtest(MemorySegment _Px) {
        var mh$ = _dtest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dtest", _Px);
            }
            return (short)mh$.invokeExact(_Px);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldtest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ldtest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static FunctionDescriptor _ldtest$descriptor() {
        return _ldtest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static MethodHandle _ldtest$handle() {
        return _ldtest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static MemorySegment _ldtest$address() {
        return _ldtest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static short _ldtest(MemorySegment _Px) {
        var mh$ = _ldtest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldtest", _Px);
            }
            return (short)mh$.invokeExact(_Px);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdtest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fdtest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static FunctionDescriptor _fdtest$descriptor() {
        return _fdtest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static MethodHandle _fdtest$handle() {
        return _fdtest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static MemorySegment _fdtest$address() {
        return _fdtest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static short _fdtest(MemorySegment _Px) {
        var mh$ = _fdtest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdtest", _Px);
            }
            return (short)mh$.invokeExact(_Px);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _d_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_d_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static FunctionDescriptor _d_int$descriptor() {
        return _d_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static MethodHandle _d_int$handle() {
        return _d_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static MemorySegment _d_int$address() {
        return _d_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static short _d_int(MemorySegment _Px, short _Xexp) {
        var mh$ = _d_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_d_int", _Px, _Xexp);
            }
            return (short)mh$.invokeExact(_Px, _Xexp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ld_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ld_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static FunctionDescriptor _ld_int$descriptor() {
        return _ld_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static MethodHandle _ld_int$handle() {
        return _ld_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static MemorySegment _ld_int$address() {
        return _ld_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static short _ld_int(MemorySegment _Px, short _Xexp) {
        var mh$ = _ld_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ld_int", _Px, _Xexp);
            }
            return (short)mh$.invokeExact(_Px, _Xexp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fd_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fd_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static FunctionDescriptor _fd_int$descriptor() {
        return _fd_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static MethodHandle _fd_int$handle() {
        return _fd_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static MemorySegment _fd_int$address() {
        return _fd_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static short _fd_int(MemorySegment _Px, short _Xexp) {
        var mh$ = _fd_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fd_int", _Px, _Xexp);
            }
            return (short)mh$.invokeExact(_Px, _Xexp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_dscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static FunctionDescriptor _dscale$descriptor() {
        return _dscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static MethodHandle _dscale$handle() {
        return _dscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static MemorySegment _dscale$address() {
        return _dscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static short _dscale(MemorySegment _Px, int _Lexp) {
        var mh$ = _dscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dscale", _Px, _Lexp);
            }
            return (short)mh$.invokeExact(_Px, _Lexp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ldscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static FunctionDescriptor _ldscale$descriptor() {
        return _ldscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static MethodHandle _ldscale$handle() {
        return _ldscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static MemorySegment _ldscale$address() {
        return _ldscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static short _ldscale(MemorySegment _Px, int _Lexp) {
        var mh$ = _ldscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldscale", _Px, _Lexp);
            }
            return (short)mh$.invokeExact(_Px, _Lexp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fdscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static FunctionDescriptor _fdscale$descriptor() {
        return _fdscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static MethodHandle _fdscale$handle() {
        return _fdscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static MemorySegment _fdscale$address() {
        return _fdscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static short _fdscale(MemorySegment _Px, int _Lexp) {
        var mh$ = _fdscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdscale", _Px, _Lexp);
            }
            return (short)mh$.invokeExact(_Px, _Lexp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dunscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_dunscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static FunctionDescriptor _dunscale$descriptor() {
        return _dunscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static MethodHandle _dunscale$handle() {
        return _dunscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static MemorySegment _dunscale$address() {
        return _dunscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static short _dunscale(MemorySegment _Pex, MemorySegment _Px) {
        var mh$ = _dunscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dunscale", _Pex, _Px);
            }
            return (short)mh$.invokeExact(_Pex, _Px);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldunscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ldunscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static FunctionDescriptor _ldunscale$descriptor() {
        return _ldunscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static MethodHandle _ldunscale$handle() {
        return _ldunscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static MemorySegment _ldunscale$address() {
        return _ldunscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static short _ldunscale(MemorySegment _Pex, MemorySegment _Px) {
        var mh$ = _ldunscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldunscale", _Pex, _Px);
            }
            return (short)mh$.invokeExact(_Pex, _Px);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdunscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fdunscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static FunctionDescriptor _fdunscale$descriptor() {
        return _fdunscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static MethodHandle _fdunscale$handle() {
        return _fdunscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static MemorySegment _fdunscale$address() {
        return _fdunscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static short _fdunscale(MemorySegment _Pex, MemorySegment _Px) {
        var mh$ = _fdunscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdunscale", _Pex, _Px);
            }
            return (short)mh$.invokeExact(_Pex, _Px);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_dexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static FunctionDescriptor _dexp$descriptor() {
        return _dexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static MethodHandle _dexp$handle() {
        return _dexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static MemorySegment _dexp$address() {
        return _dexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static short _dexp(MemorySegment _Px, double _Y, int _Eoff) {
        var mh$ = _dexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dexp", _Px, _Y, _Eoff);
            }
            return (short)mh$.invokeExact(_Px, _Y, _Eoff);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static FunctionDescriptor _ldexp$descriptor() {
        return _ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static MethodHandle _ldexp$handle() {
        return _ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static MemorySegment _ldexp$address() {
        return _ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static short _ldexp(MemorySegment _Px, double _Y, int _Eoff) {
        var mh$ = _ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldexp", _Px, _Y, _Eoff);
            }
            return (short)mh$.invokeExact(_Px, _Y, _Eoff);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fdexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static FunctionDescriptor _fdexp$descriptor() {
        return _fdexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static MethodHandle _fdexp$handle() {
        return _fdexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static MemorySegment _fdexp$address() {
        return _fdexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static short _fdexp(MemorySegment _Px, float _Y, int _Eoff) {
        var mh$ = _fdexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdexp", _Px, _Y, _Eoff);
            }
            return (short)mh$.invokeExact(_Px, _Y, _Eoff);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dnorm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_dnorm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static FunctionDescriptor _dnorm$descriptor() {
        return _dnorm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static MethodHandle _dnorm$handle() {
        return _dnorm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static MemorySegment _dnorm$address() {
        return _dnorm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static short _dnorm(MemorySegment _Ps) {
        var mh$ = _dnorm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dnorm", _Ps);
            }
            return (short)mh$.invokeExact(_Ps);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdnorm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fdnorm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static FunctionDescriptor _fdnorm$descriptor() {
        return _fdnorm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static MethodHandle _fdnorm$handle() {
        return _fdnorm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static MemorySegment _fdnorm$address() {
        return _fdnorm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static short _fdnorm(MemorySegment _Ps) {
        var mh$ = _fdnorm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdnorm", _Ps);
            }
            return (short)mh$.invokeExact(_Ps);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dpoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_dpoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static FunctionDescriptor _dpoly$descriptor() {
        return _dpoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static MethodHandle _dpoly$handle() {
        return _dpoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static MemorySegment _dpoly$address() {
        return _dpoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static double _dpoly(double _X, MemorySegment _Tab, int _N) {
        var mh$ = _dpoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dpoly", _X, _Tab, _N);
            }
            return (double)mh$.invokeExact(_X, _Tab, _N);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldpoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ldpoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static FunctionDescriptor _ldpoly$descriptor() {
        return _ldpoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static MethodHandle _ldpoly$handle() {
        return _ldpoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static MemorySegment _ldpoly$address() {
        return _ldpoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static double _ldpoly(double _X, MemorySegment _Tab, int _N) {
        var mh$ = _ldpoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldpoly", _X, _Tab, _N);
            }
            return (double)mh$.invokeExact(_X, _Tab, _N);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdpoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fdpoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static FunctionDescriptor _fdpoly$descriptor() {
        return _fdpoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static MethodHandle _fdpoly$handle() {
        return _fdpoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static MemorySegment _fdpoly$address() {
        return _fdpoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static float _fdpoly(float _X, MemorySegment _Tab, int _N) {
        var mh$ = _fdpoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdpoly", _X, _Tab, _N);
            }
            return (float)mh$.invokeExact(_X, _Tab, _N);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_dlog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static FunctionDescriptor _dlog$descriptor() {
        return _dlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static MethodHandle _dlog$handle() {
        return _dlog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static MemorySegment _dlog$address() {
        return _dlog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static double _dlog(double _X, int _Baseflag) {
        var mh$ = _dlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dlog", _X, _Baseflag);
            }
            return (double)mh$.invokeExact(_X, _Baseflag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ldlog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static FunctionDescriptor _ldlog$descriptor() {
        return _ldlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static MethodHandle _ldlog$handle() {
        return _ldlog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static MemorySegment _ldlog$address() {
        return _ldlog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static double _ldlog(double _X, int _Baseflag) {
        var mh$ = _ldlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldlog", _X, _Baseflag);
            }
            return (double)mh$.invokeExact(_X, _Baseflag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fdlog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static FunctionDescriptor _fdlog$descriptor() {
        return _fdlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static MethodHandle _fdlog$handle() {
        return _fdlog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static MemorySegment _fdlog$address() {
        return _fdlog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static float _fdlog(float _X, int _Baseflag) {
        var mh$ = _fdlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdlog", _X, _Baseflag);
            }
            return (float)mh$.invokeExact(_X, _Baseflag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dsin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_dsin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static FunctionDescriptor _dsin$descriptor() {
        return _dsin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static MethodHandle _dsin$handle() {
        return _dsin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static MemorySegment _dsin$address() {
        return _dsin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static double _dsin(double _X, int _Qoff) {
        var mh$ = _dsin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dsin", _X, _Qoff);
            }
            return (double)mh$.invokeExact(_X, _Qoff);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldsin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ldsin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static FunctionDescriptor _ldsin$descriptor() {
        return _ldsin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static MethodHandle _ldsin$handle() {
        return _ldsin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static MemorySegment _ldsin$address() {
        return _ldsin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static double _ldsin(double _X, int _Qoff) {
        var mh$ = _ldsin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldsin", _X, _Qoff);
            }
            return (double)mh$.invokeExact(_X, _Qoff);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdsin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fdsin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static FunctionDescriptor _fdsin$descriptor() {
        return _fdsin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static MethodHandle _fdsin$handle() {
        return _fdsin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static MemorySegment _fdsin$address() {
        return _fdsin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static float _fdsin(float _X, int _Qoff) {
        var mh$ = _fdsin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdsin", _X, _Qoff);
            }
            return (float)mh$.invokeExact(_X, _Qoff);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Denorm_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_Denorm_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Denorm_C
     * }
     */
    public static GroupLayout _Denorm_C$layout() {
        return _Denorm_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Denorm_C
     * }
     */
    public static MemorySegment _Denorm_C() {
        return _Denorm_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Denorm_C
     * }
     */
    public static void _Denorm_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Denorm_C$constants.SEGMENT, 0L, _Denorm_C$constants.LAYOUT.byteSize());
    }

    private static class _Inf_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_Inf_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Inf_C
     * }
     */
    public static GroupLayout _Inf_C$layout() {
        return _Inf_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Inf_C
     * }
     */
    public static MemorySegment _Inf_C() {
        return _Inf_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Inf_C
     * }
     */
    public static void _Inf_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Inf_C$constants.SEGMENT, 0L, _Inf_C$constants.LAYOUT.byteSize());
    }

    private static class _Nan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_Nan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Nan_C
     * }
     */
    public static GroupLayout _Nan_C$layout() {
        return _Nan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Nan_C
     * }
     */
    public static MemorySegment _Nan_C() {
        return _Nan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Nan_C
     * }
     */
    public static void _Nan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Nan_C$constants.SEGMENT, 0L, _Nan_C$constants.LAYOUT.byteSize());
    }

    private static class _Snan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_Snan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Snan_C
     * }
     */
    public static GroupLayout _Snan_C$layout() {
        return _Snan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Snan_C
     * }
     */
    public static MemorySegment _Snan_C() {
        return _Snan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Snan_C
     * }
     */
    public static void _Snan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Snan_C$constants.SEGMENT, 0L, _Snan_C$constants.LAYOUT.byteSize());
    }

    private static class _Hugeval_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_Hugeval_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Hugeval_C
     * }
     */
    public static GroupLayout _Hugeval_C$layout() {
        return _Hugeval_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Hugeval_C
     * }
     */
    public static MemorySegment _Hugeval_C() {
        return _Hugeval_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Hugeval_C
     * }
     */
    public static void _Hugeval_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Hugeval_C$constants.SEGMENT, 0L, _Hugeval_C$constants.LAYOUT.byteSize());
    }

    private static class _FDenorm_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_FDenorm_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FDenorm_C
     * }
     */
    public static GroupLayout _FDenorm_C$layout() {
        return _FDenorm_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FDenorm_C
     * }
     */
    public static MemorySegment _FDenorm_C() {
        return _FDenorm_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FDenorm_C
     * }
     */
    public static void _FDenorm_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FDenorm_C$constants.SEGMENT, 0L, _FDenorm_C$constants.LAYOUT.byteSize());
    }

    private static class _FInf_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_FInf_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FInf_C
     * }
     */
    public static GroupLayout _FInf_C$layout() {
        return _FInf_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FInf_C
     * }
     */
    public static MemorySegment _FInf_C() {
        return _FInf_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FInf_C
     * }
     */
    public static void _FInf_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FInf_C$constants.SEGMENT, 0L, _FInf_C$constants.LAYOUT.byteSize());
    }

    private static class _FNan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_FNan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FNan_C
     * }
     */
    public static GroupLayout _FNan_C$layout() {
        return _FNan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FNan_C
     * }
     */
    public static MemorySegment _FNan_C() {
        return _FNan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FNan_C
     * }
     */
    public static void _FNan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FNan_C$constants.SEGMENT, 0L, _FNan_C$constants.LAYOUT.byteSize());
    }

    private static class _FSnan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_FSnan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FSnan_C
     * }
     */
    public static GroupLayout _FSnan_C$layout() {
        return _FSnan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FSnan_C
     * }
     */
    public static MemorySegment _FSnan_C() {
        return _FSnan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FSnan_C
     * }
     */
    public static void _FSnan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FSnan_C$constants.SEGMENT, 0L, _FSnan_C$constants.LAYOUT.byteSize());
    }

    private static class _LDenorm_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_LDenorm_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LDenorm_C
     * }
     */
    public static GroupLayout _LDenorm_C$layout() {
        return _LDenorm_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LDenorm_C
     * }
     */
    public static MemorySegment _LDenorm_C() {
        return _LDenorm_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LDenorm_C
     * }
     */
    public static void _LDenorm_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LDenorm_C$constants.SEGMENT, 0L, _LDenorm_C$constants.LAYOUT.byteSize());
    }

    private static class _LInf_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_LInf_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LInf_C
     * }
     */
    public static GroupLayout _LInf_C$layout() {
        return _LInf_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LInf_C
     * }
     */
    public static MemorySegment _LInf_C() {
        return _LInf_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LInf_C
     * }
     */
    public static void _LInf_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LInf_C$constants.SEGMENT, 0L, _LInf_C$constants.LAYOUT.byteSize());
    }

    private static class _LNan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_LNan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LNan_C
     * }
     */
    public static GroupLayout _LNan_C$layout() {
        return _LNan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LNan_C
     * }
     */
    public static MemorySegment _LNan_C() {
        return _LNan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LNan_C
     * }
     */
    public static void _LNan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LNan_C$constants.SEGMENT, 0L, _LNan_C$constants.LAYOUT.byteSize());
    }

    private static class _LSnan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_LSnan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LSnan_C
     * }
     */
    public static GroupLayout _LSnan_C$layout() {
        return _LSnan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LSnan_C
     * }
     */
    public static MemorySegment _LSnan_C() {
        return _LSnan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LSnan_C
     * }
     */
    public static void _LSnan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LSnan_C$constants.SEGMENT, 0L, _LSnan_C$constants.LAYOUT.byteSize());
    }

    private static class _Eps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_Eps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Eps_C
     * }
     */
    public static GroupLayout _Eps_C$layout() {
        return _Eps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Eps_C
     * }
     */
    public static MemorySegment _Eps_C() {
        return _Eps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Eps_C
     * }
     */
    public static void _Eps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Eps_C$constants.SEGMENT, 0L, _Eps_C$constants.LAYOUT.byteSize());
    }

    private static class _Rteps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_Rteps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Rteps_C
     * }
     */
    public static GroupLayout _Rteps_C$layout() {
        return _Rteps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Rteps_C
     * }
     */
    public static MemorySegment _Rteps_C() {
        return _Rteps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Rteps_C
     * }
     */
    public static void _Rteps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Rteps_C$constants.SEGMENT, 0L, _Rteps_C$constants.LAYOUT.byteSize());
    }

    private static class _FEps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_FEps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FEps_C
     * }
     */
    public static GroupLayout _FEps_C$layout() {
        return _FEps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FEps_C
     * }
     */
    public static MemorySegment _FEps_C() {
        return _FEps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FEps_C
     * }
     */
    public static void _FEps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FEps_C$constants.SEGMENT, 0L, _FEps_C$constants.LAYOUT.byteSize());
    }

    private static class _FRteps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_FRteps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FRteps_C
     * }
     */
    public static GroupLayout _FRteps_C$layout() {
        return _FRteps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FRteps_C
     * }
     */
    public static MemorySegment _FRteps_C() {
        return _FRteps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FRteps_C
     * }
     */
    public static void _FRteps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FRteps_C$constants.SEGMENT, 0L, _FRteps_C$constants.LAYOUT.byteSize());
    }

    private static class _LEps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_LEps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LEps_C
     * }
     */
    public static GroupLayout _LEps_C$layout() {
        return _LEps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LEps_C
     * }
     */
    public static MemorySegment _LEps_C() {
        return _LEps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LEps_C
     * }
     */
    public static void _LEps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LEps_C$constants.SEGMENT, 0L, _LEps_C$constants.LAYOUT.byteSize());
    }

    private static class _LRteps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_LRteps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LRteps_C
     * }
     */
    public static GroupLayout _LRteps_C$layout() {
        return _LRteps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LRteps_C
     * }
     */
    public static MemorySegment _LRteps_C() {
        return _LRteps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LRteps_C
     * }
     */
    public static void _LRteps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LRteps_C$constants.SEGMENT, 0L, _LRteps_C$constants.LAYOUT.byteSize());
    }

    private static class _Zero_C$constants {
        public static final OfDouble LAYOUT = ffmpeg_includes_h.C_DOUBLE;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_Zero_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static OfDouble _Zero_C$layout() {
        return _Zero_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static MemorySegment _Zero_C$segment() {
        return _Zero_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static double _Zero_C() {
        return _Zero_C$constants.SEGMENT.get(_Zero_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static void _Zero_C(double varValue) {
        _Zero_C$constants.SEGMENT.set(_Zero_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _Xbig_C$constants {
        public static final OfDouble LAYOUT = ffmpeg_includes_h.C_DOUBLE;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_Xbig_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static OfDouble _Xbig_C$layout() {
        return _Xbig_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static MemorySegment _Xbig_C$segment() {
        return _Xbig_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static double _Xbig_C() {
        return _Xbig_C$constants.SEGMENT.get(_Xbig_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static void _Xbig_C(double varValue) {
        _Xbig_C$constants.SEGMENT.set(_Xbig_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _FZero_C$constants {
        public static final OfFloat LAYOUT = ffmpeg_includes_h.C_FLOAT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_FZero_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static OfFloat _FZero_C$layout() {
        return _FZero_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static MemorySegment _FZero_C$segment() {
        return _FZero_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static float _FZero_C() {
        return _FZero_C$constants.SEGMENT.get(_FZero_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static void _FZero_C(float varValue) {
        _FZero_C$constants.SEGMENT.set(_FZero_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _FXbig_C$constants {
        public static final OfFloat LAYOUT = ffmpeg_includes_h.C_FLOAT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_FXbig_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static OfFloat _FXbig_C$layout() {
        return _FXbig_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static MemorySegment _FXbig_C$segment() {
        return _FXbig_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static float _FXbig_C() {
        return _FXbig_C$constants.SEGMENT.get(_FXbig_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static void _FXbig_C(float varValue) {
        _FXbig_C$constants.SEGMENT.set(_FXbig_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _LZero_C$constants {
        public static final OfDouble LAYOUT = ffmpeg_includes_h.C_LONG_DOUBLE;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_LZero_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static OfDouble _LZero_C$layout() {
        return _LZero_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static MemorySegment _LZero_C$segment() {
        return _LZero_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static double _LZero_C() {
        return _LZero_C$constants.SEGMENT.get(_LZero_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static void _LZero_C(double varValue) {
        _LZero_C$constants.SEGMENT.set(_LZero_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _LXbig_C$constants {
        public static final OfDouble LAYOUT = ffmpeg_includes_h.C_LONG_DOUBLE;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("_LXbig_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static OfDouble _LXbig_C$layout() {
        return _LXbig_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static MemorySegment _LXbig_C$segment() {
        return _LXbig_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static double _LXbig_C() {
        return _LXbig_C$constants.SEGMENT.get(_LXbig_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static void _LXbig_C(double varValue) {
        _LXbig_C$constants.SEGMENT.set(_LXbig_C$constants.LAYOUT, 0L, varValue);
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int _X)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int _X)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int abs(int _X)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int abs(int _X)
     * }
     */
    public static int abs(int _X) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long _X)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long _X)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long labs(long _X)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long labs(long _X)
     * }
     */
    public static int labs(int _X) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long _X)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long _X)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llabs(long long _X)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llabs(long long _X)
     * }
     */
    public static long llabs(long _X) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("acos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static FunctionDescriptor acos$descriptor() {
        return acos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static MethodHandle acos$handle() {
        return acos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static MemorySegment acos$address() {
        return acos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static double acos(double _X) {
        var mh$ = acos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acos", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static FunctionDescriptor asin$descriptor() {
        return asin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static MethodHandle asin$handle() {
        return asin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static MemorySegment asin$address() {
        return asin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static double asin(double _X) {
        var mh$ = asin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asin", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static FunctionDescriptor atan$descriptor() {
        return atan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static MethodHandle atan$handle() {
        return atan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static MemorySegment atan$address() {
        return atan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static double atan(double _X) {
        var mh$ = atan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atan2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static FunctionDescriptor atan2$descriptor() {
        return atan2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static MethodHandle atan2$handle() {
        return atan2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static MemorySegment atan2$address() {
        return atan2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static double atan2(double _Y, double _X) {
        var mh$ = atan2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2", _Y, _X);
            }
            return (double)mh$.invokeExact(_Y, _X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static FunctionDescriptor cos$descriptor() {
        return cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static MethodHandle cos$handle() {
        return cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static MemorySegment cos$address() {
        return cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static double cos(double _X) {
        var mh$ = cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cos", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static FunctionDescriptor cosh$descriptor() {
        return cosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static MethodHandle cosh$handle() {
        return cosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static MemorySegment cosh$address() {
        return cosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static double cosh(double _X) {
        var mh$ = cosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static FunctionDescriptor exp$descriptor() {
        return exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static MethodHandle exp$handle() {
        return exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static MemorySegment exp$address() {
        return exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static double exp(double _X) {
        var mh$ = exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static FunctionDescriptor fabs$descriptor() {
        return fabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static MethodHandle fabs$handle() {
        return fabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static MemorySegment fabs$address() {
        return fabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static double fabs(double _X) {
        var mh$ = fabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabs", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fmod$descriptor() {
        return fmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static MethodHandle fmod$handle() {
        return fmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static MemorySegment fmod$address() {
        return fmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static double fmod(double _X, double _Y) {
        var mh$ = fmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmod", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static FunctionDescriptor log$descriptor() {
        return log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static MethodHandle log$handle() {
        return log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static MemorySegment log$address() {
        return log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static double log(double _X) {
        var mh$ = log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static FunctionDescriptor log10$descriptor() {
        return log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static MethodHandle log10$handle() {
        return log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static MemorySegment log10$address() {
        return log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static double log10(double _X) {
        var mh$ = log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor pow$descriptor() {
        return pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static MethodHandle pow$handle() {
        return pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static MemorySegment pow$address() {
        return pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static double pow(double _X, double _Y) {
        var mh$ = pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pow", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static FunctionDescriptor sin$descriptor() {
        return sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static MethodHandle sin$handle() {
        return sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static MemorySegment sin$address() {
        return sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static double sin(double _X) {
        var mh$ = sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sin", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static FunctionDescriptor sinh$descriptor() {
        return sinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static MethodHandle sinh$handle() {
        return sinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static MemorySegment sinh$address() {
        return sinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static double sinh(double _X) {
        var mh$ = sinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static FunctionDescriptor sqrt$descriptor() {
        return sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static MethodHandle sqrt$handle() {
        return sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static MemorySegment sqrt$address() {
        return sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static double sqrt(double _X) {
        var mh$ = sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrt", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static FunctionDescriptor tan$descriptor() {
        return tan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static MethodHandle tan$handle() {
        return tan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static MemorySegment tan$address() {
        return tan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static double tan(double _X) {
        var mh$ = tan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tan", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static FunctionDescriptor tanh$descriptor() {
        return tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static MethodHandle tanh$handle() {
        return tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static MemorySegment tanh$address() {
        return tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static double tanh(double _X) {
        var mh$ = tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("acosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static FunctionDescriptor acosh$descriptor() {
        return acosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static MethodHandle acosh$handle() {
        return acosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static MemorySegment acosh$address() {
        return acosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static double acosh(double _X) {
        var mh$ = acosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static FunctionDescriptor asinh$descriptor() {
        return asinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static MethodHandle asinh$handle() {
        return asinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static MemorySegment asinh$address() {
        return asinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static double asinh(double _X) {
        var mh$ = asinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static FunctionDescriptor atanh$descriptor() {
        return atanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static MethodHandle atanh$handle() {
        return atanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static MemorySegment atanh$address() {
        return atanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static double atanh(double _X) {
        var mh$ = atanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static double atof(MemorySegment _String) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", _String);
            }
            return (double)mh$.invokeExact(_String);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_atof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atof_l$descriptor() {
        return _atof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atof_l$handle() {
        return _atof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atof_l$address() {
        return _atof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static double _atof_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atof_l", _String, _Locale);
            }
            return (double)mh$.invokeExact(_String, _Locale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _cabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            _complex.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_cabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static FunctionDescriptor _cabs$descriptor() {
        return _cabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static MethodHandle _cabs$handle() {
        return _cabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static MemorySegment _cabs$address() {
        return _cabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static double _cabs(MemorySegment _Complex_value) {
        var mh$ = _cabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_cabs", _Complex_value);
            }
            return (double)mh$.invokeExact(_Complex_value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cbrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static FunctionDescriptor cbrt$descriptor() {
        return cbrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static MethodHandle cbrt$handle() {
        return cbrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static MemorySegment cbrt$address() {
        return cbrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static double cbrt(double _X) {
        var mh$ = cbrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrt", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static FunctionDescriptor ceil$descriptor() {
        return ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static MethodHandle ceil$handle() {
        return ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static MemorySegment ceil$address() {
        return ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static double ceil(double _X) {
        var mh$ = ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceil", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _chgsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_chgsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static FunctionDescriptor _chgsign$descriptor() {
        return _chgsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static MethodHandle _chgsign$handle() {
        return _chgsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static MemorySegment _chgsign$address() {
        return _chgsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static double _chgsign(double _X) {
        var mh$ = _chgsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_chgsign", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static FunctionDescriptor copysign$descriptor() {
        return copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static MethodHandle copysign$handle() {
        return copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static MemorySegment copysign$address() {
        return copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static double copysign(double _Number, double _Sign) {
        var mh$ = copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysign", _Number, _Sign);
            }
            return (double)mh$.invokeExact(_Number, _Sign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static FunctionDescriptor _copysign$descriptor() {
        return _copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static MethodHandle _copysign$handle() {
        return _copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static MemorySegment _copysign$address() {
        return _copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static double _copysign(double _Number, double _Sign) {
        var mh$ = _copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_copysign", _Number, _Sign);
            }
            return (double)mh$.invokeExact(_Number, _Sign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static FunctionDescriptor erf$descriptor() {
        return erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static MethodHandle erf$handle() {
        return erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static MemorySegment erf$address() {
        return erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static double erf(double _X) {
        var mh$ = erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erf", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erfc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static FunctionDescriptor erfc$descriptor() {
        return erfc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static MethodHandle erfc$handle() {
        return erfc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static MemorySegment erfc$address() {
        return erfc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static double erfc(double _X) {
        var mh$ = erfc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfc", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("exp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static FunctionDescriptor exp2$descriptor() {
        return exp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static MethodHandle exp2$handle() {
        return exp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static MemorySegment exp2$address() {
        return exp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static double exp2(double _X) {
        var mh$ = exp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static FunctionDescriptor expm1$descriptor() {
        return expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static MethodHandle expm1$handle() {
        return expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static MemorySegment expm1$address() {
        return expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static double expm1(double _X) {
        var mh$ = expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fdim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fdim$descriptor() {
        return fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static MethodHandle fdim$handle() {
        return fdim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static MemorySegment fdim$address() {
        return fdim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static double fdim(double _X, double _Y) {
        var mh$ = fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdim", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static FunctionDescriptor floor$descriptor() {
        return floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static MethodHandle floor$handle() {
        return floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static MemorySegment floor$address() {
        return floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static double floor(double _X) {
        var mh$ = floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floor", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static FunctionDescriptor fma$descriptor() {
        return fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static MethodHandle fma$handle() {
        return fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static MemorySegment fma$address() {
        return fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static double fma(double _X, double _Y, double _Z) {
        var mh$ = fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fma", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fmax$descriptor() {
        return fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static MethodHandle fmax$handle() {
        return fmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static MemorySegment fmax$address() {
        return fmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static double fmax(double _X, double _Y) {
        var mh$ = fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmax", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fmin$descriptor() {
        return fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static MethodHandle fmin$handle() {
        return fmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static MemorySegment fmin$address() {
        return fmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static double fmin(double _X, double _Y) {
        var mh$ = fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmin", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static FunctionDescriptor frexp$descriptor() {
        return frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static MethodHandle frexp$handle() {
        return frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static MemorySegment frexp$address() {
        return frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static double frexp(double _X, MemorySegment _Y) {
        var mh$ = frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexp", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor hypot$descriptor() {
        return hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static MethodHandle hypot$handle() {
        return hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static MemorySegment hypot$address() {
        return hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static double hypot(double _X, double _Y) {
        var mh$ = hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypot", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor _hypot$descriptor() {
        return _hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static MethodHandle _hypot$handle() {
        return _hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static MemorySegment _hypot$address() {
        return _hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static double _hypot(double _X, double _Y) {
        var mh$ = _hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_hypot", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ilogb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static FunctionDescriptor ilogb$descriptor() {
        return ilogb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static MethodHandle ilogb$handle() {
        return ilogb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static MemorySegment ilogb$address() {
        return ilogb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static int ilogb(double _X) {
        var mh$ = ilogb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogb", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static FunctionDescriptor ldexp$descriptor() {
        return ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static MethodHandle ldexp$handle() {
        return ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static MemorySegment ldexp$address() {
        return ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static double ldexp(double _X, int _Y) {
        var mh$ = ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexp", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static FunctionDescriptor lgamma$descriptor() {
        return lgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static MethodHandle lgamma$handle() {
        return lgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static MemorySegment lgamma$address() {
        return lgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static double lgamma(double _X) {
        var mh$ = lgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static FunctionDescriptor llrint$descriptor() {
        return llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static MethodHandle llrint$handle() {
        return llrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static MemorySegment llrint$address() {
        return llrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static long llrint(double _X) {
        var mh$ = llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrint", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static FunctionDescriptor llround$descriptor() {
        return llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static MethodHandle llround$handle() {
        return llround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static MemorySegment llround$address() {
        return llround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static long llround(double _X) {
        var mh$ = llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llround", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static FunctionDescriptor log1p$descriptor() {
        return log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static MethodHandle log1p$handle() {
        return log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static MemorySegment log1p$address() {
        return log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static double log1p(double _X) {
        var mh$ = log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1p", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static FunctionDescriptor log2$descriptor() {
        return log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static MethodHandle log2$handle() {
        return log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static MemorySegment log2$address() {
        return log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static double log2(double _X) {
        var mh$ = log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static FunctionDescriptor logb$descriptor() {
        return logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static MethodHandle logb$handle() {
        return logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static MemorySegment logb$address() {
        return logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static double logb(double _X) {
        var mh$ = logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logb", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static FunctionDescriptor lrint$descriptor() {
        return lrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static MethodHandle lrint$handle() {
        return lrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static MemorySegment lrint$address() {
        return lrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static int lrint(double _X) {
        var mh$ = lrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrint", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static FunctionDescriptor lround$descriptor() {
        return lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static MethodHandle lround$handle() {
        return lround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static MemorySegment lround$address() {
        return lround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static int lround(double _X) {
        var mh$ = lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lround", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _matherr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_matherr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static FunctionDescriptor _matherr$descriptor() {
        return _matherr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static MethodHandle _matherr$handle() {
        return _matherr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static MemorySegment _matherr$address() {
        return _matherr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static int _matherr(MemorySegment _Except) {
        var mh$ = _matherr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_matherr", _Except);
            }
            return (int)mh$.invokeExact(_Except);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("modf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static FunctionDescriptor modf$descriptor() {
        return modf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static MethodHandle modf$handle() {
        return modf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static MemorySegment modf$address() {
        return modf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static double modf(double _X, MemorySegment _Y) {
        var mh$ = modf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modf", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static FunctionDescriptor nan$descriptor() {
        return nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static MethodHandle nan$handle() {
        return nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static MemorySegment nan$address() {
        return nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static double nan(MemorySegment _X) {
        var mh$ = nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nan", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nearbyint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static FunctionDescriptor nearbyint$descriptor() {
        return nearbyint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static MethodHandle nearbyint$handle() {
        return nearbyint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static MemorySegment nearbyint$address() {
        return nearbyint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static double nearbyint(double _X) {
        var mh$ = nearbyint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyint", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor nextafter$descriptor() {
        return nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static MethodHandle nextafter$handle() {
        return nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static MemorySegment nextafter$address() {
        return nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static double nextafter(double _X, double _Y) {
        var mh$ = nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafter", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nexttoward {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nexttoward");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nexttoward$descriptor() {
        return nexttoward.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static MethodHandle nexttoward$handle() {
        return nexttoward.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static MemorySegment nexttoward$address() {
        return nexttoward.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static double nexttoward(double _X, double _Y) {
        var mh$ = nexttoward.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nexttoward", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor remainder$descriptor() {
        return remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static MethodHandle remainder$handle() {
        return remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static MemorySegment remainder$address() {
        return remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static double remainder(double _X, double _Y) {
        var mh$ = remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainder", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("remquo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static FunctionDescriptor remquo$descriptor() {
        return remquo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static MethodHandle remquo$handle() {
        return remquo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static MemorySegment remquo$address() {
        return remquo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static double remquo(double _X, double _Y, MemorySegment _Z) {
        var mh$ = remquo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquo", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static FunctionDescriptor rint$descriptor() {
        return rint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static MethodHandle rint$handle() {
        return rint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static MemorySegment rint$address() {
        return rint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static double rint(double _X) {
        var mh$ = rint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rint", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class round {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("round");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static FunctionDescriptor round$descriptor() {
        return round.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static MethodHandle round$handle() {
        return round.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static MemorySegment round$address() {
        return round.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static double round(double _X) {
        var mh$ = round.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("round", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("scalbln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static FunctionDescriptor scalbln$descriptor() {
        return scalbln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static MethodHandle scalbln$handle() {
        return scalbln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static MemorySegment scalbln$address() {
        return scalbln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static double scalbln(double _X, int _Y) {
        var mh$ = scalbln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbln", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("scalbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static FunctionDescriptor scalbn$descriptor() {
        return scalbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static MethodHandle scalbn$handle() {
        return scalbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static MemorySegment scalbn$address() {
        return scalbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static double scalbn(double _X, int _Y) {
        var mh$ = scalbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static FunctionDescriptor tgamma$descriptor() {
        return tgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static MethodHandle tgamma$handle() {
        return tgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static MemorySegment tgamma$address() {
        return tgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static double tgamma(double _X) {
        var mh$ = tgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgamma", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class trunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("trunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static FunctionDescriptor trunc$descriptor() {
        return trunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static MethodHandle trunc$handle() {
        return trunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static MemorySegment trunc$address() {
        return trunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static double trunc(double _X) {
        var mh$ = trunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("trunc", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static FunctionDescriptor _j0$descriptor() {
        return _j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static MethodHandle _j0$handle() {
        return _j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static MemorySegment _j0$address() {
        return _j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static double _j0(double _X) {
        var mh$ = _j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_j0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static FunctionDescriptor _j1$descriptor() {
        return _j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static MethodHandle _j1$handle() {
        return _j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static MemorySegment _j1$address() {
        return _j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static double _j1(double _X) {
        var mh$ = _j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_j1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor _jn$descriptor() {
        return _jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static MethodHandle _jn$handle() {
        return _jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static MemorySegment _jn$address() {
        return _jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static double _jn(int _X, double _Y) {
        var mh$ = _jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_jn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static FunctionDescriptor _y0$descriptor() {
        return _y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static MethodHandle _y0$handle() {
        return _y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static MemorySegment _y0$address() {
        return _y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static double _y0(double _X) {
        var mh$ = _y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_y0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static FunctionDescriptor _y1$descriptor() {
        return _y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static MethodHandle _y1$handle() {
        return _y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static MemorySegment _y1$address() {
        return _y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static double _y1(double _X) {
        var mh$ = _y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_y1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor _yn$descriptor() {
        return _yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static MethodHandle _yn$handle() {
        return _yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static MemorySegment _yn$address() {
        return _yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static double _yn(int _X, double _Y) {
        var mh$ = _yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_yn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("acoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static FunctionDescriptor acoshf$descriptor() {
        return acoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static MethodHandle acoshf$handle() {
        return acoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static MemorySegment acoshf$address() {
        return acoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static float acoshf(float _X) {
        var mh$ = acoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static FunctionDescriptor asinhf$descriptor() {
        return asinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static MethodHandle asinhf$handle() {
        return asinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static MemorySegment asinhf$address() {
        return asinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static float asinhf(float _X) {
        var mh$ = asinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static FunctionDescriptor atanhf$descriptor() {
        return atanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static MethodHandle atanhf$handle() {
        return atanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static MemorySegment atanhf$address() {
        return atanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static float atanhf(float _X) {
        var mh$ = atanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cbrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static FunctionDescriptor cbrtf$descriptor() {
        return cbrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static MethodHandle cbrtf$handle() {
        return cbrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static MemorySegment cbrtf$address() {
        return cbrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static float cbrtf(float _X) {
        var mh$ = cbrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _chgsignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_chgsignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static FunctionDescriptor _chgsignf$descriptor() {
        return _chgsignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static MethodHandle _chgsignf$handle() {
        return _chgsignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static MemorySegment _chgsignf$address() {
        return _chgsignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static float _chgsignf(float _X) {
        var mh$ = _chgsignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_chgsignf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static FunctionDescriptor copysignf$descriptor() {
        return copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static MethodHandle copysignf$handle() {
        return copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static MemorySegment copysignf$address() {
        return copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static float copysignf(float _Number, float _Sign) {
        var mh$ = copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignf", _Number, _Sign);
            }
            return (float)mh$.invokeExact(_Number, _Sign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static FunctionDescriptor _copysignf$descriptor() {
        return _copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static MethodHandle _copysignf$handle() {
        return _copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static MemorySegment _copysignf$address() {
        return _copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static float _copysignf(float _Number, float _Sign) {
        var mh$ = _copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_copysignf", _Number, _Sign);
            }
            return (float)mh$.invokeExact(_Number, _Sign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static FunctionDescriptor erff$descriptor() {
        return erff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static MethodHandle erff$handle() {
        return erff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static MemorySegment erff$address() {
        return erff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static float erff(float _X) {
        var mh$ = erff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erff", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erfcf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static FunctionDescriptor erfcf$descriptor() {
        return erfcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static MethodHandle erfcf$handle() {
        return erfcf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static MemorySegment erfcf$address() {
        return erfcf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static float erfcf(float _X) {
        var mh$ = erfcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("expm1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static FunctionDescriptor expm1f$descriptor() {
        return expm1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static MethodHandle expm1f$handle() {
        return expm1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static MemorySegment expm1f$address() {
        return expm1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static float expm1f(float _X) {
        var mh$ = expm1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("exp2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static FunctionDescriptor exp2f$descriptor() {
        return exp2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static MethodHandle exp2f$handle() {
        return exp2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static MemorySegment exp2f$address() {
        return exp2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static float exp2f(float _X) {
        var mh$ = exp2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdimf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fdimf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fdimf$descriptor() {
        return fdimf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static MethodHandle fdimf$handle() {
        return fdimf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static MemorySegment fdimf$address() {
        return fdimf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static float fdimf(float _X, float _Y) {
        var mh$ = fdimf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdimf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static FunctionDescriptor fmaf$descriptor() {
        return fmaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static MethodHandle fmaf$handle() {
        return fmaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static MemorySegment fmaf$address() {
        return fmaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static float fmaf(float _X, float _Y, float _Z) {
        var mh$ = fmaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaf", _X, _Y, _Z);
            }
            return (float)mh$.invokeExact(_X, _Y, _Z);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmaxf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fmaxf$descriptor() {
        return fmaxf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static MethodHandle fmaxf$handle() {
        return fmaxf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static MemorySegment fmaxf$address() {
        return fmaxf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static float fmaxf(float _X, float _Y) {
        var mh$ = fmaxf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fminf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fminf$descriptor() {
        return fminf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static MethodHandle fminf$handle() {
        return fminf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static MemorySegment fminf$address() {
        return fminf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static float fminf(float _X, float _Y) {
        var mh$ = fminf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _hypotf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_hypotf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor _hypotf$descriptor() {
        return _hypotf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static MethodHandle _hypotf$handle() {
        return _hypotf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static MemorySegment _hypotf$address() {
        return _hypotf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static float _hypotf(float _X, float _Y) {
        var mh$ = _hypotf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_hypotf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ilogbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static FunctionDescriptor ilogbf$descriptor() {
        return ilogbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static MethodHandle ilogbf$handle() {
        return ilogbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static MemorySegment ilogbf$address() {
        return ilogbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static int ilogbf(float _X) {
        var mh$ = ilogbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static FunctionDescriptor lgammaf$descriptor() {
        return lgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static MethodHandle lgammaf$handle() {
        return lgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static MemorySegment lgammaf$address() {
        return lgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static float lgammaf(float _X) {
        var mh$ = lgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static FunctionDescriptor llrintf$descriptor() {
        return llrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static MethodHandle llrintf$handle() {
        return llrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static MemorySegment llrintf$address() {
        return llrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static long llrintf(float _X) {
        var mh$ = llrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintf", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static FunctionDescriptor llroundf$descriptor() {
        return llroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static MethodHandle llroundf$handle() {
        return llroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static MemorySegment llroundf$address() {
        return llroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static long llroundf(float _X) {
        var mh$ = llroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundf", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log1pf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static FunctionDescriptor log1pf$descriptor() {
        return log1pf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static MethodHandle log1pf$handle() {
        return log1pf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static MemorySegment log1pf$address() {
        return log1pf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static float log1pf(float _X) {
        var mh$ = log1pf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static FunctionDescriptor log2f$descriptor() {
        return log2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static MethodHandle log2f$handle() {
        return log2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static MemorySegment log2f$address() {
        return log2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static float log2f(float _X) {
        var mh$ = log2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static FunctionDescriptor logbf$descriptor() {
        return logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static MethodHandle logbf$handle() {
        return logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static MemorySegment logbf$address() {
        return logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static float logbf(float _X) {
        var mh$ = logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static FunctionDescriptor lrintf$descriptor() {
        return lrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static MethodHandle lrintf$handle() {
        return lrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static MemorySegment lrintf$address() {
        return lrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static int lrintf(float _X) {
        var mh$ = lrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static FunctionDescriptor lroundf$descriptor() {
        return lroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static MethodHandle lroundf$handle() {
        return lroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static MemorySegment lroundf$address() {
        return lroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static int lroundf(float _X) {
        var mh$ = lroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static FunctionDescriptor nanf$descriptor() {
        return nanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static MethodHandle nanf$handle() {
        return nanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static MemorySegment nanf$address() {
        return nanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static float nanf(MemorySegment _X) {
        var mh$ = nanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nearbyintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static FunctionDescriptor nearbyintf$descriptor() {
        return nearbyintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static MethodHandle nearbyintf$handle() {
        return nearbyintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static MemorySegment nearbyintf$address() {
        return nearbyintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static float nearbyintf(float _X) {
        var mh$ = nearbyintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor nextafterf$descriptor() {
        return nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static MethodHandle nextafterf$handle() {
        return nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static MemorySegment nextafterf$address() {
        return nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static float nextafterf(float _X, float _Y) {
        var mh$ = nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nexttowardf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nexttowardf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nexttowardf$descriptor() {
        return nexttowardf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static MethodHandle nexttowardf$handle() {
        return nexttowardf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static MemorySegment nexttowardf$address() {
        return nexttowardf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static float nexttowardf(float _X, double _Y) {
        var mh$ = nexttowardf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nexttowardf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("remainderf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor remainderf$descriptor() {
        return remainderf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static MethodHandle remainderf$handle() {
        return remainderf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static MemorySegment remainderf$address() {
        return remainderf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static float remainderf(float _X, float _Y) {
        var mh$ = remainderf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("remquof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static FunctionDescriptor remquof$descriptor() {
        return remquof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static MethodHandle remquof$handle() {
        return remquof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static MemorySegment remquof$address() {
        return remquof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static float remquof(float _X, float _Y, MemorySegment _Z) {
        var mh$ = remquof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquof", _X, _Y, _Z);
            }
            return (float)mh$.invokeExact(_X, _Y, _Z);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static FunctionDescriptor rintf$descriptor() {
        return rintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static MethodHandle rintf$handle() {
        return rintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static MemorySegment rintf$address() {
        return rintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static float rintf(float _X) {
        var mh$ = rintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("roundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static FunctionDescriptor roundf$descriptor() {
        return roundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static MethodHandle roundf$handle() {
        return roundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static MemorySegment roundf$address() {
        return roundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static float roundf(float _X) {
        var mh$ = roundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("scalblnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static FunctionDescriptor scalblnf$descriptor() {
        return scalblnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static MethodHandle scalblnf$handle() {
        return scalblnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static MemorySegment scalblnf$address() {
        return scalblnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static float scalblnf(float _X, int _Y) {
        var mh$ = scalblnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("scalbnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static FunctionDescriptor scalbnf$descriptor() {
        return scalbnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static MethodHandle scalbnf$handle() {
        return scalbnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static MemorySegment scalbnf$address() {
        return scalbnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static float scalbnf(float _X, int _Y) {
        var mh$ = scalbnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static FunctionDescriptor tgammaf$descriptor() {
        return tgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static MethodHandle tgammaf$handle() {
        return tgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static MemorySegment tgammaf$address() {
        return tgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static float tgammaf(float _X) {
        var mh$ = tgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammaf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("truncf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static FunctionDescriptor truncf$descriptor() {
        return truncf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static MethodHandle truncf$handle() {
        return truncf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static MemorySegment truncf$address() {
        return truncf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static float truncf(float _X) {
        var mh$ = truncf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static FunctionDescriptor _logbf$descriptor() {
        return _logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static MethodHandle _logbf$handle() {
        return _logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static MemorySegment _logbf$address() {
        return _logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static float _logbf(float _X) {
        var mh$ = _logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_logbf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor _nextafterf$descriptor() {
        return _nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static MethodHandle _nextafterf$handle() {
        return _nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static MemorySegment _nextafterf$address() {
        return _nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static float _nextafterf(float _X, float _Y) {
        var mh$ = _nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_nextafterf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _finitef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_finitef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static FunctionDescriptor _finitef$descriptor() {
        return _finitef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static MethodHandle _finitef$handle() {
        return _finitef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static MemorySegment _finitef$address() {
        return _finitef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static int _finitef(float _X) {
        var mh$ = _finitef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_finitef", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isnanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_isnanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static FunctionDescriptor _isnanf$descriptor() {
        return _isnanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static MethodHandle _isnanf$handle() {
        return _isnanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static MemorySegment _isnanf$address() {
        return _isnanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static int _isnanf(float _X) {
        var mh$ = _isnanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isnanf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fpclassf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fpclassf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static FunctionDescriptor _fpclassf$descriptor() {
        return _fpclassf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static MethodHandle _fpclassf$handle() {
        return _fpclassf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static MemorySegment _fpclassf$address() {
        return _fpclassf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static int _fpclassf(float _X) {
        var mh$ = _fpclassf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fpclassf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_FMA3_enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_set_FMA3_enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static FunctionDescriptor _set_FMA3_enable$descriptor() {
        return _set_FMA3_enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static MethodHandle _set_FMA3_enable$handle() {
        return _set_FMA3_enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static MemorySegment _set_FMA3_enable$address() {
        return _set_FMA3_enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static int _set_FMA3_enable(int _Flag) {
        var mh$ = _set_FMA3_enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_FMA3_enable", _Flag);
            }
            return (int)mh$.invokeExact(_Flag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_FMA3_enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_FMA3_enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static FunctionDescriptor _get_FMA3_enable$descriptor() {
        return _get_FMA3_enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static MethodHandle _get_FMA3_enable$handle() {
        return _get_FMA3_enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static MemorySegment _get_FMA3_enable$address() {
        return _get_FMA3_enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static int _get_FMA3_enable() {
        var mh$ = _get_FMA3_enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_FMA3_enable");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("acosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static FunctionDescriptor acosf$descriptor() {
        return acosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static MethodHandle acosf$handle() {
        return acosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static MemorySegment acosf$address() {
        return acosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static float acosf(float _X) {
        var mh$ = acosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static FunctionDescriptor asinf$descriptor() {
        return asinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static MethodHandle asinf$handle() {
        return asinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static MemorySegment asinf$address() {
        return asinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static float asinf(float _X) {
        var mh$ = asinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atan2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static FunctionDescriptor atan2f$descriptor() {
        return atan2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static MethodHandle atan2f$handle() {
        return atan2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static MemorySegment atan2f$address() {
        return atan2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static float atan2f(float _Y, float _X) {
        var mh$ = atan2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2f", _Y, _X);
            }
            return (float)mh$.invokeExact(_Y, _X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static FunctionDescriptor atanf$descriptor() {
        return atanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static MethodHandle atanf$handle() {
        return atanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static MemorySegment atanf$address() {
        return atanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static float atanf(float _X) {
        var mh$ = atanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceilf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ceilf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static FunctionDescriptor ceilf$descriptor() {
        return ceilf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static MethodHandle ceilf$handle() {
        return ceilf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static MemorySegment ceilf$address() {
        return ceilf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static float ceilf(float _X) {
        var mh$ = ceilf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceilf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static FunctionDescriptor cosf$descriptor() {
        return cosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static MethodHandle cosf$handle() {
        return cosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static MemorySegment cosf$address() {
        return cosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static float cosf(float _X) {
        var mh$ = cosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class coshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("coshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static FunctionDescriptor coshf$descriptor() {
        return coshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static MethodHandle coshf$handle() {
        return coshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static MemorySegment coshf$address() {
        return coshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static float coshf(float _X) {
        var mh$ = coshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("coshf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("expf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static FunctionDescriptor expf$descriptor() {
        return expf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static MethodHandle expf$handle() {
        return expf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static MemorySegment expf$address() {
        return expf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static float expf(float _X) {
        var mh$ = expf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floorf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("floorf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static FunctionDescriptor floorf$descriptor() {
        return floorf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static MethodHandle floorf$handle() {
        return floorf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static MemorySegment floorf$address() {
        return floorf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static float floorf(float _X) {
        var mh$ = floorf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floorf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmodf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmodf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fmodf$descriptor() {
        return fmodf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static MethodHandle fmodf$handle() {
        return fmodf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static MemorySegment fmodf$address() {
        return fmodf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static float fmodf(float _X, float _Y) {
        var mh$ = fmodf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmodf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static FunctionDescriptor log10f$descriptor() {
        return log10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static MethodHandle log10f$handle() {
        return log10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static MemorySegment log10f$address() {
        return log10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static float log10f(float _X) {
        var mh$ = log10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("logf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static FunctionDescriptor logf$descriptor() {
        return logf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static MethodHandle logf$handle() {
        return logf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static MemorySegment logf$address() {
        return logf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static float logf(float _X) {
        var mh$ = logf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("modff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static FunctionDescriptor modff$descriptor() {
        return modff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static MethodHandle modff$handle() {
        return modff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static MemorySegment modff$address() {
        return modff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static float modff(float _X, MemorySegment _Y) {
        var mh$ = modff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modff", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class powf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("powf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor powf$descriptor() {
        return powf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static MethodHandle powf$handle() {
        return powf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static MemorySegment powf$address() {
        return powf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static float powf(float _X, float _Y) {
        var mh$ = powf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("powf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static FunctionDescriptor sinf$descriptor() {
        return sinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static MethodHandle sinf$handle() {
        return sinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static MemorySegment sinf$address() {
        return sinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static float sinf(float _X) {
        var mh$ = sinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static FunctionDescriptor sinhf$descriptor() {
        return sinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static MethodHandle sinhf$handle() {
        return sinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static MemorySegment sinhf$address() {
        return sinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static float sinhf(float _X) {
        var mh$ = sinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static FunctionDescriptor sqrtf$descriptor() {
        return sqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static MethodHandle sqrtf$handle() {
        return sqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static MemorySegment sqrtf$address() {
        return sqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static float sqrtf(float _X) {
        var mh$ = sqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrtf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static FunctionDescriptor tanf$descriptor() {
        return tanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static MethodHandle tanf$handle() {
        return tanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static MemorySegment tanf$address() {
        return tanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static float tanf(float _X) {
        var mh$ = tanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_FLOAT,
            ffmpeg_includes_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static FunctionDescriptor tanhf$descriptor() {
        return tanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static MethodHandle tanhf$handle() {
        return tanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static MemorySegment tanhf$address() {
        return tanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static float tanhf(float _X) {
        var mh$ = tanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("acoshl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static FunctionDescriptor acoshl$descriptor() {
        return acoshl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static MethodHandle acoshl$handle() {
        return acoshl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static MemorySegment acoshl$address() {
        return acoshl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static double acoshl(double _X) {
        var mh$ = acoshl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asinhl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static FunctionDescriptor asinhl$descriptor() {
        return asinhl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static MethodHandle asinhl$handle() {
        return asinhl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static MemorySegment asinhl$address() {
        return asinhl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static double asinhl(double _X) {
        var mh$ = asinhl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atanhl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static FunctionDescriptor atanhl$descriptor() {
        return atanhl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static MethodHandle atanhl$handle() {
        return atanhl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static MemorySegment atanhl$address() {
        return atanhl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static double atanhl(double _X) {
        var mh$ = atanhl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cbrtl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static FunctionDescriptor cbrtl$descriptor() {
        return cbrtl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static MethodHandle cbrtl$handle() {
        return cbrtl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static MemorySegment cbrtl$address() {
        return cbrtl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static double cbrtl(double _X) {
        var mh$ = cbrtl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("copysignl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static FunctionDescriptor copysignl$descriptor() {
        return copysignl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static MethodHandle copysignl$handle() {
        return copysignl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static MemorySegment copysignl$address() {
        return copysignl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static double copysignl(double _Number, double _Sign) {
        var mh$ = copysignl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignl", _Number, _Sign);
            }
            return (double)mh$.invokeExact(_Number, _Sign);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erfl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static FunctionDescriptor erfl$descriptor() {
        return erfl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static MethodHandle erfl$handle() {
        return erfl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static MemorySegment erfl$address() {
        return erfl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static double erfl(double _X) {
        var mh$ = erfl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erfcl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static FunctionDescriptor erfcl$descriptor() {
        return erfcl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static MethodHandle erfcl$handle() {
        return erfcl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static MemorySegment erfcl$address() {
        return erfcl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static double erfcl(double _X) {
        var mh$ = erfcl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("exp2l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static FunctionDescriptor exp2l$descriptor() {
        return exp2l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static MethodHandle exp2l$handle() {
        return exp2l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static MemorySegment exp2l$address() {
        return exp2l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static double exp2l(double _X) {
        var mh$ = exp2l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2l", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("expm1l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static FunctionDescriptor expm1l$descriptor() {
        return expm1l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static MethodHandle expm1l$handle() {
        return expm1l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static MemorySegment expm1l$address() {
        return expm1l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static double expm1l(double _X) {
        var mh$ = expm1l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1l", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdiml {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fdiml");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor fdiml$descriptor() {
        return fdiml.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static MethodHandle fdiml$handle() {
        return fdiml.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static MemorySegment fdiml$address() {
        return fdiml.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static double fdiml(double _X, double _Y) {
        var mh$ = fdiml.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdiml", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static FunctionDescriptor fmal$descriptor() {
        return fmal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static MethodHandle fmal$handle() {
        return fmal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static MemorySegment fmal$address() {
        return fmal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static double fmal(double _X, double _Y, double _Z) {
        var mh$ = fmal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmal", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmaxl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor fmaxl$descriptor() {
        return fmaxl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle fmaxl$handle() {
        return fmaxl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment fmaxl$address() {
        return fmaxl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static double fmaxl(double _X, double _Y) {
        var mh$ = fmaxl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fminl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor fminl$descriptor() {
        return fminl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle fminl$handle() {
        return fminl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment fminl$address() {
        return fminl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static double fminl(double _X, double _Y) {
        var mh$ = fminl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ilogbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static FunctionDescriptor ilogbl$descriptor() {
        return ilogbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static MethodHandle ilogbl$handle() {
        return ilogbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static MemorySegment ilogbl$address() {
        return ilogbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static int ilogbl(double _X) {
        var mh$ = ilogbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbl", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lgammal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static FunctionDescriptor lgammal$descriptor() {
        return lgammal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static MethodHandle lgammal$handle() {
        return lgammal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static MemorySegment lgammal$address() {
        return lgammal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static double lgammal(double _X) {
        var mh$ = lgammal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammal", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llrintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static FunctionDescriptor llrintl$descriptor() {
        return llrintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static MethodHandle llrintl$handle() {
        return llrintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static MemorySegment llrintl$address() {
        return llrintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static long llrintl(double _X) {
        var mh$ = llrintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintl", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llroundl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static FunctionDescriptor llroundl$descriptor() {
        return llroundl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static MethodHandle llroundl$handle() {
        return llroundl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static MemorySegment llroundl$address() {
        return llroundl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static long llroundl(double _X) {
        var mh$ = llroundl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundl", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log1pl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static FunctionDescriptor log1pl$descriptor() {
        return log1pl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static MethodHandle log1pl$handle() {
        return log1pl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static MemorySegment log1pl$address() {
        return log1pl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static double log1pl(double _X) {
        var mh$ = log1pl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log2l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static FunctionDescriptor log2l$descriptor() {
        return log2l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static MethodHandle log2l$handle() {
        return log2l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static MemorySegment log2l$address() {
        return log2l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static double log2l(double _X) {
        var mh$ = log2l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2l", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("logbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static FunctionDescriptor logbl$descriptor() {
        return logbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static MethodHandle logbl$handle() {
        return logbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static MemorySegment logbl$address() {
        return logbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static double logbl(double _X) {
        var mh$ = logbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lrintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static FunctionDescriptor lrintl$descriptor() {
        return lrintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static MethodHandle lrintl$handle() {
        return lrintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static MemorySegment lrintl$address() {
        return lrintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static int lrintl(double _X) {
        var mh$ = lrintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintl", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lroundl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static FunctionDescriptor lroundl$descriptor() {
        return lroundl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static MethodHandle lroundl$handle() {
        return lroundl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static MemorySegment lroundl$address() {
        return lroundl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static int lroundl(double _X) {
        var mh$ = lroundl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundl", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nanl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static FunctionDescriptor nanl$descriptor() {
        return nanl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static MethodHandle nanl$handle() {
        return nanl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static MemorySegment nanl$address() {
        return nanl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static double nanl(MemorySegment _X) {
        var mh$ = nanl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nearbyintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static FunctionDescriptor nearbyintl$descriptor() {
        return nearbyintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static MethodHandle nearbyintl$handle() {
        return nearbyintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static MemorySegment nearbyintl$address() {
        return nearbyintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static double nearbyintl(double _X) {
        var mh$ = nearbyintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nextafterl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nextafterl$descriptor() {
        return nextafterl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle nextafterl$handle() {
        return nextafterl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment nextafterl$address() {
        return nextafterl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static double nextafterl(double _X, double _Y) {
        var mh$ = nextafterl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nexttowardl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nexttowardl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nexttowardl$descriptor() {
        return nexttowardl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle nexttowardl$handle() {
        return nexttowardl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment nexttowardl$address() {
        return nexttowardl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static double nexttowardl(double _X, double _Y) {
        var mh$ = nexttowardl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nexttowardl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("remainderl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor remainderl$descriptor() {
        return remainderl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle remainderl$handle() {
        return remainderl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment remainderl$address() {
        return remainderl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static double remainderl(double _X, double _Y) {
        var mh$ = remainderl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("remquol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static FunctionDescriptor remquol$descriptor() {
        return remquol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static MethodHandle remquol$handle() {
        return remquol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static MemorySegment remquol$address() {
        return remquol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static double remquol(double _X, double _Y, MemorySegment _Z) {
        var mh$ = remquol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquol", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static FunctionDescriptor rintl$descriptor() {
        return rintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static MethodHandle rintl$handle() {
        return rintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static MemorySegment rintl$address() {
        return rintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static double rintl(double _X) {
        var mh$ = rintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("roundl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static FunctionDescriptor roundl$descriptor() {
        return roundl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static MethodHandle roundl$handle() {
        return roundl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static MemorySegment roundl$address() {
        return roundl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static double roundl(double _X) {
        var mh$ = roundl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("scalblnl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static FunctionDescriptor scalblnl$descriptor() {
        return scalblnl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static MethodHandle scalblnl$handle() {
        return scalblnl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static MemorySegment scalblnl$address() {
        return scalblnl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static double scalblnl(double _X, int _Y) {
        var mh$ = scalblnl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("scalbnl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static FunctionDescriptor scalbnl$descriptor() {
        return scalbnl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static MethodHandle scalbnl$handle() {
        return scalbnl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static MemorySegment scalbnl$address() {
        return scalbnl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static double scalbnl(double _X, int _Y) {
        var mh$ = scalbnl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tgammal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static FunctionDescriptor tgammal$descriptor() {
        return tgammal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static MethodHandle tgammal$handle() {
        return tgammal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static MemorySegment tgammal$address() {
        return tgammal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static double tgammal(double _X) {
        var mh$ = tgammal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammal", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_DOUBLE,
            ffmpeg_includes_h.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("truncl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static FunctionDescriptor truncl$descriptor() {
        return truncl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static MethodHandle truncl$handle() {
        return truncl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static MemorySegment truncl$address() {
        return truncl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static double truncl(double _X) {
        var mh$ = truncl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HUGE$constants {
        public static final OfDouble LAYOUT = ffmpeg_includes_h.C_DOUBLE;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("HUGE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static OfDouble HUGE$layout() {
        return HUGE$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static MemorySegment HUGE$segment() {
        return HUGE$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static double HUGE() {
        return HUGE$constants.SEGMENT.get(HUGE$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static void HUGE(double varValue) {
        HUGE$constants.SEGMENT.set(HUGE$constants.LAYOUT, 0L, varValue);
    }

    private static class j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static FunctionDescriptor j0$descriptor() {
        return j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static MethodHandle j0$handle() {
        return j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static MemorySegment j0$address() {
        return j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static double j0(double _X) {
        var mh$ = j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static FunctionDescriptor j1$descriptor() {
        return j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static MethodHandle j1$handle() {
        return j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static MemorySegment j1$address() {
        return j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static double j1(double _X) {
        var mh$ = j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor jn$descriptor() {
        return jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static MethodHandle jn$handle() {
        return jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static MemorySegment jn$address() {
        return jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static double jn(int _X, double _Y) {
        var mh$ = jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static FunctionDescriptor y0$descriptor() {
        return y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static MethodHandle y0$handle() {
        return y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static MemorySegment y0$address() {
        return y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static double y0(double _X) {
        var mh$ = y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static FunctionDescriptor y1$descriptor() {
        return y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static MethodHandle y1$handle() {
        return y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static MemorySegment y1$address() {
        return y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static double y1(double _X) {
        var mh$ = y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_DOUBLE,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor yn$descriptor() {
        return yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static MethodHandle yn$handle() {
        return yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static MemorySegment yn$address() {
        return yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static double yn(int _X, double _Y) {
        var mh$ = yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("yn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __acrt_iob_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__acrt_iob_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static FunctionDescriptor __acrt_iob_func$descriptor() {
        return __acrt_iob_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static MethodHandle __acrt_iob_func$handle() {
        return __acrt_iob_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static MemorySegment __acrt_iob_func$address() {
        return __acrt_iob_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static MemorySegment __acrt_iob_func(int _Ix) {
        var mh$ = __acrt_iob_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__acrt_iob_func", _Ix);
            }
            return (MemorySegment)mh$.invokeExact(_Ix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgetwc$descriptor() {
        return fgetwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static MethodHandle fgetwc$handle() {
        return fgetwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static MemorySegment fgetwc$address() {
        return fgetwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static short fgetwc(MemorySegment _Stream) {
        var mh$ = fgetwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetwc", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fgetwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fgetwchar()
     * }
     */
    public static FunctionDescriptor _fgetwchar$descriptor() {
        return _fgetwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fgetwchar()
     * }
     */
    public static MethodHandle _fgetwchar$handle() {
        return _fgetwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _fgetwchar()
     * }
     */
    public static MemorySegment _fgetwchar$address() {
        return _fgetwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _fgetwchar()
     * }
     */
    public static short _fgetwchar() {
        var mh$ = _fgetwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetwchar");
            }
            return (short)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fputwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputwc$descriptor() {
        return fputwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle fputwc$handle() {
        return fputwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment fputwc$address() {
        return fputwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short fputwc(short _Character, MemorySegment _Stream) {
        var mh$ = fputwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputwc", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fputwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static FunctionDescriptor _fputwchar$descriptor() {
        return _fputwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static MethodHandle _fputwchar$handle() {
        return _fputwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static MemorySegment _fputwchar$address() {
        return _fputwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static short _fputwchar(short _Character) {
        var mh$ = _fputwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputwchar", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor getwc$descriptor() {
        return getwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *_Stream)
     * }
     */
    public static MethodHandle getwc$handle() {
        return getwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *_Stream)
     * }
     */
    public static MemorySegment getwc$address() {
        return getwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t getwc(FILE *_Stream)
     * }
     */
    public static short getwc(MemorySegment _Stream) {
        var mh$ = getwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwc", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static FunctionDescriptor getwchar$descriptor() {
        return getwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static MethodHandle getwchar$handle() {
        return getwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static MemorySegment getwchar$address() {
        return getwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static short getwchar() {
        var mh$ = getwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwchar");
            }
            return (short)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgetws$descriptor() {
        return fgetws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fgetws$handle() {
        return fgetws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgetws$address() {
        return fgetws.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgetws(MemorySegment _Buffer, int _BufferCount, MemorySegment _Stream) {
        var mh$ = fgetws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetws", _Buffer, _BufferCount, _Stream);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _BufferCount, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fputws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputws$descriptor() {
        return fputws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static MethodHandle fputws$handle() {
        return fputws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static MemorySegment fputws$address() {
        return fputws.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static int fputws(MemorySegment _Buffer, MemorySegment _Stream) {
        var mh$ = fputws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputws", _Buffer, _Stream);
            }
            return (int)mh$.invokeExact(_Buffer, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getws_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_getws_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _getws_s$descriptor() {
        return _getws_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _getws_s$handle() {
        return _getws_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _getws_s$address() {
        return _getws_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _getws_s(MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _getws_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getws_s", _Buffer, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _BufferCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor putwc$descriptor() {
        return putwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle putwc$handle() {
        return putwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment putwc$address() {
        return putwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short putwc(short _Character, MemorySegment _Stream) {
        var mh$ = putwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putwc", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static FunctionDescriptor putwchar$descriptor() {
        return putwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static MethodHandle putwchar$handle() {
        return putwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static MemorySegment putwchar$address() {
        return putwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static short putwchar(short _Character) {
        var mh$ = putwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putwchar", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_putws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _putws$descriptor() {
        return _putws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _putws$handle() {
        return _putws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _putws$address() {
        return _putws.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static int _putws(MemorySegment _Buffer) {
        var mh$ = _putws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putws", _Buffer);
            }
            return (int)mh$.invokeExact(_Buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ungetwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ungetwc$descriptor() {
        return ungetwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle ungetwc$handle() {
        return ungetwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment ungetwc$address() {
        return ungetwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static short ungetwc(short _Character, MemorySegment _Stream) {
        var mh$ = ungetwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetwc", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wfdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wfdopen$descriptor() {
        return _wfdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wfdopen$handle() {
        return _wfdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfdopen$address() {
        return _wfdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfdopen(int _FileHandle, MemorySegment _Mode) {
        var mh$ = _wfdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfdopen", _FileHandle, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileHandle, _Mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wfopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wfopen$descriptor() {
        return _wfopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wfopen$handle() {
        return _wfopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfopen$address() {
        return _wfopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfopen(MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = _wfopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfopen", _FileName, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wfopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wfopen_s$descriptor() {
        return _wfopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wfopen_s$handle() {
        return _wfopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfopen_s$address() {
        return _wfopen_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static int _wfopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = _wfopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfopen_s", _Stream, _FileName, _Mode);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfreopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wfreopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static FunctionDescriptor _wfreopen$descriptor() {
        return _wfreopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MethodHandle _wfreopen$handle() {
        return _wfreopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment _wfreopen$address() {
        return _wfreopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment _wfreopen(MemorySegment _FileName, MemorySegment _Mode, MemorySegment _OldStream) {
        var mh$ = _wfreopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfreopen", _FileName, _Mode, _OldStream);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _OldStream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfreopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wfreopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static FunctionDescriptor _wfreopen_s$descriptor() {
        return _wfreopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MethodHandle _wfreopen_s$handle() {
        return _wfreopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment _wfreopen_s$address() {
        return _wfreopen_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static int _wfreopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode, MemorySegment _OldStream) {
        var mh$ = _wfreopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfreopen_s", _Stream, _FileName, _Mode, _OldStream);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode, _OldStream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfsopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wfsopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static FunctionDescriptor _wfsopen$descriptor() {
        return _wfsopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static MethodHandle _wfsopen$handle() {
        return _wfsopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _wfsopen$address() {
        return _wfsopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _wfsopen(MemorySegment _FileName, MemorySegment _Mode, int _ShFlag) {
        var mh$ = _wfsopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfsopen", _FileName, _Mode, _ShFlag);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _ShFlag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wperror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wperror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _wperror$descriptor() {
        return _wperror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MethodHandle _wperror$handle() {
        return _wperror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MemorySegment _wperror$address() {
        return _wperror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static void _wperror(MemorySegment _ErrorMessage) {
        var mh$ = _wperror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wperror", _ErrorMessage);
            }
            mh$.invokeExact(_ErrorMessage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wpopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wpopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wpopen$descriptor() {
        return _wpopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wpopen$handle() {
        return _wpopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wpopen$address() {
        return _wpopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wpopen(MemorySegment _Command, MemorySegment _Mode) {
        var mh$ = _wpopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wpopen", _Command, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_Command, _Mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wremove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wremove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static FunctionDescriptor _wremove$descriptor() {
        return _wremove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static MethodHandle _wremove$handle() {
        return _wremove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static MemorySegment _wremove$address() {
        return _wremove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static int _wremove(MemorySegment _FileName) {
        var mh$ = _wremove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wremove", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static FunctionDescriptor _wtempnam$descriptor() {
        return _wtempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static MethodHandle _wtempnam$handle() {
        return _wtempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static MemorySegment _wtempnam$address() {
        return _wtempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static MemorySegment _wtempnam(MemorySegment _Directory, MemorySegment _FilePrefix) {
        var mh$ = _wtempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtempnam", _Directory, _FilePrefix);
            }
            return (MemorySegment)mh$.invokeExact(_Directory, _FilePrefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtmpnam_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtmpnam_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wtmpnam_s$descriptor() {
        return _wtmpnam_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wtmpnam_s$handle() {
        return _wtmpnam_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wtmpnam_s$address() {
        return _wtmpnam_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _wtmpnam_s(MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _wtmpnam_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtmpnam_s", _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_wtmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _wtmpnam$descriptor() {
        return _wtmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _wtmpnam$handle() {
        return _wtmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wtmpnam$address() {
        return _wtmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wtmpnam(MemorySegment _Buffer) {
        var mh$ = _wtmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtmpnam", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fgetwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fgetwc_nolock$descriptor() {
        return _fgetwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fgetwc_nolock$handle() {
        return _fgetwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fgetwc_nolock$address() {
        return _fgetwc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static short _fgetwc_nolock(MemorySegment _Stream) {
        var mh$ = _fgetwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetwc_nolock", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fputwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fputwc_nolock$descriptor() {
        return _fputwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _fputwc_nolock$handle() {
        return _fputwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _fputwc_nolock$address() {
        return _fputwc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short _fputwc_nolock(short _Character, MemorySegment _Stream) {
        var mh$ = _fputwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputwc_nolock", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_getwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _getwc_nolock$descriptor() {
        return _getwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _getwc_nolock$handle() {
        return _getwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _getwc_nolock$address() {
        return _getwc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static short _getwc_nolock(MemorySegment _Stream) {
        var mh$ = _getwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getwc_nolock", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_putwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _putwc_nolock$descriptor() {
        return _putwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _putwc_nolock$handle() {
        return _putwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _putwc_nolock$address() {
        return _putwc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short _putwc_nolock(short _Character, MemorySegment _Stream) {
        var mh$ = _putwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putwc_nolock", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ungetwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_SHORT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ungetwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ungetwc_nolock$descriptor() {
        return _ungetwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _ungetwc_nolock$handle() {
        return _ungetwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _ungetwc_nolock$address() {
        return _ungetwc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static short _ungetwc_nolock(short _Character, MemorySegment _Stream) {
        var mh$ = _ungetwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ungetwc_nolock", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfwprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwprintf$descriptor() {
        return __stdio_common_vfwprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwprintf$handle() {
        return __stdio_common_vfwprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwprintf$address() {
        return __stdio_common_vfwprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwprintf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwprintf", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfwprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwprintf_s$descriptor() {
        return __stdio_common_vfwprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwprintf_s$handle() {
        return __stdio_common_vfwprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwprintf_s$address() {
        return __stdio_common_vfwprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwprintf_s(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwprintf_s", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfwprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwprintf_p$descriptor() {
        return __stdio_common_vfwprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwprintf_p$handle() {
        return __stdio_common_vfwprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwprintf_p$address() {
        return __stdio_common_vfwprintf_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwprintf_p(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwprintf_p", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vfwscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwscanf$descriptor() {
        return __stdio_common_vfwscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwscanf$handle() {
        return __stdio_common_vfwscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwscanf$address() {
        return __stdio_common_vfwscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwscanf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwscanf", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vswprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswprintf$descriptor() {
        return __stdio_common_vswprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswprintf$handle() {
        return __stdio_common_vswprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswprintf$address() {
        return __stdio_common_vswprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswprintf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswprintf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vswprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswprintf_s$descriptor() {
        return __stdio_common_vswprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswprintf_s$handle() {
        return __stdio_common_vswprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswprintf_s$address() {
        return __stdio_common_vswprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswprintf_s", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsnwprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vsnwprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsnwprintf_s$descriptor() {
        return __stdio_common_vsnwprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsnwprintf_s$handle() {
        return __stdio_common_vsnwprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsnwprintf_s$address() {
        return __stdio_common_vsnwprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsnwprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, long _MaxCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsnwprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsnwprintf_s", _Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vswprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswprintf_p$descriptor() {
        return __stdio_common_vswprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswprintf_p$handle() {
        return __stdio_common_vswprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswprintf_p$address() {
        return __stdio_common_vswprintf_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswprintf_p(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswprintf_p", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__stdio_common_vswscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswscanf$descriptor() {
        return __stdio_common_vswscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswscanf$handle() {
        return __stdio_common_vswscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswscanf$address() {
        return __stdio_common_vswscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswscanf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswscanf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long long fpos_t
     * }
     */
    public static final OfLong fpos_t = ffmpeg_includes_h.C_LONG_LONG;

    private static class _get_stream_buffer_pointers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_get_stream_buffer_pointers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static FunctionDescriptor _get_stream_buffer_pointers$descriptor() {
        return _get_stream_buffer_pointers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static MethodHandle _get_stream_buffer_pointers$handle() {
        return _get_stream_buffer_pointers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static MemorySegment _get_stream_buffer_pointers$address() {
        return _get_stream_buffer_pointers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static int _get_stream_buffer_pointers(MemorySegment _Stream, MemorySegment _Base, MemorySegment _Pointer, MemorySegment _Count) {
        var mh$ = _get_stream_buffer_pointers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_stream_buffer_pointers", _Stream, _Base, _Pointer, _Count);
            }
            return (int)mh$.invokeExact(_Stream, _Base, _Pointer, _Count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clearerr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor clearerr_s$descriptor() {
        return clearerr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static MethodHandle clearerr_s$handle() {
        return clearerr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static MemorySegment clearerr_s$address() {
        return clearerr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static int clearerr_s(MemorySegment _Stream) {
        var mh$ = clearerr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_s", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static FunctionDescriptor fopen_s$descriptor() {
        return fopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static MethodHandle fopen_s$handle() {
        return fopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static MemorySegment fopen_s$address() {
        return fopen_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static int fopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = fopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen_s", _Stream, _FileName, _Mode);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fread_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fread_s$descriptor() {
        return fread_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fread_s$handle() {
        return fread_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fread_s$address() {
        return fread_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long fread_s(MemorySegment _Buffer, long _BufferSize, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = fread_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_s", _Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("freopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static FunctionDescriptor freopen_s$descriptor() {
        return freopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static MethodHandle freopen_s$handle() {
        return freopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment freopen_s$address() {
        return freopen_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static int freopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode, MemorySegment _OldStream) {
        var mh$ = freopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen_s", _Stream, _FileName, _Mode, _OldStream);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode, _OldStream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gets_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gets_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static FunctionDescriptor gets_s$descriptor() {
        return gets_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MethodHandle gets_s$handle() {
        return gets_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MemorySegment gets_s$address() {
        return gets_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MemorySegment gets_s(MemorySegment _Buffer, long _Size) {
        var mh$ = gets_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gets_s", _Buffer, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tmpfile_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static FunctionDescriptor tmpfile_s$descriptor() {
        return tmpfile_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static MethodHandle tmpfile_s$handle() {
        return tmpfile_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static MemorySegment tmpfile_s$address() {
        return tmpfile_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static int tmpfile_s(MemorySegment _Stream) {
        var mh$ = tmpfile_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile_s", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tmpnam_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static FunctionDescriptor tmpnam_s$descriptor() {
        return tmpnam_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MethodHandle tmpnam_s$handle() {
        return tmpnam_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MemorySegment tmpnam_s$address() {
        return tmpnam_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static int tmpnam_s(MemorySegment _Buffer, long _Size) {
        var mh$ = tmpnam_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_s", _Buffer, _Size);
            }
            return (int)mh$.invokeExact(_Buffer, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clearerr(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clearerr(FILE *_Stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clearerr(FILE *_Stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clearerr(FILE *_Stream)
     * }
     */
    public static void clearerr(MemorySegment _Stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fclose(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fclose(FILE *_Stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fclose(FILE *_Stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fclose(FILE *_Stream)
     * }
     */
    public static int fclose(MemorySegment _Stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcloseall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fcloseall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fcloseall()
     * }
     */
    public static FunctionDescriptor _fcloseall$descriptor() {
        return _fcloseall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fcloseall()
     * }
     */
    public static MethodHandle _fcloseall$handle() {
        return _fcloseall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fcloseall()
     * }
     */
    public static MemorySegment _fcloseall$address() {
        return _fcloseall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fcloseall()
     * }
     */
    public static int _fcloseall() {
        var mh$ = _fcloseall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcloseall");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static FunctionDescriptor _fdopen$descriptor() {
        return _fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static MethodHandle _fdopen$handle() {
        return _fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static MemorySegment _fdopen$address() {
        return _fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static MemorySegment _fdopen(int _FileHandle, MemorySegment _Mode) {
        var mh$ = _fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdopen", _FileHandle, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileHandle, _Mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int feof(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int feof(FILE *_Stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int feof(FILE *_Stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int feof(FILE *_Stream)
     * }
     */
    public static int feof(MemorySegment _Stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ferror(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ferror(FILE *_Stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ferror(FILE *_Stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ferror(FILE *_Stream)
     * }
     */
    public static int ferror(MemorySegment _Stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fflush(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fflush(FILE *_Stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fflush(FILE *_Stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fflush(FILE *_Stream)
     * }
     */
    public static int fflush(MemorySegment _Stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetc(FILE *_Stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetc(FILE *_Stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetc(FILE *_Stream)
     * }
     */
    public static int fgetc(MemorySegment _Stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fgetchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fgetchar()
     * }
     */
    public static FunctionDescriptor _fgetchar$descriptor() {
        return _fgetchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fgetchar()
     * }
     */
    public static MethodHandle _fgetchar$handle() {
        return _fgetchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fgetchar()
     * }
     */
    public static MemorySegment _fgetchar$address() {
        return _fgetchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fgetchar()
     * }
     */
    public static int _fgetchar() {
        var mh$ = _fgetchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetchar");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static int fgetpos(MemorySegment _Stream, MemorySegment _Position) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", _Stream, _Position);
            }
            return (int)mh$.invokeExact(_Stream, _Position);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment _Buffer, int _MaxCount, MemorySegment _Stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", _Buffer, _MaxCount, _Stream);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _MaxCount, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fileno(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fileno$descriptor() {
        return _fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fileno(FILE *_Stream)
     * }
     */
    public static MethodHandle _fileno$handle() {
        return _fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fileno(FILE *_Stream)
     * }
     */
    public static MemorySegment _fileno$address() {
        return _fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fileno(FILE *_Stream)
     * }
     */
    public static int _fileno(MemorySegment _Stream) {
        var mh$ = _fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fileno", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _flushall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_flushall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _flushall()
     * }
     */
    public static FunctionDescriptor _flushall$descriptor() {
        return _flushall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _flushall()
     * }
     */
    public static MethodHandle _flushall$handle() {
        return _flushall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _flushall()
     * }
     */
    public static MemorySegment _flushall$address() {
        return _flushall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _flushall()
     * }
     */
    public static int _flushall() {
        var mh$ = _flushall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_flushall");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static MemorySegment fopen(MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", _FileName, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static int fputc(int _Character, MemorySegment _Stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fputchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fputchar(int _Character)
     * }
     */
    public static FunctionDescriptor _fputchar$descriptor() {
        return _fputchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fputchar(int _Character)
     * }
     */
    public static MethodHandle _fputchar$handle() {
        return _fputchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fputchar(int _Character)
     * }
     */
    public static MemorySegment _fputchar$address() {
        return _fputchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fputchar(int _Character)
     * }
     */
    public static int _fputchar(int _Character) {
        var mh$ = _fputchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputchar", _Character);
            }
            return (int)mh$.invokeExact(_Character);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static int fputs(MemorySegment _Buffer, MemorySegment _Stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", _Buffer, _Stream);
            }
            return (int)mh$.invokeExact(_Buffer, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long fread(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment _FileName, MemorySegment _Mode, MemorySegment _Stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", _FileName, _Mode, _Stream);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fsopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fsopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static FunctionDescriptor _fsopen$descriptor() {
        return _fsopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static MethodHandle _fsopen$handle() {
        return _fsopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _fsopen$address() {
        return _fsopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _fsopen(MemorySegment _FileName, MemorySegment _Mode, int _ShFlag) {
        var mh$ = _fsopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fsopen", _FileName, _Mode, _ShFlag);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _ShFlag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static int fsetpos(MemorySegment _Stream, MemorySegment _Position) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", _Stream, _Position);
            }
            return (int)mh$.invokeExact(_Stream, _Position);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static int fseek(MemorySegment _Stream, int _Offset, int _Origin) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fseeki64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fseeki64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _fseeki64$descriptor() {
        return _fseeki64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _fseeki64$handle() {
        return _fseeki64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MemorySegment _fseeki64$address() {
        return _fseeki64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static int _fseeki64(MemorySegment _Stream, long _Offset, int _Origin) {
        var mh$ = _fseeki64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fseeki64", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long ftell(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long ftell(FILE *_Stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long ftell(FILE *_Stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long ftell(FILE *_Stream)
     * }
     */
    public static int ftell(MemorySegment _Stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ftelli64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ftelli64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ftelli64$descriptor() {
        return _ftelli64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static MethodHandle _ftelli64$handle() {
        return _ftelli64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static MemorySegment _ftelli64$address() {
        return _ftelli64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static long _ftelli64(MemorySegment _Stream) {
        var mh$ = _ftelli64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ftelli64", _Stream);
            }
            return (long)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long fwrite(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc(FILE *_Stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getc(FILE *_Stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getc(FILE *_Stream)
     * }
     */
    public static int getc(MemorySegment _Stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getmaxstdio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_getmaxstdio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _getmaxstdio()
     * }
     */
    public static FunctionDescriptor _getmaxstdio$descriptor() {
        return _getmaxstdio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _getmaxstdio()
     * }
     */
    public static MethodHandle _getmaxstdio$handle() {
        return _getmaxstdio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _getmaxstdio()
     * }
     */
    public static MemorySegment _getmaxstdio$address() {
        return _getmaxstdio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _getmaxstdio()
     * }
     */
    public static int _getmaxstdio() {
        var mh$ = _getmaxstdio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getmaxstdio");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _getw(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _getw$descriptor() {
        return _getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _getw(FILE *_Stream)
     * }
     */
    public static MethodHandle _getw$handle() {
        return _getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _getw(FILE *_Stream)
     * }
     */
    public static MemorySegment _getw$address() {
        return _getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _getw(FILE *_Stream)
     * }
     */
    public static int _getw(MemorySegment _Stream) {
        var mh$ = _getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getw", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perror(const char *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perror(const char *_ErrorMessage)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void perror(const char *_ErrorMessage)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void perror(const char *_ErrorMessage)
     * }
     */
    public static void perror(MemorySegment _ErrorMessage) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", _ErrorMessage);
            }
            mh$.invokeExact(_ErrorMessage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _pclose(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _pclose$descriptor() {
        return _pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _pclose(FILE *_Stream)
     * }
     */
    public static MethodHandle _pclose$handle() {
        return _pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _pclose(FILE *_Stream)
     * }
     */
    public static MemorySegment _pclose$address() {
        return _pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _pclose(FILE *_Stream)
     * }
     */
    public static int _pclose(MemorySegment _Stream) {
        var mh$ = _pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_pclose", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static FunctionDescriptor _popen$descriptor() {
        return _popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static MethodHandle _popen$handle() {
        return _popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static MemorySegment _popen$address() {
        return _popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static MemorySegment _popen(MemorySegment _Command, MemorySegment _Mode) {
        var mh$ = _popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_popen", _Command, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_Command, _Mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static int putc(int _Character, MemorySegment _Stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar(int _Character)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar(int _Character)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putchar(int _Character)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putchar(int _Character)
     * }
     */
    public static int putchar(int _Character) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", _Character);
            }
            return (int)mh$.invokeExact(_Character);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int puts(const char *_Buffer)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int puts(const char *_Buffer)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int puts(const char *_Buffer)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int puts(const char *_Buffer)
     * }
     */
    public static int puts(MemorySegment _Buffer) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", _Buffer);
            }
            return (int)mh$.invokeExact(_Buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _putw$descriptor() {
        return _putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static MethodHandle _putw$handle() {
        return _putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static MemorySegment _putw$address() {
        return _putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static int _putw(int _Word, MemorySegment _Stream) {
        var mh$ = _putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putw", _Word, _Stream);
            }
            return (int)mh$.invokeExact(_Word, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int remove(const char *_FileName)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int remove(const char *_FileName)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int remove(const char *_FileName)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int remove(const char *_FileName)
     * }
     */
    public static int remove(MemorySegment _FileName) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rename(const char *_OldFileName, const char *_NewFileName)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rename(const char *_OldFileName, const char *_NewFileName)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rename(const char *_OldFileName, const char *_NewFileName)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rename(const char *_OldFileName, const char *_NewFileName)
     * }
     */
    public static int rename(MemorySegment _OldFileName, MemorySegment _NewFileName) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", _OldFileName, _NewFileName);
            }
            return (int)mh$.invokeExact(_OldFileName, _NewFileName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _unlink(const char *_FileName)
     * }
     */
    public static FunctionDescriptor _unlink$descriptor() {
        return _unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _unlink(const char *_FileName)
     * }
     */
    public static MethodHandle _unlink$handle() {
        return _unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _unlink(const char *_FileName)
     * }
     */
    public static MemorySegment _unlink$address() {
        return _unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _unlink(const char *_FileName)
     * }
     */
    public static int _unlink(MemorySegment _FileName) {
        var mh$ = _unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_unlink", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlink(const char *_FileName)
     * }
     */
    public static FunctionDescriptor unlink$descriptor() {
        return unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlink(const char *_FileName)
     * }
     */
    public static MethodHandle unlink$handle() {
        return unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlink(const char *_FileName)
     * }
     */
    public static MemorySegment unlink$address() {
        return unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlink(const char *_FileName)
     * }
     */
    public static int unlink(MemorySegment _FileName) {
        var mh$ = unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlink", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rewind(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rewind(FILE *_Stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rewind(FILE *_Stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rewind(FILE *_Stream)
     * }
     */
    public static void rewind(MemorySegment _Stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rmtmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_rmtmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _rmtmp()
     * }
     */
    public static FunctionDescriptor _rmtmp$descriptor() {
        return _rmtmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _rmtmp()
     * }
     */
    public static MethodHandle _rmtmp$handle() {
        return _rmtmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _rmtmp()
     * }
     */
    public static MemorySegment _rmtmp$address() {
        return _rmtmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _rmtmp()
     * }
     */
    public static int _rmtmp() {
        var mh$ = _rmtmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rmtmp");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static void setbuf(MemorySegment _Stream, MemorySegment _Buffer) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", _Stream, _Buffer);
            }
            mh$.invokeExact(_Stream, _Buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _setmaxstdio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_setmaxstdio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _setmaxstdio(int _Maximum)
     * }
     */
    public static FunctionDescriptor _setmaxstdio$descriptor() {
        return _setmaxstdio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _setmaxstdio(int _Maximum)
     * }
     */
    public static MethodHandle _setmaxstdio$handle() {
        return _setmaxstdio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _setmaxstdio(int _Maximum)
     * }
     */
    public static MemorySegment _setmaxstdio$address() {
        return _setmaxstdio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _setmaxstdio(int _Maximum)
     * }
     */
    public static int _setmaxstdio(int _Maximum) {
        var mh$ = _setmaxstdio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_setmaxstdio", _Maximum);
            }
            return (int)mh$.invokeExact(_Maximum);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static int setvbuf(MemorySegment _Stream, MemorySegment _Buffer, int _Mode, long _Size) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", _Stream, _Buffer, _Mode, _Size);
            }
            return (int)mh$.invokeExact(_Stream, _Buffer, _Mode, _Size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static FunctionDescriptor _tempnam$descriptor() {
        return _tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static MethodHandle _tempnam$handle() {
        return _tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static MemorySegment _tempnam$address() {
        return _tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static MemorySegment _tempnam(MemorySegment _DirectoryName, MemorySegment _FilePrefix) {
        var mh$ = _tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_tempnam", _DirectoryName, _FilePrefix);
            }
            return (MemorySegment)mh$.invokeExact(_DirectoryName, _FilePrefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tmpnam(char *_Buffer)
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tmpnam(char *_Buffer)
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tmpnam(char *_Buffer)
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tmpnam(char *_Buffer)
     * }
     */
    public static MemorySegment tmpnam(MemorySegment _Buffer) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static int ungetc(int _Character, MemorySegment _Stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lock_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_lock_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _lock_file(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _lock_file$descriptor() {
        return _lock_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _lock_file(FILE *_Stream)
     * }
     */
    public static MethodHandle _lock_file$handle() {
        return _lock_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _lock_file(FILE *_Stream)
     * }
     */
    public static MemorySegment _lock_file$address() {
        return _lock_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _lock_file(FILE *_Stream)
     * }
     */
    public static void _lock_file(MemorySegment _Stream) {
        var mh$ = _lock_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lock_file", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _unlock_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_unlock_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _unlock_file(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _unlock_file$descriptor() {
        return _unlock_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _unlock_file(FILE *_Stream)
     * }
     */
    public static MethodHandle _unlock_file$handle() {
        return _unlock_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _unlock_file(FILE *_Stream)
     * }
     */
    public static MemorySegment _unlock_file$address() {
        return _unlock_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _unlock_file(FILE *_Stream)
     * }
     */
    public static void _unlock_file(MemorySegment _Stream) {
        var mh$ = _unlock_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_unlock_file", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fclose_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fclose_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fclose_nolock$descriptor() {
        return _fclose_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fclose_nolock$handle() {
        return _fclose_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fclose_nolock$address() {
        return _fclose_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static int _fclose_nolock(MemorySegment _Stream) {
        var mh$ = _fclose_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fclose_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fflush_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fflush_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fflush_nolock$descriptor() {
        return _fflush_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fflush_nolock$handle() {
        return _fflush_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fflush_nolock$address() {
        return _fflush_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static int _fflush_nolock(MemorySegment _Stream) {
        var mh$ = _fflush_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fflush_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fgetc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fgetc_nolock$descriptor() {
        return _fgetc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fgetc_nolock$handle() {
        return _fgetc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fgetc_nolock$address() {
        return _fgetc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static int _fgetc_nolock(MemorySegment _Stream) {
        var mh$ = _fgetc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetc_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fputc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fputc_nolock$descriptor() {
        return _fputc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _fputc_nolock$handle() {
        return _fputc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _fputc_nolock$address() {
        return _fputc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static int _fputc_nolock(int _Character, MemorySegment _Stream) {
        var mh$ = _fputc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputc_nolock", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fread_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fread_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fread_nolock$descriptor() {
        return _fread_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle _fread_nolock$handle() {
        return _fread_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment _fread_nolock$address() {
        return _fread_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long _fread_nolock(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = _fread_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fread_nolock", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fread_nolock_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fread_nolock_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fread_nolock_s$descriptor() {
        return _fread_nolock_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle _fread_nolock_s$handle() {
        return _fread_nolock_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment _fread_nolock_s$address() {
        return _fread_nolock_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long _fread_nolock_s(MemorySegment _Buffer, long _BufferSize, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = _fread_nolock_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fread_nolock_s", _Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fseek_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fseek_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _fseek_nolock$descriptor() {
        return _fseek_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _fseek_nolock$handle() {
        return _fseek_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MemorySegment _fseek_nolock$address() {
        return _fseek_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static int _fseek_nolock(MemorySegment _Stream, int _Offset, int _Origin) {
        var mh$ = _fseek_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fseek_nolock", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fseeki64_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fseeki64_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _fseeki64_nolock$descriptor() {
        return _fseeki64_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _fseeki64_nolock$handle() {
        return _fseeki64_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MemorySegment _fseeki64_nolock$address() {
        return _fseeki64_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static int _fseeki64_nolock(MemorySegment _Stream, long _Offset, int _Origin) {
        var mh$ = _fseeki64_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fseeki64_nolock", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ftell_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ftell_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ftell_nolock$descriptor() {
        return _ftell_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _ftell_nolock$handle() {
        return _ftell_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _ftell_nolock$address() {
        return _ftell_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static int _ftell_nolock(MemorySegment _Stream) {
        var mh$ = _ftell_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ftell_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ftelli64_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ftelli64_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ftelli64_nolock$descriptor() {
        return _ftelli64_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _ftelli64_nolock$handle() {
        return _ftelli64_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _ftelli64_nolock$address() {
        return _ftelli64_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static long _ftelli64_nolock(MemorySegment _Stream) {
        var mh$ = _ftelli64_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ftelli64_nolock", _Stream);
            }
            return (long)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fwrite_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_LONG_LONG,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_fwrite_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fwrite_nolock$descriptor() {
        return _fwrite_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle _fwrite_nolock$handle() {
        return _fwrite_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment _fwrite_nolock$address() {
        return _fwrite_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long _fwrite_nolock(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = _fwrite_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fwrite_nolock", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_getc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _getc_nolock$descriptor() {
        return _getc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _getc_nolock$handle() {
        return _getc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _getc_nolock$address() {
        return _getc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static int _getc_nolock(MemorySegment _Stream) {
        var mh$ = _getc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getc_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_putc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _putc_nolock$descriptor() {
        return _putc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _putc_nolock$handle() {
        return _putc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _putc_nolock$address() {
        return _putc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static int _putc_nolock(int _Character, MemorySegment _Stream) {
        var mh$ = _putc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putc_nolock", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ungetc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_INT,
            ffmpeg_includes_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_ungetc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ungetc_nolock$descriptor() {
        return _ungetc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _ungetc_nolock$handle() {
        return _ungetc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _ungetc_nolock$address() {
        return _ungetc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static int _ungetc_nolock(int _Character, MemorySegment _Stream) {
        var mh$ = _ungetc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ungetc_nolock", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

